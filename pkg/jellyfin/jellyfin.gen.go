// Package jellyfin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package jellyfin

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	CustomAuthenticationScopes = "CustomAuthentication.Scopes"
)

// Defines values for Architecture.
const (
	Arm   Architecture = "Arm"
	Arm64 Architecture = "Arm64"
	S390x Architecture = "S390x"
	Wasm  Architecture = "Wasm"
	X64   Architecture = "X64"
	X86   Architecture = "X86"
)

// Defines values for BaseItemKind.
const (
	BaseItemKindAggregateFolder       BaseItemKind = "AggregateFolder"
	BaseItemKindAudio                 BaseItemKind = "Audio"
	BaseItemKindAudioBook             BaseItemKind = "AudioBook"
	BaseItemKindBasePluginFolder      BaseItemKind = "BasePluginFolder"
	BaseItemKindBook                  BaseItemKind = "Book"
	BaseItemKindBoxSet                BaseItemKind = "BoxSet"
	BaseItemKindChannel               BaseItemKind = "Channel"
	BaseItemKindChannelFolderItem     BaseItemKind = "ChannelFolderItem"
	BaseItemKindCollectionFolder      BaseItemKind = "CollectionFolder"
	BaseItemKindEpisode               BaseItemKind = "Episode"
	BaseItemKindFolder                BaseItemKind = "Folder"
	BaseItemKindGenre                 BaseItemKind = "Genre"
	BaseItemKindLiveTvChannel         BaseItemKind = "LiveTvChannel"
	BaseItemKindLiveTvProgram         BaseItemKind = "LiveTvProgram"
	BaseItemKindManualPlaylistsFolder BaseItemKind = "ManualPlaylistsFolder"
	BaseItemKindMovie                 BaseItemKind = "Movie"
	BaseItemKindMusicAlbum            BaseItemKind = "MusicAlbum"
	BaseItemKindMusicArtist           BaseItemKind = "MusicArtist"
	BaseItemKindMusicGenre            BaseItemKind = "MusicGenre"
	BaseItemKindMusicVideo            BaseItemKind = "MusicVideo"
	BaseItemKindPerson                BaseItemKind = "Person"
	BaseItemKindPhoto                 BaseItemKind = "Photo"
	BaseItemKindPhotoAlbum            BaseItemKind = "PhotoAlbum"
	BaseItemKindPlaylist              BaseItemKind = "Playlist"
	BaseItemKindPlaylistsFolder       BaseItemKind = "PlaylistsFolder"
	BaseItemKindProgram               BaseItemKind = "Program"
	BaseItemKindRecording             BaseItemKind = "Recording"
	BaseItemKindSeason                BaseItemKind = "Season"
	BaseItemKindSeries                BaseItemKind = "Series"
	BaseItemKindStudio                BaseItemKind = "Studio"
	BaseItemKindTrailer               BaseItemKind = "Trailer"
	BaseItemKindTvChannel             BaseItemKind = "TvChannel"
	BaseItemKindTvProgram             BaseItemKind = "TvProgram"
	BaseItemKindUserRootFolder        BaseItemKind = "UserRootFolder"
	BaseItemKindUserView              BaseItemKind = "UserView"
	BaseItemKindVideo                 BaseItemKind = "Video"
	BaseItemKindYear                  BaseItemKind = "Year"
)

// Defines values for ChannelItemSortField.
const (
	ChannelItemSortFieldCommunityPlayCount ChannelItemSortField = "CommunityPlayCount"
	ChannelItemSortFieldCommunityRating    ChannelItemSortField = "CommunityRating"
	ChannelItemSortFieldDateCreated        ChannelItemSortField = "DateCreated"
	ChannelItemSortFieldName               ChannelItemSortField = "Name"
	ChannelItemSortFieldPlayCount          ChannelItemSortField = "PlayCount"
	ChannelItemSortFieldPremiereDate       ChannelItemSortField = "PremiereDate"
	ChannelItemSortFieldRuntime            ChannelItemSortField = "Runtime"
)

// Defines values for ChannelMediaContentType.
const (
	ChannelMediaContentTypeClip       ChannelMediaContentType = "Clip"
	ChannelMediaContentTypeEpisode    ChannelMediaContentType = "Episode"
	ChannelMediaContentTypeMovie      ChannelMediaContentType = "Movie"
	ChannelMediaContentTypeMovieExtra ChannelMediaContentType = "MovieExtra"
	ChannelMediaContentTypePodcast    ChannelMediaContentType = "Podcast"
	ChannelMediaContentTypeSong       ChannelMediaContentType = "Song"
	ChannelMediaContentTypeTrailer    ChannelMediaContentType = "Trailer"
	ChannelMediaContentTypeTvExtra    ChannelMediaContentType = "TvExtra"
)

// Defines values for ChannelMediaType.
const (
	ChannelMediaTypeAudio ChannelMediaType = "Audio"
	ChannelMediaTypePhoto ChannelMediaType = "Photo"
	ChannelMediaTypeVideo ChannelMediaType = "Video"
)

// Defines values for ChannelType.
const (
	Radio ChannelType = "Radio"
	TV    ChannelType = "TV"
)

// Defines values for CodecType.
const (
	CodecTypeAudio      CodecType = "Audio"
	CodecTypeVideo      CodecType = "Video"
	CodecTypeVideoAudio CodecType = "VideoAudio"
)

// Defines values for CollectionTypeOptions.
const (
	CollectionTypeOptionsBooks       CollectionTypeOptions = "Books"
	CollectionTypeOptionsBoxSets     CollectionTypeOptions = "BoxSets"
	CollectionTypeOptionsHomeVideos  CollectionTypeOptions = "HomeVideos"
	CollectionTypeOptionsMixed       CollectionTypeOptions = "Mixed"
	CollectionTypeOptionsMovies      CollectionTypeOptions = "Movies"
	CollectionTypeOptionsMusic       CollectionTypeOptions = "Music"
	CollectionTypeOptionsMusicVideos CollectionTypeOptions = "MusicVideos"
	CollectionTypeOptionsTvShows     CollectionTypeOptions = "TvShows"
)

// Defines values for DayOfWeek.
const (
	DayOfWeekFriday    DayOfWeek = "Friday"
	DayOfWeekMonday    DayOfWeek = "Monday"
	DayOfWeekSaturday  DayOfWeek = "Saturday"
	DayOfWeekSunday    DayOfWeek = "Sunday"
	DayOfWeekThursday  DayOfWeek = "Thursday"
	DayOfWeekTuesday   DayOfWeek = "Tuesday"
	DayOfWeekWednesday DayOfWeek = "Wednesday"
)

// Defines values for DayPattern.
const (
	Daily    DayPattern = "Daily"
	Weekdays DayPattern = "Weekdays"
	Weekends DayPattern = "Weekends"
)

// Defines values for DeviceProfileType.
const (
	DeviceProfileTypeSystem DeviceProfileType = "System"
	DeviceProfileTypeUser   DeviceProfileType = "User"
)

// Defines values for DlnaProfileType.
const (
	DlnaProfileTypeAudio    DlnaProfileType = "Audio"
	DlnaProfileTypePhoto    DlnaProfileType = "Photo"
	DlnaProfileTypeSubtitle DlnaProfileType = "Subtitle"
	DlnaProfileTypeVideo    DlnaProfileType = "Video"
)

// Defines values for DynamicDayOfWeek.
const (
	DynamicDayOfWeekEveryday  DynamicDayOfWeek = "Everyday"
	DynamicDayOfWeekFriday    DynamicDayOfWeek = "Friday"
	DynamicDayOfWeekMonday    DynamicDayOfWeek = "Monday"
	DynamicDayOfWeekSaturday  DynamicDayOfWeek = "Saturday"
	DynamicDayOfWeekSunday    DynamicDayOfWeek = "Sunday"
	DynamicDayOfWeekThursday  DynamicDayOfWeek = "Thursday"
	DynamicDayOfWeekTuesday   DynamicDayOfWeek = "Tuesday"
	DynamicDayOfWeekWednesday DynamicDayOfWeek = "Wednesday"
	DynamicDayOfWeekWeekday   DynamicDayOfWeek = "Weekday"
	DynamicDayOfWeekWeekend   DynamicDayOfWeek = "Weekend"
)

// Defines values for EmbeddedSubtitleOptions.
const (
	AllowAll   EmbeddedSubtitleOptions = "AllowAll"
	AllowImage EmbeddedSubtitleOptions = "AllowImage"
	AllowNone  EmbeddedSubtitleOptions = "AllowNone"
	AllowText  EmbeddedSubtitleOptions = "AllowText"
)

// Defines values for EncodingContext.
const (
	Static    EncodingContext = "Static"
	Streaming EncodingContext = "Streaming"
)

// Defines values for ExternalIdMediaType.
const (
	ExternalIdMediaTypeAlbum        ExternalIdMediaType = "Album"
	ExternalIdMediaTypeAlbumArtist  ExternalIdMediaType = "AlbumArtist"
	ExternalIdMediaTypeArtist       ExternalIdMediaType = "Artist"
	ExternalIdMediaTypeBoxSet       ExternalIdMediaType = "BoxSet"
	ExternalIdMediaTypeEpisode      ExternalIdMediaType = "Episode"
	ExternalIdMediaTypeMovie        ExternalIdMediaType = "Movie"
	ExternalIdMediaTypeOtherArtist  ExternalIdMediaType = "OtherArtist"
	ExternalIdMediaTypePerson       ExternalIdMediaType = "Person"
	ExternalIdMediaTypeReleaseGroup ExternalIdMediaType = "ReleaseGroup"
	ExternalIdMediaTypeSeason       ExternalIdMediaType = "Season"
	ExternalIdMediaTypeSeries       ExternalIdMediaType = "Series"
	ExternalIdMediaTypeTrack        ExternalIdMediaType = "Track"
)

// Defines values for FFmpegLocation.
const (
	FFmpegLocationCustom        FFmpegLocation = "Custom"
	FFmpegLocationNotFound      FFmpegLocation = "NotFound"
	FFmpegLocationSetByArgument FFmpegLocation = "SetByArgument"
	FFmpegLocationSystem        FFmpegLocation = "System"
)

// Defines values for FileSystemEntryType.
const (
	FileSystemEntryTypeDirectory       FileSystemEntryType = "Directory"
	FileSystemEntryTypeFile            FileSystemEntryType = "File"
	FileSystemEntryTypeNetworkComputer FileSystemEntryType = "NetworkComputer"
	FileSystemEntryTypeNetworkShare    FileSystemEntryType = "NetworkShare"
)

// Defines values for ForgotPasswordAction.
const (
	ContactAdmin      ForgotPasswordAction = "ContactAdmin"
	InNetworkRequired ForgotPasswordAction = "InNetworkRequired"
	PinCode           ForgotPasswordAction = "PinCode"
)

// Defines values for GeneralCommandType.
const (
	GeneralCommandTypeBack                   GeneralCommandType = "Back"
	GeneralCommandTypeChannelDown            GeneralCommandType = "ChannelDown"
	GeneralCommandTypeChannelUp              GeneralCommandType = "ChannelUp"
	GeneralCommandTypeDisplayContent         GeneralCommandType = "DisplayContent"
	GeneralCommandTypeDisplayMessage         GeneralCommandType = "DisplayMessage"
	GeneralCommandTypeGoHome                 GeneralCommandType = "GoHome"
	GeneralCommandTypeGoToSearch             GeneralCommandType = "GoToSearch"
	GeneralCommandTypeGoToSettings           GeneralCommandType = "GoToSettings"
	GeneralCommandTypeGuide                  GeneralCommandType = "Guide"
	GeneralCommandTypeMoveDown               GeneralCommandType = "MoveDown"
	GeneralCommandTypeMoveLeft               GeneralCommandType = "MoveLeft"
	GeneralCommandTypeMoveRight              GeneralCommandType = "MoveRight"
	GeneralCommandTypeMoveUp                 GeneralCommandType = "MoveUp"
	GeneralCommandTypeMute                   GeneralCommandType = "Mute"
	GeneralCommandTypeNextLetter             GeneralCommandType = "NextLetter"
	GeneralCommandTypePageDown               GeneralCommandType = "PageDown"
	GeneralCommandTypePageUp                 GeneralCommandType = "PageUp"
	GeneralCommandTypePlay                   GeneralCommandType = "Play"
	GeneralCommandTypePlayMediaSource        GeneralCommandType = "PlayMediaSource"
	GeneralCommandTypePlayNext               GeneralCommandType = "PlayNext"
	GeneralCommandTypePlayState              GeneralCommandType = "PlayState"
	GeneralCommandTypePlayTrailers           GeneralCommandType = "PlayTrailers"
	GeneralCommandTypePreviousLetter         GeneralCommandType = "PreviousLetter"
	GeneralCommandTypeSelect                 GeneralCommandType = "Select"
	GeneralCommandTypeSendKey                GeneralCommandType = "SendKey"
	GeneralCommandTypeSendString             GeneralCommandType = "SendString"
	GeneralCommandTypeSetAudioStreamIndex    GeneralCommandType = "SetAudioStreamIndex"
	GeneralCommandTypeSetMaxStreamingBitrate GeneralCommandType = "SetMaxStreamingBitrate"
	GeneralCommandTypeSetRepeatMode          GeneralCommandType = "SetRepeatMode"
	GeneralCommandTypeSetShuffleQueue        GeneralCommandType = "SetShuffleQueue"
	GeneralCommandTypeSetSubtitleStreamIndex GeneralCommandType = "SetSubtitleStreamIndex"
	GeneralCommandTypeSetVolume              GeneralCommandType = "SetVolume"
	GeneralCommandTypeTakeScreenshot         GeneralCommandType = "TakeScreenshot"
	GeneralCommandTypeToggleContextMenu      GeneralCommandType = "ToggleContextMenu"
	GeneralCommandTypeToggleFullscreen       GeneralCommandType = "ToggleFullscreen"
	GeneralCommandTypeToggleMute             GeneralCommandType = "ToggleMute"
	GeneralCommandTypeToggleOsd              GeneralCommandType = "ToggleOsd"
	GeneralCommandTypeToggleOsdMenu          GeneralCommandType = "ToggleOsdMenu"
	GeneralCommandTypeToggleStats            GeneralCommandType = "ToggleStats"
	GeneralCommandTypeUnmute                 GeneralCommandType = "Unmute"
	GeneralCommandTypeVolumeDown             GeneralCommandType = "VolumeDown"
	GeneralCommandTypeVolumeUp               GeneralCommandType = "VolumeUp"
)

// Defines values for GroupQueueMode.
const (
	Queue     GroupQueueMode = "Queue"
	QueueNext GroupQueueMode = "QueueNext"
)

// Defines values for GroupRepeatMode.
const (
	GroupRepeatModeRepeatAll  GroupRepeatMode = "RepeatAll"
	GroupRepeatModeRepeatNone GroupRepeatMode = "RepeatNone"
	GroupRepeatModeRepeatOne  GroupRepeatMode = "RepeatOne"
)

// Defines values for GroupShuffleMode.
const (
	Shuffle GroupShuffleMode = "Shuffle"
	Sorted  GroupShuffleMode = "Sorted"
)

// Defines values for GroupStateType.
const (
	GroupStateTypeIdle    GroupStateType = "Idle"
	GroupStateTypePaused  GroupStateType = "Paused"
	GroupStateTypePlaying GroupStateType = "Playing"
	GroupStateTypeWaiting GroupStateType = "Waiting"
)

// Defines values for HardwareEncodingType.
const (
	AMF          HardwareEncodingType = "AMF"
	NVENC        HardwareEncodingType = "NVENC"
	QSV          HardwareEncodingType = "QSV"
	V4L2M2M      HardwareEncodingType = "V4L2M2M"
	VAAPI        HardwareEncodingType = "VAAPI"
	VideoToolBox HardwareEncodingType = "VideoToolBox"
)

// Defines values for HeaderMatchType.
const (
	HeaderMatchTypeEquals    HeaderMatchType = "Equals"
	HeaderMatchTypeRegex     HeaderMatchType = "Regex"
	HeaderMatchTypeSubstring HeaderMatchType = "Substring"
)

// Defines values for HeaderMetadata.
const (
	HeaderMetadataActor            HeaderMetadata = "Actor"
	HeaderMetadataAlbum            HeaderMetadata = "Album"
	HeaderMetadataAlbumArtist      HeaderMetadata = "AlbumArtist"
	HeaderMetadataArtist           HeaderMetadata = "Artist"
	HeaderMetadataAudio            HeaderMetadata = "Audio"
	HeaderMetadataAudioAlbum       HeaderMetadata = "AudioAlbum"
	HeaderMetadataAudioAlbumArtist HeaderMetadata = "AudioAlbumArtist"
	HeaderMetadataCommunityRating  HeaderMetadata = "CommunityRating"
	HeaderMetadataCommunityRatings HeaderMetadata = "CommunityRatings"
	HeaderMetadataComposer         HeaderMetadata = "Composer"
	HeaderMetadataCountries        HeaderMetadata = "Countries"
	HeaderMetadataDate             HeaderMetadata = "Date"
	HeaderMetadataDateAdded        HeaderMetadata = "DateAdded"
	HeaderMetadataDirector         HeaderMetadata = "Director"
	HeaderMetadataDisc             HeaderMetadata = "Disc"
	HeaderMetadataEmbeddedImage    HeaderMetadata = "EmbeddedImage"
	HeaderMetadataEpisodeNumber    HeaderMetadata = "EpisodeNumber"
	HeaderMetadataEpisodeSeason    HeaderMetadata = "EpisodeSeason"
	HeaderMetadataEpisodeSeries    HeaderMetadata = "EpisodeSeries"
	HeaderMetadataGenres           HeaderMetadata = "Genres"
	HeaderMetadataGuestStar        HeaderMetadata = "GuestStar"
	HeaderMetadataImageBackdrop    HeaderMetadata = "ImageBackdrop"
	HeaderMetadataImageLogo        HeaderMetadata = "ImageLogo"
	HeaderMetadataImagePrimary     HeaderMetadata = "ImagePrimary"
	HeaderMetadataItem             HeaderMetadata = "Item"
	HeaderMetadataLocked           HeaderMetadata = "Locked"
	HeaderMetadataMusicArtist      HeaderMetadata = "MusicArtist"
	HeaderMetadataName             HeaderMetadata = "Name"
	HeaderMetadataNetwork          HeaderMetadata = "Network"
	HeaderMetadataNone             HeaderMetadata = "None"
	HeaderMetadataOverview         HeaderMetadata = "Overview"
	HeaderMetadataParentalRating   HeaderMetadata = "ParentalRating"
	HeaderMetadataParentalRatings  HeaderMetadata = "ParentalRatings"
	HeaderMetadataPath             HeaderMetadata = "Path"
	HeaderMetadataPlayCount        HeaderMetadata = "PlayCount"
	HeaderMetadataPremiereDate     HeaderMetadata = "PremiereDate"
	HeaderMetadataProducer         HeaderMetadata = "Producer"
	HeaderMetadataReleaseDate      HeaderMetadata = "ReleaseDate"
	HeaderMetadataResolution       HeaderMetadata = "Resolution"
	HeaderMetadataRuntime          HeaderMetadata = "Runtime"
	HeaderMetadataSeason           HeaderMetadata = "Season"
	HeaderMetadataSeasonNumber     HeaderMetadata = "SeasonNumber"
	HeaderMetadataSeries           HeaderMetadata = "Series"
	HeaderMetadataSeverity         HeaderMetadata = "Severity"
	HeaderMetadataShortOverview    HeaderMetadata = "ShortOverview"
	HeaderMetadataSpecials         HeaderMetadata = "Specials"
	HeaderMetadataStatus           HeaderMetadata = "Status"
	HeaderMetadataStudios          HeaderMetadata = "Studios"
	HeaderMetadataSubtitles        HeaderMetadata = "Subtitles"
	HeaderMetadataTrack            HeaderMetadata = "Track"
	HeaderMetadataTracks           HeaderMetadata = "Tracks"
	HeaderMetadataTrailers         HeaderMetadata = "Trailers"
	HeaderMetadataType             HeaderMetadata = "Type"
	HeaderMetadataUser             HeaderMetadata = "User"
	HeaderMetadataUserId           HeaderMetadata = "UserId"
	HeaderMetadataUserPrimaryImage HeaderMetadata = "UserPrimaryImage"
	HeaderMetadataVideo            HeaderMetadata = "Video"
	HeaderMetadataWriter           HeaderMetadata = "Writer"
	HeaderMetadataYear             HeaderMetadata = "Year"
	HeaderMetadataYears            HeaderMetadata = "Years"
)

// Defines values for ImageFormat.
const (
	Bmp  ImageFormat = "Bmp"
	Gif  ImageFormat = "Gif"
	Jpg  ImageFormat = "Jpg"
	Png  ImageFormat = "Png"
	Webp ImageFormat = "Webp"
)

// Defines values for ImageOrientation.
const (
	BottomLeft  ImageOrientation = "BottomLeft"
	BottomRight ImageOrientation = "BottomRight"
	LeftBottom  ImageOrientation = "LeftBottom"
	LeftTop     ImageOrientation = "LeftTop"
	RightBottom ImageOrientation = "RightBottom"
	RightTop    ImageOrientation = "RightTop"
	TopLeft     ImageOrientation = "TopLeft"
	TopRight    ImageOrientation = "TopRight"
)

// Defines values for ImageSavingConvention.
const (
	Compatible ImageSavingConvention = "Compatible"
	Legacy     ImageSavingConvention = "Legacy"
)

// Defines values for ImageType.
const (
	Art        ImageType = "Art"
	Backdrop   ImageType = "Backdrop"
	Banner     ImageType = "Banner"
	Box        ImageType = "Box"
	BoxRear    ImageType = "BoxRear"
	Chapter    ImageType = "Chapter"
	Disc       ImageType = "Disc"
	Logo       ImageType = "Logo"
	Menu       ImageType = "Menu"
	Primary    ImageType = "Primary"
	Profile    ImageType = "Profile"
	Screenshot ImageType = "Screenshot"
	Thumb      ImageType = "Thumb"
)

// Defines values for IsoType.
const (
	IsoTypeBluRay IsoType = "BluRay"
	IsoTypeDvd    IsoType = "Dvd"
)

// Defines values for ItemFields.
const (
	ItemFieldsAirTime                      ItemFields = "AirTime"
	ItemFieldsBasicSyncInfo                ItemFields = "BasicSyncInfo"
	ItemFieldsCanDelete                    ItemFields = "CanDelete"
	ItemFieldsCanDownload                  ItemFields = "CanDownload"
	ItemFieldsChannelImage                 ItemFields = "ChannelImage"
	ItemFieldsChannelInfo                  ItemFields = "ChannelInfo"
	ItemFieldsChapters                     ItemFields = "Chapters"
	ItemFieldsChildCount                   ItemFields = "ChildCount"
	ItemFieldsCumulativeRunTimeTicks       ItemFields = "CumulativeRunTimeTicks"
	ItemFieldsCustomRating                 ItemFields = "CustomRating"
	ItemFieldsDateCreated                  ItemFields = "DateCreated"
	ItemFieldsDateLastMediaAdded           ItemFields = "DateLastMediaAdded"
	ItemFieldsDateLastRefreshed            ItemFields = "DateLastRefreshed"
	ItemFieldsDateLastSaved                ItemFields = "DateLastSaved"
	ItemFieldsDisplayPreferencesId         ItemFields = "DisplayPreferencesId"
	ItemFieldsEnableMediaSourceDisplay     ItemFields = "EnableMediaSourceDisplay"
	ItemFieldsEtag                         ItemFields = "Etag"
	ItemFieldsExternalEtag                 ItemFields = "ExternalEtag"
	ItemFieldsExternalSeriesId             ItemFields = "ExternalSeriesId"
	ItemFieldsExternalUrls                 ItemFields = "ExternalUrls"
	ItemFieldsExtraIds                     ItemFields = "ExtraIds"
	ItemFieldsGenres                       ItemFields = "Genres"
	ItemFieldsHeight                       ItemFields = "Height"
	ItemFieldsHomePageUrl                  ItemFields = "HomePageUrl"
	ItemFieldsInheritedParentalRatingValue ItemFields = "InheritedParentalRatingValue"
	ItemFieldsIsHD                         ItemFields = "IsHD"
	ItemFieldsItemCounts                   ItemFields = "ItemCounts"
	ItemFieldsLocalTrailerCount            ItemFields = "LocalTrailerCount"
	ItemFieldsMediaSourceCount             ItemFields = "MediaSourceCount"
	ItemFieldsMediaSources                 ItemFields = "MediaSources"
	ItemFieldsMediaStreams                 ItemFields = "MediaStreams"
	ItemFieldsOriginalTitle                ItemFields = "OriginalTitle"
	ItemFieldsOverview                     ItemFields = "Overview"
	ItemFieldsParentId                     ItemFields = "ParentId"
	ItemFieldsPath                         ItemFields = "Path"
	ItemFieldsPeople                       ItemFields = "People"
	ItemFieldsPlayAccess                   ItemFields = "PlayAccess"
	ItemFieldsPresentationUniqueKey        ItemFields = "PresentationUniqueKey"
	ItemFieldsPrimaryImageAspectRatio      ItemFields = "PrimaryImageAspectRatio"
	ItemFieldsProductionLocations          ItemFields = "ProductionLocations"
	ItemFieldsProviderIds                  ItemFields = "ProviderIds"
	ItemFieldsRecursiveItemCount           ItemFields = "RecursiveItemCount"
	ItemFieldsRefreshState                 ItemFields = "RefreshState"
	ItemFieldsRemoteTrailers               ItemFields = "RemoteTrailers"
	ItemFieldsScreenshotImageTags          ItemFields = "ScreenshotImageTags"
	ItemFieldsSeasonUserData               ItemFields = "SeasonUserData"
	ItemFieldsSeriesPresentationUniqueKey  ItemFields = "SeriesPresentationUniqueKey"
	ItemFieldsSeriesPrimaryImage           ItemFields = "SeriesPrimaryImage"
	ItemFieldsSeriesStudio                 ItemFields = "SeriesStudio"
	ItemFieldsServiceName                  ItemFields = "ServiceName"
	ItemFieldsSettings                     ItemFields = "Settings"
	ItemFieldsSortName                     ItemFields = "SortName"
	ItemFieldsSpecialEpisodeNumbers        ItemFields = "SpecialEpisodeNumbers"
	ItemFieldsSpecialFeatureCount          ItemFields = "SpecialFeatureCount"
	ItemFieldsStudios                      ItemFields = "Studios"
	ItemFieldsSyncInfo                     ItemFields = "SyncInfo"
	ItemFieldsTaglines                     ItemFields = "Taglines"
	ItemFieldsTags                         ItemFields = "Tags"
	ItemFieldsThemeSongIds                 ItemFields = "ThemeSongIds"
	ItemFieldsThemeVideoIds                ItemFields = "ThemeVideoIds"
	ItemFieldsWidth                        ItemFields = "Width"
)

// Defines values for ItemFilter.
const (
	ItemFilterDislikes          ItemFilter = "Dislikes"
	ItemFilterIsFavorite        ItemFilter = "IsFavorite"
	ItemFilterIsFavoriteOrLikes ItemFilter = "IsFavoriteOrLikes"
	ItemFilterIsFolder          ItemFilter = "IsFolder"
	ItemFilterIsNotFolder       ItemFilter = "IsNotFolder"
	ItemFilterIsPlayed          ItemFilter = "IsPlayed"
	ItemFilterIsResumable       ItemFilter = "IsResumable"
	ItemFilterIsUnplayed        ItemFilter = "IsUnplayed"
	ItemFilterLikes             ItemFilter = "Likes"
)

// Defines values for ItemViewType.
const (
	ItemViewTypeDetail            ItemViewType = "Detail"
	ItemViewTypeEdit              ItemViewType = "Edit"
	ItemViewTypeEmbeddedImage     ItemViewType = "EmbeddedImage"
	ItemViewTypeItemByNameDetails ItemViewType = "ItemByNameDetails"
	ItemViewTypeList              ItemViewType = "List"
	ItemViewTypeLockDataImage     ItemViewType = "LockDataImage"
	ItemViewTypeNone              ItemViewType = "None"
	ItemViewTypeSpecialsImage     ItemViewType = "SpecialsImage"
	ItemViewTypeStatusImage       ItemViewType = "StatusImage"
	ItemViewTypeSubtitleImage     ItemViewType = "SubtitleImage"
	ItemViewTypeTagsBackdropImage ItemViewType = "TagsBackdropImage"
	ItemViewTypeTagsLogoImage     ItemViewType = "TagsLogoImage"
	ItemViewTypeTagsPrimaryImage  ItemViewType = "TagsPrimaryImage"
	ItemViewTypeTrailersImage     ItemViewType = "TrailersImage"
	ItemViewTypeUserPrimaryImage  ItemViewType = "UserPrimaryImage"
)

// Defines values for KeepUntil.
const (
	UntilDate        KeepUntil = "UntilDate"
	UntilDeleted     KeepUntil = "UntilDeleted"
	UntilSpaceNeeded KeepUntil = "UntilSpaceNeeded"
	UntilWatched     KeepUntil = "UntilWatched"
)

// Defines values for LiveTvServiceStatus.
const (
	Ok          LiveTvServiceStatus = "Ok"
	Unavailable LiveTvServiceStatus = "Unavailable"
)

// Defines values for LocationType.
const (
	FileSystem LocationType = "FileSystem"
	Offline    LocationType = "Offline"
	Remote     LocationType = "Remote"
	Virtual    LocationType = "Virtual"
)

// Defines values for LogLevel.
const (
	LogLevelCritical    LogLevel = "Critical"
	LogLevelDebug       LogLevel = "Debug"
	LogLevelError       LogLevel = "Error"
	LogLevelInformation LogLevel = "Information"
	LogLevelNone        LogLevel = "None"
	LogLevelTrace       LogLevel = "Trace"
	LogLevelWarning     LogLevel = "Warning"
)

// Defines values for MediaProtocol.
const (
	MediaProtocolFile MediaProtocol = "File"
	MediaProtocolFtp  MediaProtocol = "Ftp"
	MediaProtocolHttp MediaProtocol = "Http"
	MediaProtocolRtmp MediaProtocol = "Rtmp"
	MediaProtocolRtp  MediaProtocol = "Rtp"
	MediaProtocolRtsp MediaProtocol = "Rtsp"
	MediaProtocolUdp  MediaProtocol = "Udp"
)

// Defines values for MediaSourceType.
const (
	MediaSourceTypeDefault     MediaSourceType = "Default"
	MediaSourceTypeGrouping    MediaSourceType = "Grouping"
	MediaSourceTypePlaceholder MediaSourceType = "Placeholder"
)

// Defines values for MediaStreamType.
const (
	MediaStreamTypeAudio         MediaStreamType = "Audio"
	MediaStreamTypeData          MediaStreamType = "Data"
	MediaStreamTypeEmbeddedImage MediaStreamType = "EmbeddedImage"
	MediaStreamTypeSubtitle      MediaStreamType = "Subtitle"
	MediaStreamTypeVideo         MediaStreamType = "Video"
)

// Defines values for MetadataField.
const (
	MetadataFieldCast                MetadataField = "Cast"
	MetadataFieldGenres              MetadataField = "Genres"
	MetadataFieldName                MetadataField = "Name"
	MetadataFieldOfficialRating      MetadataField = "OfficialRating"
	MetadataFieldOverview            MetadataField = "Overview"
	MetadataFieldProductionLocations MetadataField = "ProductionLocations"
	MetadataFieldRuntime             MetadataField = "Runtime"
	MetadataFieldStudios             MetadataField = "Studios"
	MetadataFieldTags                MetadataField = "Tags"
)

// Defines values for MetadataRefreshMode.
const (
	MetadataRefreshModeDefault        MetadataRefreshMode = "Default"
	MetadataRefreshModeFullRefresh    MetadataRefreshMode = "FullRefresh"
	MetadataRefreshModeNone           MetadataRefreshMode = "None"
	MetadataRefreshModeValidationOnly MetadataRefreshMode = "ValidationOnly"
)

// Defines values for NotificationLevel.
const (
	NotificationLevelError   NotificationLevel = "Error"
	NotificationLevelNormal  NotificationLevel = "Normal"
	NotificationLevelWarning NotificationLevel = "Warning"
)

// Defines values for PlayAccess.
const (
	PlayAccessFull PlayAccess = "Full"
	PlayAccessNone PlayAccess = "None"
)

// Defines values for PlayCommand.
const (
	PlayCommandPlayInstantMix PlayCommand = "PlayInstantMix"
	PlayCommandPlayLast       PlayCommand = "PlayLast"
	PlayCommandPlayNext       PlayCommand = "PlayNext"
	PlayCommandPlayNow        PlayCommand = "PlayNow"
	PlayCommandPlayShuffle    PlayCommand = "PlayShuffle"
)

// Defines values for PlayMethod.
const (
	DirectPlay   PlayMethod = "DirectPlay"
	DirectStream PlayMethod = "DirectStream"
	Transcode    PlayMethod = "Transcode"
)

// Defines values for PlaybackErrorCode.
const (
	NoCompatibleStream PlaybackErrorCode = "NoCompatibleStream"
	NotAllowed         PlaybackErrorCode = "NotAllowed"
	RateLimitExceeded  PlaybackErrorCode = "RateLimitExceeded"
)

// Defines values for PlaystateCommand.
const (
	FastForward   PlaystateCommand = "FastForward"
	NextTrack     PlaystateCommand = "NextTrack"
	Pause         PlaystateCommand = "Pause"
	PlayPause     PlaystateCommand = "PlayPause"
	PreviousTrack PlaystateCommand = "PreviousTrack"
	Rewind        PlaystateCommand = "Rewind"
	Seek          PlaystateCommand = "Seek"
	Stop          PlaystateCommand = "Stop"
	Unpause       PlaystateCommand = "Unpause"
)

// Defines values for PluginStatus.
const (
	Active        PluginStatus = "Active"
	Deleted       PluginStatus = "Deleted"
	Disabled      PluginStatus = "Disabled"
	Malfunctioned PluginStatus = "Malfunctioned"
	NotSupported  PluginStatus = "NotSupported"
	Restart       PluginStatus = "Restart"
	Superceded    PluginStatus = "Superceded"
)

// Defines values for ProfileConditionType.
const (
	ProfileConditionTypeEquals           ProfileConditionType = "Equals"
	ProfileConditionTypeEqualsAny        ProfileConditionType = "EqualsAny"
	ProfileConditionTypeGreaterThanEqual ProfileConditionType = "GreaterThanEqual"
	ProfileConditionTypeLessThanEqual    ProfileConditionType = "LessThanEqual"
	ProfileConditionTypeNotEquals        ProfileConditionType = "NotEquals"
)

// Defines values for ProfileConditionValue.
const (
	AudioBitDepth    ProfileConditionValue = "AudioBitDepth"
	AudioBitrate     ProfileConditionValue = "AudioBitrate"
	AudioChannels    ProfileConditionValue = "AudioChannels"
	AudioProfile     ProfileConditionValue = "AudioProfile"
	AudioSampleRate  ProfileConditionValue = "AudioSampleRate"
	Has64BitOffsets  ProfileConditionValue = "Has64BitOffsets"
	Height           ProfileConditionValue = "Height"
	IsAnamorphic     ProfileConditionValue = "IsAnamorphic"
	IsAvc            ProfileConditionValue = "IsAvc"
	IsInterlaced     ProfileConditionValue = "IsInterlaced"
	IsSecondaryAudio ProfileConditionValue = "IsSecondaryAudio"
	NumAudioStreams  ProfileConditionValue = "NumAudioStreams"
	NumVideoStreams  ProfileConditionValue = "NumVideoStreams"
	PacketLength     ProfileConditionValue = "PacketLength"
	RefFrames        ProfileConditionValue = "RefFrames"
	VideoBitDepth    ProfileConditionValue = "VideoBitDepth"
	VideoBitrate     ProfileConditionValue = "VideoBitrate"
	VideoCodecTag    ProfileConditionValue = "VideoCodecTag"
	VideoFramerate   ProfileConditionValue = "VideoFramerate"
	VideoLevel       ProfileConditionValue = "VideoLevel"
	VideoProfile     ProfileConditionValue = "VideoProfile"
	VideoRangeType   ProfileConditionValue = "VideoRangeType"
	VideoTimestamp   ProfileConditionValue = "VideoTimestamp"
	Width            ProfileConditionValue = "Width"
)

// Defines values for ProgramAudio.
const (
	Atmos        ProgramAudio = "Atmos"
	Dolby        ProgramAudio = "Dolby"
	DolbyDigital ProgramAudio = "DolbyDigital"
	Mono         ProgramAudio = "Mono"
	Stereo       ProgramAudio = "Stereo"
	Thx          ProgramAudio = "Thx"
)

// Defines values for RatingType.
const (
	RatingTypeLikes RatingType = "Likes"
	RatingTypeScore RatingType = "Score"
)

// Defines values for RecommendationType.
const (
	HasActorFromRecentlyPlayed    RecommendationType = "HasActorFromRecentlyPlayed"
	HasDirectorFromRecentlyPlayed RecommendationType = "HasDirectorFromRecentlyPlayed"
	HasLikedActor                 RecommendationType = "HasLikedActor"
	HasLikedDirector              RecommendationType = "HasLikedDirector"
	SimilarToLikedItem            RecommendationType = "SimilarToLikedItem"
	SimilarToRecentlyPlayed       RecommendationType = "SimilarToRecentlyPlayed"
)

// Defines values for RecordingStatus.
const (
	RecordingStatusCancelled       RecordingStatus = "Cancelled"
	RecordingStatusCompleted       RecordingStatus = "Completed"
	RecordingStatusConflictedNotOk RecordingStatus = "ConflictedNotOk"
	RecordingStatusConflictedOk    RecordingStatus = "ConflictedOk"
	RecordingStatusError           RecordingStatus = "Error"
	RecordingStatusInProgress      RecordingStatus = "InProgress"
	RecordingStatusNew             RecordingStatus = "New"
)

// Defines values for RepeatMode.
const (
	RepeatModeRepeatAll  RepeatMode = "RepeatAll"
	RepeatModeRepeatNone RepeatMode = "RepeatNone"
	RepeatModeRepeatOne  RepeatMode = "RepeatOne"
)

// Defines values for ReportDisplayType.
const (
	ReportDisplayTypeExport       ReportDisplayType = "Export"
	ReportDisplayTypeNone         ReportDisplayType = "None"
	ReportDisplayTypeScreen       ReportDisplayType = "Screen"
	ReportDisplayTypeScreenExport ReportDisplayType = "ScreenExport"
)

// Defines values for ReportExportType.
const (
	CSV   ReportExportType = "CSV"
	Excel ReportExportType = "Excel"
)

// Defines values for ReportFieldType.
const (
	Boolean  ReportFieldType = "Boolean"
	Date     ReportFieldType = "Date"
	DateTime ReportFieldType = "DateTime"
	Image    ReportFieldType = "Image"
	Int      ReportFieldType = "Int"
	Minutes  ReportFieldType = "Minutes"
	Object   ReportFieldType = "Object"
	String   ReportFieldType = "String"
	Time     ReportFieldType = "Time"
)

// Defines values for ReportIncludeItemTypes.
const (
	ReportIncludeItemTypesArtist      ReportIncludeItemTypes = "Artist"
	ReportIncludeItemTypesAudio       ReportIncludeItemTypes = "Audio"
	ReportIncludeItemTypesBaseItem    ReportIncludeItemTypes = "BaseItem"
	ReportIncludeItemTypesBook        ReportIncludeItemTypes = "Book"
	ReportIncludeItemTypesBoxSet      ReportIncludeItemTypes = "BoxSet"
	ReportIncludeItemTypesEpisode     ReportIncludeItemTypes = "Episode"
	ReportIncludeItemTypesMovie       ReportIncludeItemTypes = "Movie"
	ReportIncludeItemTypesMusicAlbum  ReportIncludeItemTypes = "MusicAlbum"
	ReportIncludeItemTypesMusicArtist ReportIncludeItemTypes = "MusicArtist"
	ReportIncludeItemTypesMusicVideo  ReportIncludeItemTypes = "MusicVideo"
	ReportIncludeItemTypesSeason      ReportIncludeItemTypes = "Season"
	ReportIncludeItemTypesSeries      ReportIncludeItemTypes = "Series"
	ReportIncludeItemTypesTrailer     ReportIncludeItemTypes = "Trailer"
	ReportIncludeItemTypesVideo       ReportIncludeItemTypes = "Video"
)

// Defines values for ScrollDirection.
const (
	Horizontal ScrollDirection = "Horizontal"
	Vertical   ScrollDirection = "Vertical"
)

// Defines values for SeriesStatus.
const (
	Continuing SeriesStatus = "Continuing"
	Ended      SeriesStatus = "Ended"
)

// Defines values for SortOrder.
const (
	Ascending  SortOrder = "Ascending"
	Descending SortOrder = "Descending"
)

// Defines values for SubtitleDeliveryMethod.
const (
	Drop     SubtitleDeliveryMethod = "Drop"
	Embed    SubtitleDeliveryMethod = "Embed"
	Encode   SubtitleDeliveryMethod = "Encode"
	External SubtitleDeliveryMethod = "External"
	Hls      SubtitleDeliveryMethod = "Hls"
)

// Defines values for SubtitlePlaybackMode.
const (
	SubtitlePlaybackModeAlways     SubtitlePlaybackMode = "Always"
	SubtitlePlaybackModeDefault    SubtitlePlaybackMode = "Default"
	SubtitlePlaybackModeNone       SubtitlePlaybackMode = "None"
	SubtitlePlaybackModeOnlyForced SubtitlePlaybackMode = "OnlyForced"
	SubtitlePlaybackModeSmart      SubtitlePlaybackMode = "Smart"
)

// Defines values for SyncPlayUserAccessType.
const (
	SyncPlayUserAccessTypeCreateAndJoinGroups SyncPlayUserAccessType = "CreateAndJoinGroups"
	SyncPlayUserAccessTypeJoinGroups          SyncPlayUserAccessType = "JoinGroups"
	SyncPlayUserAccessTypeNone                SyncPlayUserAccessType = "None"
)

// Defines values for TaskCompletionStatus.
const (
	Aborted   TaskCompletionStatus = "Aborted"
	Cancelled TaskCompletionStatus = "Cancelled"
	Completed TaskCompletionStatus = "Completed"
	Failed    TaskCompletionStatus = "Failed"
)

// Defines values for TaskState.
const (
	TaskStateCancelling TaskState = "Cancelling"
	TaskStateIdle       TaskState = "Idle"
	TaskStateRunning    TaskState = "Running"
)

// Defines values for TranscodeReason.
const (
	AnamorphicVideoNotSupported  TranscodeReason = "AnamorphicVideoNotSupported"
	AudioBitDepthNotSupported    TranscodeReason = "AudioBitDepthNotSupported"
	AudioBitrateNotSupported     TranscodeReason = "AudioBitrateNotSupported"
	AudioChannelsNotSupported    TranscodeReason = "AudioChannelsNotSupported"
	AudioCodecNotSupported       TranscodeReason = "AudioCodecNotSupported"
	AudioIsExternal              TranscodeReason = "AudioIsExternal"
	AudioProfileNotSupported     TranscodeReason = "AudioProfileNotSupported"
	AudioSampleRateNotSupported  TranscodeReason = "AudioSampleRateNotSupported"
	ContainerBitrateExceedsLimit TranscodeReason = "ContainerBitrateExceedsLimit"
	ContainerNotSupported        TranscodeReason = "ContainerNotSupported"
	DirectPlayError              TranscodeReason = "DirectPlayError"
	InterlacedVideoNotSupported  TranscodeReason = "InterlacedVideoNotSupported"
	RefFramesNotSupported        TranscodeReason = "RefFramesNotSupported"
	SecondaryAudioNotSupported   TranscodeReason = "SecondaryAudioNotSupported"
	SubtitleCodecNotSupported    TranscodeReason = "SubtitleCodecNotSupported"
	UnknownAudioStreamInfo       TranscodeReason = "UnknownAudioStreamInfo"
	UnknownVideoStreamInfo       TranscodeReason = "UnknownVideoStreamInfo"
	VideoBitDepthNotSupported    TranscodeReason = "VideoBitDepthNotSupported"
	VideoBitrateNotSupported     TranscodeReason = "VideoBitrateNotSupported"
	VideoCodecNotSupported       TranscodeReason = "VideoCodecNotSupported"
	VideoFramerateNotSupported   TranscodeReason = "VideoFramerateNotSupported"
	VideoLevelNotSupported       TranscodeReason = "VideoLevelNotSupported"
	VideoProfileNotSupported     TranscodeReason = "VideoProfileNotSupported"
	VideoRangeTypeNotSupported   TranscodeReason = "VideoRangeTypeNotSupported"
	VideoResolutionNotSupported  TranscodeReason = "VideoResolutionNotSupported"
)

// Defines values for TranscodeSeekInfo.
const (
	Auto  TranscodeSeekInfo = "Auto"
	Bytes TranscodeSeekInfo = "Bytes"
)

// Defines values for TransportStreamTimestamp.
const (
	None  TransportStreamTimestamp = "None"
	Valid TransportStreamTimestamp = "Valid"
	Zero  TransportStreamTimestamp = "Zero"
)

// Defines values for UnratedItem.
const (
	UnratedItemBook           UnratedItem = "Book"
	UnratedItemChannelContent UnratedItem = "ChannelContent"
	UnratedItemLiveTvChannel  UnratedItem = "LiveTvChannel"
	UnratedItemLiveTvProgram  UnratedItem = "LiveTvProgram"
	UnratedItemMovie          UnratedItem = "Movie"
	UnratedItemMusic          UnratedItem = "Music"
	UnratedItemOther          UnratedItem = "Other"
	UnratedItemSeries         UnratedItem = "Series"
	UnratedItemTrailer        UnratedItem = "Trailer"
)

// Defines values for Video3DFormat.
const (
	FullSideBySide   Video3DFormat = "FullSideBySide"
	FullTopAndBottom Video3DFormat = "FullTopAndBottom"
	HalfSideBySide   Video3DFormat = "HalfSideBySide"
	HalfTopAndBottom Video3DFormat = "HalfTopAndBottom"
	MVC              Video3DFormat = "MVC"
)

// Defines values for VideoType.
const (
	VideoTypeBluRay    VideoType = "BluRay"
	VideoTypeDvd       VideoType = "Dvd"
	VideoTypeIso       VideoType = "Iso"
	VideoTypeVideoFile VideoType = "VideoFile"
)

// AccessSchedule An entity representing a user's access schedule.
type AccessSchedule struct {
	// DayOfWeek Gets or sets the day of week.
	DayOfWeek *DynamicDayOfWeek `json:"DayOfWeek,omitempty"`

	// EndHour Gets or sets the end hour.
	EndHour *float64 `json:"EndHour,omitempty"`

	// Id Gets the id of this instance.
	Id *int32 `json:"Id,omitempty"`

	// StartHour Gets or sets the start hour.
	StartHour *float64 `json:"StartHour,omitempty"`

	// UserId Gets the id of the associated user.
	UserId *openapi_types.UUID `json:"UserId,omitempty"`
}

// ActivityLogEntry An activity log entry.
type ActivityLogEntry struct {
	// Date Gets or sets the date.
	Date *time.Time `json:"Date,omitempty"`

	// Id Gets or sets the identifier.
	Id *int64 `json:"Id,omitempty"`

	// ItemId Gets or sets the item identifier.
	ItemId *string `json:"ItemId"`

	// Name Gets or sets the name.
	Name *string `json:"Name,omitempty"`

	// Overview Gets or sets the overview.
	Overview *string `json:"Overview"`

	// Severity Gets or sets the log severity.
	Severity *LogLevel `json:"Severity,omitempty"`

	// ShortOverview Gets or sets the short overview.
	ShortOverview *string `json:"ShortOverview"`

	// Type Gets or sets the type.
	Type *string `json:"Type,omitempty"`

	// UserId Gets or sets the user identifier.
	UserId *openapi_types.UUID `json:"UserId,omitempty"`

	// UserPrimaryImageTag Gets or sets the user primary image tag.
	// Deprecated:
	UserPrimaryImageTag *string `json:"UserPrimaryImageTag"`
}

// ActivityLogEntryQueryResult defines model for ActivityLogEntryQueryResult.
type ActivityLogEntryQueryResult struct {
	// Items Gets or sets the items.
	Items *[]ActivityLogEntry `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// AddVirtualFolderDto Add virtual folder dto.
type AddVirtualFolderDto struct {
	// LibraryOptions Gets or sets library options.
	LibraryOptions *LibraryOptions `json:"LibraryOptions"`
}

// AdminNotificationDto The admin notification dto.
type AdminNotificationDto struct {
	// Description Gets or sets the notification description.
	Description *string `json:"Description"`

	// Name Gets or sets the notification name.
	Name *string `json:"Name"`

	// NotificationLevel Gets or sets the notification level.
	NotificationLevel *NotificationLevel `json:"NotificationLevel"`

	// Url Gets or sets the notification url.
	Url *string `json:"Url"`
}

// AlbumInfo defines model for AlbumInfo.
type AlbumInfo struct {
	// AlbumArtists Gets or sets the album artist.
	AlbumArtists *[]string `json:"AlbumArtists,omitempty"`

	// ArtistProviderIds Gets or sets the artist provider ids.
	ArtistProviderIds *map[string]*string `json:"ArtistProviderIds,omitempty"`
	IndexNumber       *int32              `json:"IndexNumber"`
	IsAutomated       *bool               `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`
	SongInfos   *[]SongInfo         `json:"SongInfos,omitempty"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// AlbumInfoRemoteSearchQuery defines model for AlbumInfoRemoteSearchQuery.
type AlbumInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *AlbumInfo          `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// AllThemeMediaResult defines model for AllThemeMediaResult.
type AllThemeMediaResult struct {
	// SoundtrackSongsResult Class ThemeMediaResult.
	SoundtrackSongsResult *ThemeMediaResult `json:"SoundtrackSongsResult"`

	// ThemeSongsResult Class ThemeMediaResult.
	ThemeSongsResult *ThemeMediaResult `json:"ThemeSongsResult"`

	// ThemeVideosResult Class ThemeMediaResult.
	ThemeVideosResult *ThemeMediaResult `json:"ThemeVideosResult"`
}

// Architecture defines model for Architecture.
type Architecture string

// ArtistInfo defines model for ArtistInfo.
type ArtistInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`
	SongInfos   *[]SongInfo         `json:"SongInfos,omitempty"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// ArtistInfoRemoteSearchQuery defines model for ArtistInfoRemoteSearchQuery.
type ArtistInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *ArtistInfo         `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// AuthenticateUserByName The authenticate user by name request body.
type AuthenticateUserByName struct {
	// Password Gets or sets the sha1-hashed password.
	// Deprecated:
	Password *string `json:"Password"`

	// Pw Gets or sets the plain text password.
	Pw *string `json:"Pw"`

	// Username Gets or sets the username.
	Username *string `json:"Username"`
}

// AuthenticationInfo defines model for AuthenticationInfo.
type AuthenticationInfo struct {
	// AccessToken Gets or sets the access token.
	AccessToken *string `json:"AccessToken"`

	// AppName Gets or sets the name of the application.
	AppName *string `json:"AppName"`

	// AppVersion Gets or sets the application version.
	AppVersion *string `json:"AppVersion"`

	// DateCreated Gets or sets the date created.
	DateCreated      *time.Time `json:"DateCreated,omitempty"`
	DateLastActivity *time.Time `json:"DateLastActivity,omitempty"`

	// DateRevoked Gets or sets the date revoked.
	DateRevoked *time.Time `json:"DateRevoked"`

	// DeviceId Gets or sets the device identifier.
	DeviceId *string `json:"DeviceId"`

	// DeviceName Gets or sets the name of the device.
	DeviceName *string `json:"DeviceName"`

	// Id Gets or sets the identifier.
	Id *int64 `json:"Id,omitempty"`

	// IsActive Gets or sets a value indicating whether this instance is active.
	IsActive *bool `json:"IsActive,omitempty"`

	// UserId Gets or sets the user identifier.
	UserId   *openapi_types.UUID `json:"UserId,omitempty"`
	UserName *string             `json:"UserName"`
}

// AuthenticationInfoQueryResult defines model for AuthenticationInfoQueryResult.
type AuthenticationInfoQueryResult struct {
	// Items Gets or sets the items.
	Items *[]AuthenticationInfo `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// AuthenticationResult defines model for AuthenticationResult.
type AuthenticationResult struct {
	AccessToken *string `json:"AccessToken"`
	ServerId    *string `json:"ServerId"`

	// SessionInfo Class SessionInfo.
	SessionInfo *SessionInfo `json:"SessionInfo"`

	// User Class UserDto.
	User *UserDto `json:"User"`
}

// BaseItem Class BaseItem.
type BaseItem struct {
	Container     *string               `json:"Container"`
	DateLastSaved *time.Time            `json:"DateLastSaved,omitempty"`
	ExtraIds      *[]openapi_types.UUID `json:"ExtraIds"`
	Height        *int32                `json:"Height,omitempty"`
	IsHD          *bool                 `json:"IsHD,omitempty"`
	IsShortcut    *bool                 `json:"IsShortcut,omitempty"`

	// RemoteTrailers Gets or sets the remote trailers.
	RemoteTrailers           *[]MediaUrl `json:"RemoteTrailers"`
	ShortcutPath             *string     `json:"ShortcutPath"`
	Size                     *int64      `json:"Size"`
	SupportsExternalTransfer *bool       `json:"SupportsExternalTransfer,omitempty"`
	Width                    *int32      `json:"Width,omitempty"`
}

// BaseItemDto This is strictly used as a data transfer object from the api layer.
// This holds information about a BaseItem in a format that is convenient for the client.
type BaseItemDto struct {
	// AirDays Gets or sets the air days.
	AirDays *[]DayOfWeek `json:"AirDays"`

	// AirTime Gets or sets the air time.
	AirTime                 *string `json:"AirTime"`
	AirsAfterSeasonNumber   *int32  `json:"AirsAfterSeasonNumber"`
	AirsBeforeEpisodeNumber *int32  `json:"AirsBeforeEpisodeNumber"`
	AirsBeforeSeasonNumber  *int32  `json:"AirsBeforeSeasonNumber"`

	// Album Gets or sets the album.
	Album *string `json:"Album"`

	// AlbumArtist Gets or sets the album artist.
	AlbumArtist *string `json:"AlbumArtist"`

	// AlbumArtists Gets or sets the album artists.
	AlbumArtists *[]NameGuidPair `json:"AlbumArtists"`

	// AlbumCount Gets or sets the album count.
	AlbumCount *int32 `json:"AlbumCount"`

	// AlbumId Gets or sets the album id.
	AlbumId *openapi_types.UUID `json:"AlbumId"`

	// AlbumPrimaryImageTag Gets or sets the album image tag.
	AlbumPrimaryImageTag *string  `json:"AlbumPrimaryImageTag"`
	Altitude             *float64 `json:"Altitude"`
	Aperture             *float64 `json:"Aperture"`
	ArtistCount          *int32   `json:"ArtistCount"`

	// ArtistItems Gets or sets the artist items.
	ArtistItems *[]NameGuidPair `json:"ArtistItems"`

	// Artists Gets or sets the artists.
	Artists *[]string `json:"Artists"`

	// AspectRatio Gets or sets the aspect ratio.
	AspectRatio *string `json:"AspectRatio"`

	// Audio Gets or sets the audio.
	Audio *ProgramAudio `json:"Audio"`

	// BackdropImageTags Gets or sets the backdrop image tags.
	BackdropImageTags *[]string `json:"BackdropImageTags"`
	CameraMake        *string   `json:"CameraMake"`
	CameraModel       *string   `json:"CameraModel"`
	CanDelete         *bool     `json:"CanDelete"`
	CanDownload       *bool     `json:"CanDownload"`

	// ChannelId Gets or sets the channel identifier.
	ChannelId     *openapi_types.UUID `json:"ChannelId"`
	ChannelName   *string             `json:"ChannelName"`
	ChannelNumber *string             `json:"ChannelNumber"`

	// ChannelPrimaryImageTag Gets or sets the channel primary image tag.
	ChannelPrimaryImageTag *string `json:"ChannelPrimaryImageTag"`

	// ChannelType Gets or sets the type of the channel.
	ChannelType *ChannelType `json:"ChannelType"`

	// Chapters Gets or sets the chapters.
	Chapters *[]ChapterInfo `json:"Chapters"`

	// ChildCount Gets or sets the child count.
	ChildCount *int32 `json:"ChildCount"`

	// CollectionType Gets or sets the type of the collection.
	CollectionType *string `json:"CollectionType"`

	// CommunityRating Gets or sets the community rating.
	CommunityRating *float32 `json:"CommunityRating"`

	// CompletionPercentage Gets or sets the completion percentage. CompletionPercentage *float64 `json:"CompletionPercentage"`
	Container            *string  `json:"Container"`

	// CriticRating Gets or sets the critic rating.
	CriticRating *float32 `json:"CriticRating"`

	// CumulativeRunTimeTicks Gets or sets the cumulative run time ticks.
	CumulativeRunTimeTicks *int64 `json:"CumulativeRunTimeTicks"`

	// CurrentProgram Gets or sets the current program.
	CurrentProgram *BaseItemDto `json:"CurrentProgram"`

	// CustomRating Gets or sets the custom rating.
	CustomRating *string `json:"CustomRating"`

	// DateCreated Gets or sets the date created.
	DateCreated        *time.Time `json:"DateCreated"`
	DateLastMediaAdded *time.Time `json:"DateLastMediaAdded"`

	// DisplayOrder Gets or sets the display order.
	DisplayOrder *string `json:"DisplayOrder"`

	// DisplayPreferencesId Gets or sets the display preferences id.
	DisplayPreferencesId     *string `json:"DisplayPreferencesId"`
	EnableMediaSourceDisplay *bool   `json:"EnableMediaSourceDisplay"`

	// EndDate Gets or sets the end date.
	EndDate *time.Time `json:"EndDate"`

	// EpisodeCount Gets or sets the episode count.
	EpisodeCount *int32 `json:"EpisodeCount"`

	// EpisodeTitle Gets or sets the episode title.
	EpisodeTitle *string `json:"EpisodeTitle"`

	// Etag Gets or sets the etag.
	Etag         *string  `json:"Etag"`
	ExposureTime *float64 `json:"ExposureTime"`

	// ExternalUrls Gets or sets the external urls.
	ExternalUrls   *[]ExternalUrl  `json:"ExternalUrls"`
	ExtraType      *string         `json:"ExtraType"`
	FocalLength    *float64        `json:"FocalLength"`
	ForcedSortName *string         `json:"ForcedSortName"`
	GenreItems     *[]NameGuidPair `json:"GenreItems"`

	// Genres Gets or sets the genres.
	Genres       *[]string `json:"Genres"`
	HasSubtitles *bool     `json:"HasSubtitles"`
	Height       *int32    `json:"Height"`

	// Id Gets or sets the id.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// ImageBlurHashes Gets or sets the blurhashes for the image tags.
	// Maps image type to dictionary mapping image tag to blurhash value.
	ImageBlurHashes *struct {
		Art        *map[string]string `json:"Art,omitempty"`
		Backdrop   *map[string]string `json:"Backdrop,omitempty"`
		Banner     *map[string]string `json:"Banner,omitempty"`
		Box        *map[string]string `json:"Box,omitempty"`
		BoxRear    *map[string]string `json:"BoxRear,omitempty"`
		Chapter    *map[string]string `json:"Chapter,omitempty"`
		Disc       *map[string]string `json:"Disc,omitempty"`
		Logo       *map[string]string `json:"Logo,omitempty"`
		Menu       *map[string]string `json:"Menu,omitempty"`
		Primary    *map[string]string `json:"Primary,omitempty"`
		Profile    *map[string]string `json:"Profile,omitempty"`
		Screenshot *map[string]string `json:"Screenshot,omitempty"`
		Thumb      *map[string]string `json:"Thumb,omitempty"`
	} `json:"ImageBlurHashes"`
	ImageOrientation *ImageOrientation `json:"ImageOrientation"`

	// ImageTags Gets or sets the image tags.
	ImageTags *map[string]string `json:"ImageTags"`

	// IndexNumber Gets or sets the index number.
	IndexNumber *int32 `json:"IndexNumber"`

	// IndexNumberEnd Gets or sets the index number end.
	IndexNumberEnd *int32 `json:"IndexNumberEnd"`

	// IsFolder Gets or sets a value indicating whether this instance is folder.
	IsFolder *bool `json:"IsFolder"`

	// IsHD Gets or sets a value indicating whether this instance is HD.
	IsHD *bool `json:"IsHD"`

	// IsKids Gets or sets a value indicating whether this instance is kids.
	IsKids *bool `json:"IsKids"`

	// IsLive Gets or sets a value indicating whether this instance is live.
	IsLive *bool `json:"IsLive"`

	// IsMovii Gets or sets a value indicating whether this instance is movie.
	IsMovie *bool `json:"IsMovie"`

	// IsNews Gets or sets a value indicating whether this instance is news.
	IsNews *bool `json:"IsNews"`

	// IsPlaceHolder Gets or sets a value indicating whether this instance is place holder.
	IsPlaceHolder *bool `json:"IsPlaceHolder"`

	// IsPremiere Gets or sets a value indicating whether this instance is premiere.
	IsPremiere *bool `json:"IsPremiere"`

	// IsRepeat Gets or sets a value indicating whether this instance is repeat.
	IsRepeat *bool `json:"IsRepeai"`

	// IsSeries Gets or sets a value indicating whether this instance is series.
	IsSeries *bool `json:"IsSeries"`

	// IsSports Gets or sets a value indicating whether this instance is sports.
	IsSports       *bool  `json:"IsSports"`
	IsoSpeedRating *int32 `json:"IsoSpeedRating"`

	// IsoType Gets or sets the type of the iso.
	IsoType  *IsoType `json:"IsoType"`
	Latitude *float64 `json:"Latitude"`

	// LocalTrailerCount Gets or sets the local trailer count.
	LocalTrailerCount *int32 `json:"LocalTrailerCount"`

	// LocationType Gets or sets the type of the location.
	LocationType *LocationType `json:"LocationType"`

	// LockData Gets or sets a value indicating whether [enable internet providers].
	LockData *bool `json:"LockData"`

	// LockedFields Gets or sets the locked fields.
	LockedFields     *[]MetadataField `json:"LockedFields"`
	Longitude        *float64         `json:"Longitude"`
	MediaSourceCount *int32           `json:"MediaSourceCount"`

	// MediaSources Gets or sets the media versions.
	MediaSources *[]MediaSourceInfo `json:"MediaSources"`

	// MediaStreams Gets or sets the media streams.
	MediaStreams *[]MediaStream `json:"MediaStreams"`

	// MediaType Gets or sets the type of the media.
	MediaType *string `json:"MediaType"`

	// MovieCount Gets or sets the movie count.
	MovieCount *int32 `json:"MovieCount"`

	// MusicVideoCount Gets or sets the music video count.
	MusicVideoCount *int32 `json:"MusicVideoCount"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Number Gets or sets the number.
	Number *string `json:"Number"`

	// OfficialRating Gets or sets the official rating.
	OfficialRating *string `json:"OfficialRating"`
	OriginalTitle  *string `json:"OriginalTitle"`

	// Overview Gets or sets the overview.
	Overview *string `json:"Overview"`

	// ParentArtImageTag Gets or sets the parent art image tag.
	ParentArtImageTag *string `json:"ParentArtImageTag"`

	// ParentArtItemId Gets or sets wether the item has fan art, this will hold the Id of the Parent that has one.
	ParentArtItemId *openapi_types.UUID `json:"ParentArtItemId"`

	// ParentBackdropImageTags Gets or sets the parent backdrop image tags.
	ParentBackdropImageTags *[]string `json:"ParentBackdropImageTags"`

	// ParentBackdropItemId Gets or sets wether the item has any backdrops, this will hold the Id of the Parent that has one.
	ParentBackdropItemId *openapi_types.UUID `json:"ParentBackdropItemId"`

	// ParentId Gets or sets the parent id.
	ParentId *openapi_types.UUID `json:"ParentId"`

	// ParentIndexNumber Gets or sets the parent index number.
	ParentIndexNumber *int32 `json:"ParentIndexNumber"`

	// ParentLogoImageTag Gets or sets the parent logo image tag.
	ParentLogoImageTag *string `json:"ParentLogoImageTag"`

	// ParentLogoItemId Gets or sets wether the item has a logo, this will hold the Id of the Parent that has one.
	ParentLogoItemId *openapi_types.UUID `json:"ParentLogoItemId"`

	// ParentPrimaryImageItemId Gets or sets the parent primary image item identifier.
	ParentPrimaryImageItemId *string `json:"ParentPrimaryImageItemId"`

	// ParentPrimaryImageTag Gets or sets the parent primary image tag.
	ParentPrimaryImageTag *string `json:"ParentPrimaryImageTag"`

	// ParentThumbImageTag Gets or sets the parent thumb image tag.
	ParentThumbImageTag *string `json:"ParentThumbImageTag"`

	// ParentThumbItemId Gets or sets the parent thumb item id.
	ParentThumbItemId *openapi_types.UUID `json:"ParentThumbItemId"`

	// PartCount Gets or sets the part count.
	PartCount *int32 `json:"PartCount"`

	// Path Gets or sets the path.
	Path *string `json:"Path"`

	// People Gets or sets the people.
	People *[]BaseItemPerson `json:"People"`

	// PlayAccess Gets or sets the play access.
	PlayAccess *PlayAccess `json:"PlayAccess"`

	// PlaylistItemId Gets or sets the playlist item identifier.
	PlaylistItemId               *string `json:"PlaylistItemId"`
	PreferredMetadataCountryCode *string `json:"PreferredMetadataCountryCode"`
	PreferredMetadataLanguage    *string `json:"PreferredMetadataLanguage"`

	// PremiereDate Gets or sets the premiere date.
	PremiereDate *time.Time `json:"PremiereDate"`

	// PrimaryImageAspectRatio Gets or sets the primary image aspect ratio, after image enhancements.
	PrimaryImageAspectRatio *float64  `json:"PrimaryImageAspectRatio"`
	ProductionLocations     *[]string `json:"ProductionLocations"`

	// ProductionYear Gets or sets the production year.
	ProductionYear *int32 `json:"ProductionYear"`
	ProgramCount   *int32 `json:"ProgramCount"`

	// ProgramId Gets or sets the program identifier.
	ProgramId *string `json:"ProgramId"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// RecursiveItemCount Gets or sets the recursive item count.
	RecursiveItemCount *int32 `json:"RecursiveItemCount"`

	// RemoteTrailers Gets or sets the trailer urls.
	RemoteTrailers *[]MediaUrl `json:"RemoteTrailers"`

	// RunTimeTicks Gets or sets the run time ticks.
	RunTimeTicks *int64 `json:"RunTimeTicks"`

	// ScreenshotImageTags Gets or sets the screenshot image tags.
	ScreenshotImageTags *[]string `json:"ScreenshotImageTags"`

	// SeasonId Gets or sets the season identifier.
	SeasonId *openapi_types.UUID `json:"SeasonId"`

	// SeasonName Gets or sets the name of the season.
	SeasonName *string `json:"SeasonName"`

	// SeriesCount Gets or sets the series count.
	SeriesCount *int32 `json:"SeriesCount"`

	// SeriesId Gets or sets the series id.
	SeriesId *openapi_types.UUID `json:"SeriesId"`

	// SeriesName Gets or sets the name of the series.
	SeriesName *string `json:"SeriesName"`

	// SeriesPrimaryImageTag Gets or sets the series primary image tag.
	SeriesPrimaryImageTag *string `json:"SeriesPrimaryImageTag"`

	// SeriesStudio Gets or sets the series studio.
	SeriesStudio *string `json:"SeriesStudio"`

	// SeriesThumbImageTag Gets or sets the series thumb image tag.
	SeriesThumbImageTag *string `json:"SeriesThumbImageTag"`

	// SeriesTimerId Gets or sets the series timer identifier.
	SeriesTimerId *string `json:"SeriesTimerId"`

	// ServerId Gets or sets the server identifier.
	ServerId     *string  `json:"ServerId"`
	ShutterSpeed *float64 `json:"ShutterSpeed"`
	Software     *string  `json:"Software"`

	// SongCount Gets or sets the song count.
	SongCount *int32 `json:"SongCount"`

	// SortName Gets or sets the name of the sort.
	SortName *string `json:"SortName"`

	// SourceType Gets or sets the type of the source.
	SourceType *string `json:"SourceType"`

	// SpecialFeatureCount Gets or sets the special feature count.
	SpecialFeatureCount *int32 `json:"SpecialFeatureCount"`

	// StartDate Gets or sets the start date of the recording, in UTC.
	StartDate *time.Time `json:"StartDate"`

	// Status Gets or sets the status.
	Status *string `json:"Status"`

	// Studios Gets or sets the studios.
	Studios *[]NameGuidPair `json:"Studios"`

	// SupportsSync Gets or sets a value indicating whether [supports synchronize].
	SupportsSync *bool `json:"SupportsSync"`

	// Taglines Gets or sets the taglines.
	Taglines *[]string `json:"Taglines"`

	// Tags Gets or sets the tags.
	Tags *[]string `json:"Tags"`

	// TimerId Gets or sets the timer identifier.
	TimerId *string `json:"TimerId"`

	// TrailerCount Gets or sets the trailer count.
	TrailerCount *int32 `json:"TrailerCount"`

	// Type Gets or sets the type.
	Type *BaseItemKind `json:"Type,omitempty"`

	// UserData Gets or sets the user data for this item based on the user it's being requested for.
	UserData *UserItemDataDto `json:"UserData"`

	// Video3DFormat Gets or sets the video3 D format.
	Video3DFormat *Video3DFormat `json:"Video3DFormat"`

	// VideoType Gets or sets the type of the video.
	VideoType *VideoType `json:"VideoType"`
	Width     *int32     `json:"Width"`
}

// BaseItemDtoQueryResult defines model for BaseItemDtoQueryResult.
type BaseItemDtoQueryResult struct {
	// Items Gets or sets the items.
	Items *[]BaseItemDto `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// BaseItemKind The base item kind.
type BaseItemKind string

// BaseItemPerson This is used by the api to get information about a Person within a BaseItem.
type BaseItemPerson struct {
	// Id Gets or sets the identifier.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// ImageBlurHashes Gets or sets the primary image blurhash.
	ImageBlurHashes *struct {
		Art        *map[string]string `json:"Art,omitempty"`
		Backdrop   *map[string]string `json:"Backdrop,omitempty"`
		Banner     *map[string]string `json:"Banner,omitempty"`
		Box        *map[string]string `json:"Box,omitempty"`
		BoxRear    *map[string]string `json:"BoxRear,omitempty"`
		Chapter    *map[string]string `json:"Chapter,omitempty"`
		Disc       *map[string]string `json:"Disc,omitempty"`
		Logo       *map[string]string `json:"Logo,omitempty"`
		Menu       *map[string]string `json:"Menu,omitempty"`
		Primary    *map[string]string `json:"Primary,omitempty"`
		Profile    *map[string]string `json:"Profile,omitempty"`
		Screenshot *map[string]string `json:"Screenshot,omitempty"`
		Thumb      *map[string]string `json:"Thumb,omitempty"`
	} `json:"ImageBlurHashes"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// PrimaryImageTag Gets or sets the primary image tag.
	PrimaryImageTag *string `json:"PrimaryImageTag"`

	// Role Gets or sets the role.
	Role *string `json:"Role"`

	// Type Gets or sets the type.
	Type *string `json:"Type"`
}

// BasePluginConfiguration Class BasePluginConfiguration.
type BasePluginConfiguration = map[string]interface{}

// BookInfo defines model for BookInfo.
type BookInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`
	SeriesName  *string             `json:"SeriesName"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// BookInfoRemoteSearchQuery defines model for BookInfoRemoteSearchQuery.
type BookInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *BookInfo           `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// BoxSetInfo defines model for BoxSetInfo.
type BoxSetInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// BoxSetInfoRemoteSearchQuery defines model for BoxSetInfoRemoteSearchQuery.
type BoxSetInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *BoxSetInfo         `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// BrandingOptions The branding options.
type BrandingOptions struct {
	// CustomCss Gets or sets the custom CSS.
	CustomCss *string `json:"CustomCss"`

	// LoginDisclaimer Gets or sets the login disclaimer.
	LoginDisclaimer *string `json:"LoginDisclaimer"`

	// SplashscreenEnabled Gets or sets a value indicating whether to enable the splashscreen.
	SplashscreenEnabled *bool `json:"SplashscreenEnabled,omitempty"`
}

// BufferRequestDto Class BufferRequestDto.
type BufferRequestDto struct {
	// IsPlaying Gets or sets a value indicating whether the client playback is unpaused.
	IsPlaying *bool `json:"IsPlaying,omitempty"`

	// PlaylistItemId Gets or sets the playlist item identifier of the playing item.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`

	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks,omitempty"`

	// When Gets or sets when the request has been made by the client.
	When *time.Time `json:"When,omitempty"`
}

// ChannelFeatures defines model for ChannelFeatures.
type ChannelFeatures struct {
	// AutoRefreshLevels Gets or sets the automatic refresh levels.
	AutoRefreshLevels *int32 `json:"AutoRefreshLevels"`

	// CanFilter Gets or sets a value indicating whether this instance can filter.
	CanFilter *bool `json:"CanFilter,omitempty"`

	// CanSearch Gets or sets a value indicating whether this instance can search.
	CanSearch *bool `json:"CanSearch,omitempty"`

	// ContentTypes Gets or sets the content types.
	ContentTypes *[]ChannelMediaContentType `json:"ContentTypes,omitempty"`

	// DefaultSortFields Gets or sets the default sort orders.
	DefaultSortFields *[]ChannelItemSortField `json:"DefaultSortFields,omitempty"`

	// Id Gets or sets the identifier.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// MaxPageSize Gets or sets the maximum number of records the channel allows retrieving at a time.
	MaxPageSize *int32 `json:"MaxPageSize"`

	// MediaTypes Gets or sets the media types.
	MediaTypes *[]ChannelMediaType `json:"MediaTypes,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name,omitempty"`

	// SupportsContentDownloading Gets or sets a value indicating whether [supports content downloading].
	SupportsContentDownloading *bool `json:"SupportsContentDownloading,omitempty"`

	// SupportsLatestMedia Gets or sets a value indicating whether [supports latest media].
	SupportsLatestMedia *bool `json:"SupportsLatestMedia,omitempty"`

	// SupportsSortOrderToggle Gets or sets a value indicating whether a sort ascending/descending toggle is supported.
	SupportsSortOrderToggle *bool `json:"SupportsSortOrderToggle,omitempty"`
}

// ChannelItemSortField defines model for ChannelItemSortField.
type ChannelItemSortField string

// ChannelMappingOptionsDto Channel mapping options dto.
type ChannelMappingOptionsDto struct {
	// Mappings Gets or sets list of mappings.
	Mappings *[]NameValuePair `json:"Mappings,omitempty"`

	// ProviderChannels Gets or sets list of provider channels.
	ProviderChannels *[]NameIdPair `json:"ProviderChannels,omitempty"`

	// ProviderName Gets or sets provider name.
	ProviderName *string `json:"ProviderName"`

	// TunerChannels Gets or sets list of tuner channels.
	TunerChannels *[]TunerChannelMapping `json:"TunerChannels,omitempty"`
}

// ChannelMediaContentType defines model for ChannelMediaContentType.
type ChannelMediaContentType string

// ChannelMediaType defines model for ChannelMediaType.
type ChannelMediaType string

// ChannelType Enum ChannelType.
type ChannelType string

// ChapterInfo Class ChapterInfo.
type ChapterInfo struct {
	ImageDateModified *time.Time `json:"ImageDateModified,omitempty"`

	// ImagePath Gets or sets the image path.
	ImagePath *string `json:"ImagePath"`
	ImageTag  *string `json:"ImageTag"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// StartPositionTicks Gets or sets the start position ticks.
	StartPositionTicks *int64 `json:"StartPositionTicks,omitempty"`
}

// ClientCapabilities defines model for ClientCapabilities.
type ClientCapabilities struct {
	AppStoreUrl *string `json:"AppStoreUrl"`

	// DeviceProfile A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
	// <br />
	// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
	// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
	// the device is able to direct play (without transcoding or remuxing),
	// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
	DeviceProfile                *DeviceProfile        `json:"DeviceProfile"`
	IconUrl                      *string               `json:"IconUrl"`
	MessageCallbackUrl           *string               `json:"MessageCallbackUrl"`
	PlayableMediaTypes           *[]string             `json:"PlayableMediaTypes"`
	SupportedCommands            *[]GeneralCommandType `json:"SupportedCommands"`
	SupportsContentUploading     *bool                 `json:"SupportsContentUploading,omitempty"`
	SupportsMediaControl         *bool                 `json:"SupportsMediaControl,omitempty"`
	SupportsPersistentIdentifier *bool                 `json:"SupportsPersistentIdentifier,omitempty"`
	SupportsSync                 *bool                 `json:"SupportsSync,omitempty"`
}

// ClientCapabilitiesDto Client capabilities dto.
type ClientCapabilitiesDto struct {
	// AppStoreUrl Gets or sets the app store url.
	AppStoreUrl *string `json:"AppStoreUrl"`

	// DeviceProfile A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
	// <br />
	// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
	// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
	// the device is able to direct play (without transcoding or remuxing),
	// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
	DeviceProfile *DeviceProfile `json:"DeviceProfile"`

	// IconUrl Gets or sets the icon url.
	IconUrl *string `json:"IconUrl"`

	// MessageCallbackUrl Gets or sets the message callback url.
	MessageCallbackUrl *string `json:"MessageCallbackUrl"`

	// PlayableMediaTypes Gets or sets the list of playable media types.
	PlayableMediaTypes *[]string `json:"PlayableMediaTypes,omitempty"`

	// SupportedCommands Gets or sets the list of supported commands.
	SupportedCommands *[]GeneralCommandType `json:"SupportedCommands,omitempty"`

	// SupportsContentUploading Gets or sets a value indicating whether session supports content uploading.
	SupportsContentUploading *bool `json:"SupportsContentUploading,omitempty"`

	// SupportsMediaControl Gets or sets a value indicating whether session supports media control.
	SupportsMediaControl *bool `json:"SupportsMediaControl,omitempty"`

	// SupportsPersistentIdentifier Gets or sets a value indicating whether session supports a persistent identifier.
	SupportsPersistentIdentifier *bool `json:"SupportsPersistentIdentifier,omitempty"`

	// SupportsSync Gets or sets a value indicating whether session supports sync.
	SupportsSync *bool `json:"SupportsSync,omitempty"`
}

// ClientLogDocumentResponseDto Client log document response dto.
type ClientLogDocumentResponseDto struct {
	// FileName Gets the resulting filename.
	FileName *string `json:"FileName,omitempty"`
}

// CodecProfile defines model for CodecProfile.
type CodecProfile struct {
	ApplyConditions *[]ProfileCondition `json:"ApplyConditions"`
	Codec           *string             `json:"Codec"`
	Conditions      *[]ProfileCondition `json:"Conditions"`
	Container       *string             `json:"Container"`
	Type            *CodecType          `json:"Type,omitempty"`
}

// CodecType defines model for CodecType.
type CodecType string

// CollectionCreationResult defines model for CollectionCreationResult.
type CollectionCreationResult struct {
	Id *openapi_types.UUID `json:"Id,omitempty"`
}

// CollectionTypeOptions defines model for CollectionTypeOptions.
type CollectionTypeOptions string

// ConfigImageTypes defines model for ConfigImageTypes.
type ConfigImageTypes struct {
	BackdropSizes *[]string `json:"BackdropSizes"`
	BaseUrl       *string   `json:"BaseUrl"`
	LogoSizes     *[]string `json:"LogoSizes"`
	PosterSizes   *[]string `json:"PosterSizes"`
	ProfileSizes  *[]string `json:"ProfileSizes"`
	SecureBaseUrl *string   `json:"SecureBaseUrl"`
	StillSizes    *[]string `json:"StillSizes"`
}

// ConfigurationPageInfo The configuration page info.
type ConfigurationPageInfo struct {
	// DisplayName Gets or sets the display name.
	DisplayName *string `json:"DisplayName"`

	// EnableInMainMenu Gets or sets a value indicating whether the configurations page is enabled in the main menu.
	EnableInMainMenu *bool `json:"EnableInMainMenu,omitempty"`

	// MenuIcon Gets or sets the menu icon.
	MenuIcon *string `json:"MenuIcon"`

	// MenuSection Gets or sets the menu section.
	MenuSection *string `json:"MenuSection"`

	// Name Gets or sets the name.
	Name *string `json:"Name,omitempty"`

	// PluginId Gets or sets the plugin id.
	PluginId *openapi_types.UUID `json:"PluginId"`
}

// ContainerProfile defines model for ContainerProfile.
type ContainerProfile struct {
	Conditions *[]ProfileCondition `json:"Conditions"`
	Container  *string             `json:"Container,omitempty"`
	Type       *DlnaProfileType    `json:"Type,omitempty"`
}

// CountryInfo Class CountryInfo.
type CountryInfo struct {
	// DisplayName Gets or sets the display name.
	DisplayName *string `json:"DisplayName"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// ThreeLetterISORegionName Gets or sets the name of the three letter ISO region.
	ThreeLetterISORegionName *string `json:"ThreeLetterISORegionName"`

	// TwoLetterISORegionName Gets or sets the name of the two letter ISO region.
	TwoLetterISORegionName *string `json:"TwoLetterISORegionName"`
}

// CreatePlaylistDto Create new playlist dto.
type CreatePlaylistDto struct {
	// Ids Gets or sets item ids to add to the playlist.
	Ids *[]openapi_types.UUID `json:"Ids,omitempty"`

	// MediaType Gets or sets the media type.
	MediaType *string `json:"MediaType"`

	// Name Gets or sets the name of the new playlist.
	Name *string `json:"Name"`

	// UserId Gets or sets the user id.
	UserId *openapi_types.UUID `json:"UserId"`
}

// CreateUserByName The create user by name request body.
type CreateUserByName struct {
	// Name Gets or sets the username.
	Name *string `json:"Name"`

	// Password Gets or sets the password.
	Password *string `json:"Password"`
}

// CultureDto Class CultureDto.
type CultureDto struct {
	// DisplayName Gets the display name.
	DisplayName *string `json:"DisplayName,omitempty"`

	// Name Gets the name.
	Name *string `json:"Name,omitempty"`

	// ThreeLetterISOLanguageName Gets the name of the three letter ISO language.
	ThreeLetterISOLanguageName  *string   `json:"ThreeLetterISOLanguageName"`
	ThreeLetterISOLanguageNames *[]string `json:"ThreeLetterISOLanguageNames,omitempty"`

	// TwoLetterISOLanguageName Gets the name of the two letter ISO language.
	TwoLetterISOLanguageName *string `json:"TwoLetterISOLanguageName,omitempty"`
}

// CustomQueryData defines model for CustomQueryData.
type CustomQueryData struct {
	CustomQueryString *string `json:"CustomQueryString,omitempty"`
	ReplaceUserId     *bool   `json:"ReplaceUserId,omitempty"`
}

// DayOfWeek defines model for DayOfWeek.
type DayOfWeek string

// DayPattern defines model for DayPattern.
type DayPattern string

// DefaultDirectoryBrowserInfoDto Default directory browser info.
type DefaultDirectoryBrowserInfoDto struct {
	// Path Gets or sets the path.
	Path *string `json:"Path"`
}

// DeviceIdentification defines model for DeviceIdentification.
type DeviceIdentification struct {
	// FriendlyName Gets or sets the name of the friendly.
	FriendlyName *string `json:"FriendlyName,omitempty"`

	// Headers Gets or sets the headers.
	Headers *[]HttpHeaderInfo `json:"Headers,omitempty"`

	// Manufacturer Gets or sets the manufacturer.
	Manufacturer *string `json:"Manufacturer,omitempty"`

	// ManufacturerUrl Gets or sets the manufacturer URL.
	ManufacturerUrl *string `json:"ManufacturerUrl,omitempty"`

	// ModelDescription Gets or sets the model description.
	ModelDescription *string `json:"ModelDescription,omitempty"`

	// ModelName Gets or sets the name of the model.
	ModelName *string `json:"ModelName,omitempty"`

	// ModelNumber Gets or sets the model number.
	ModelNumber *string `json:"ModelNumber,omitempty"`

	// ModelUrl Gets or sets the model URL.
	ModelUrl *string `json:"ModelUrl,omitempty"`

	// SerialNumber Gets or sets the serial number.
	SerialNumber *string `json:"SerialNumber,omitempty"`
}

// DeviceInfo defines model for DeviceInfo.
type DeviceInfo struct {
	// AccessToken Gets or sets the access token.
	AccessToken *string `json:"AccessToken"`

	// AppName Gets or sets the name of the application.
	AppName *string `json:"AppName"`

	// AppVersion Gets or sets the application version.
	AppVersion *string `json:"AppVersion"`

	// Capabilities Gets or sets the capabilities.
	Capabilities *ClientCapabilities `json:"Capabilities"`

	// DateLastActivity Gets or sets the date last modified.
	DateLastActivity *time.Time `json:"DateLastActivity,omitempty"`
	IconUrl          *string    `json:"IconUrl"`

	// Id Gets or sets the identifier.
	Id *string `json:"Id"`

	// LastUserId Gets or sets the last user identifier.
	LastUserId *openapi_types.UUID `json:"LastUserId,omitempty"`

	// LastUserName Gets or sets the last name of the user.
	LastUserName *string `json:"LastUserName"`
	Name         *string `json:"Name"`
}

// DeviceInfoQueryResult defines model for DeviceInfoQueryResult.
type DeviceInfoQueryResult struct {
	// Items Gets or sets the items.
	Items *[]DeviceInfo `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// DeviceOptions An entity representing custom options for a device.
type DeviceOptions struct {
	// CustomName Gets or sets the custom name.
	CustomName *string `json:"CustomName"`

	// DeviceId Gets the device id.
	DeviceId *string `json:"DeviceId,omitempty"`

	// Id Gets the id.
	Id *int32 `json:"Id,omitempty"`
}

// DeviceOptionsDto A dto representing custom options for a device.
type DeviceOptionsDto struct {
	// CustomName Gets or sets the custom name.
	CustomName *string `json:"CustomName"`

	// DeviceId Gets or sets the device id.
	DeviceId *string `json:"DeviceId"`

	// Id Gets or sets the id.
	Id *int32 `json:"Id,omitempty"`
}

// DeviceProfile A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
// <br />
// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
// the device is able to direct play (without transcoding or remuxing),
// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
type DeviceProfile struct {
	// AlbumArtPn Gets or sets the AlbumArtPn.
	AlbumArtPn *string `json:"AlbumArtPn"`

	// CodecProfiles Gets or sets the codec profiles.
	CodecProfiles *[]CodecProfile `json:"CodecProfiles,omitempty"`

	// ContainerProfiles Gets or sets the container profiles.
	ContainerProfiles *[]ContainerProfile `json:"ContainerProfiles,omitempty"`

	// DirectPlayProfiles Gets or sets the direct play profiles.
	DirectPlayProfiles *[]DirectPlayProfile `json:"DirectPlayProfiles,omitempty"`

	// EnableAlbumArtInDidl Gets or sets a value indicating whether EnableAlbumArtInDidl.
	EnableAlbumArtInDidl *bool `json:"EnableAlbumArtInDidl,omitempty"`

	// EnableMSMediaReceiverRegistrar Gets or sets a value indicating whether EnableMSMediaReceiverRegistrar.
	EnableMSMediaReceiverRegistrar *bool `json:"EnableMSMediaReceiverRegistrar,omitempty"`

	// EnableSingleAlbumArtLimit Gets or sets a value indicating whether EnableSingleAlbumArtLimit.
	EnableSingleAlbumArtLimit *bool `json:"EnableSingleAlbumArtLimit,omitempty"`

	// EnableSingleSubtitleLimit Gets or sets a value indicating whether EnableSingleSubtitleLimit.
	EnableSingleSubtitleLimit *bool `json:"EnableSingleSubtitleLimit,omitempty"`

	// FriendlyName Gets or sets the friendly name of the device profile, which can be shown to users.
	FriendlyName *string `json:"FriendlyName"`

	// Id Gets or sets the Id.
	Id *string `json:"Id"`

	// Identification Gets or sets the Identification.
	Identification *DeviceIdentification `json:"Identification"`

	// IgnoreTranscodeByteRangeRequests Gets or sets a value indicating whether IgnoreTranscodeByteRangeRequests.
	IgnoreTranscodeByteRangeRequests *bool `json:"IgnoreTranscodeByteRangeRequests,omitempty"`

	// Manufacturer Gets or sets the manufacturer of the device which this profile represents.
	Manufacturer *string `json:"Manufacturer"`

	// ManufacturerUrl Gets or sets an url for the manufacturer of the device which this profile represents.
	ManufacturerUrl *string `json:"ManufacturerUrl"`

	// MaxAlbumArtHeight Gets or sets the MaxAlbumArtHeight.
	MaxAlbumArtHeight *int32 `json:"MaxAlbumArtHeight"`

	// MaxAlbumArtWidth Gets or sets the MaxAlbumArtWidth.
	MaxAlbumArtWidth *int32 `json:"MaxAlbumArtWidth"`

	// MaxIconHeight Gets or sets the maximum allowed height of embedded icons.
	MaxIconHeight *int32 `json:"MaxIconHeight"`

	// MaxIconWidth Gets or sets the maximum allowed width of embedded icons.
	MaxIconWidth *int32 `json:"MaxIconWidth"`

	// MaxStaticBitrate Gets or sets the maximum allowed bitrate for statically streamed content (= direct played files).
	MaxStaticBitrate *int32 `json:"MaxStaticBitrate"`

	// MaxStaticMusicBitrate Gets or sets the maximum allowed bitrate for statically streamed (= direct played) music files.
	MaxStaticMusicBitrate *int32 `json:"MaxStaticMusicBitrate"`

	// MaxStreamingBitrate Gets or sets the maximum allowed bitrate for all streamed content.
	MaxStreamingBitrate *int32 `json:"MaxStreamingBitrate"`

	// ModelDescription Gets or sets the model description of the device which this profile represents.
	ModelDescription *string `json:"ModelDescription"`

	// ModelName Gets or sets the model name of the device which this profile represents.
	ModelName *string `json:"ModelName"`

	// ModelNumber Gets or sets the model number of the device which this profile represents.
	ModelNumber *string `json:"ModelNumber"`

	// ModelUrl Gets or sets the ModelUrl.
	ModelUrl *string `json:"ModelUrl"`

	// MusicStreamingTranscodingBitrate Gets or sets the maximum allowed bitrate for transcoded music streams.
	MusicStreamingTranscodingBitrate *int32 `json:"MusicStreamingTranscodingBitrate"`

	// Name Gets or sets the name of this device profile.
	Name *string `json:"Name"`

	// ProtocolInfo Gets or sets the ProtocolInfo.
	ProtocolInfo *string `json:"ProtocolInfo"`

	// RequiresPlainFolders Gets or sets a value indicating whether RequiresPlainFolders.
	RequiresPlainFolders *bool `json:"RequiresPlainFolders,omitempty"`

	// RequiresPlainVideoItems Gets or sets a value indicating whether RequiresPlainVideoItems.
	RequiresPlainVideoItems *bool `json:"RequiresPlainVideoItems,omitempty"`

	// ResponseProfiles Gets or sets the ResponseProfiles.
	ResponseProfiles *[]ResponseProfile `json:"ResponseProfiles,omitempty"`

	// SerialNumber Gets or sets the serial number of the device which this profile represents.
	SerialNumber *string `json:"SerialNumber"`

	// SonyAggregationFlags Gets or sets the content of the aggregationFlags element in the urn:schemas-sonycom:av namespace.
	SonyAggregationFlags *string `json:"SonyAggregationFlags"`

	// SubtitleProfiles Gets or sets the subtitle profiles.
	SubtitleProfiles *[]SubtitleProfile `json:"SubtitleProfiles,omitempty"`

	// SupportedMediaTypes Gets or sets the SupportedMediaTypes.
	SupportedMediaTypes *string `json:"SupportedMediaTypes,omitempty"`

	// TimelineOffsetSeconds Gets or sets the TimelineOffsetSeconds.
	TimelineOffsetSeconds *int32 `json:"TimelineOffsetSeconds,omitempty"`

	// TranscodingProfiles Gets or sets the transcoding profiles.
	TranscodingProfiles *[]TranscodingProfile `json:"TranscodingProfiles,omitempty"`

	// UserId Gets or sets the UserId.
	UserId *string `json:"UserId"`

	// XmlRootAttributes Gets or sets the XmlRootAttributes.
	XmlRootAttributes *[]XmlAttribute `json:"XmlRootAttributes,omitempty"`
}

// DeviceProfileInfo defines model for DeviceProfileInfo.
type DeviceProfileInfo struct {
	// Id Gets or sets the identifier.
	Id *string `json:"Id"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Type Gets or sets the type.
	Type *DeviceProfileType `json:"Type,omitempty"`
}

// DeviceProfileType defines model for DeviceProfileType.
type DeviceProfileType string

// DirectPlayProfile defines model for DirectPlayProfile.
type DirectPlayProfile struct {
	AudioCodec *string          `json:"AudioCodec"`
	Container  *string          `json:"Container"`
	Type       *DlnaProfileType `json:"Type,omitempty"`
	VideoCodec *string          `json:"VideoCodec"`
}

// DisplayPreferencesDto Defines the display preferences for any item that supports them (usually Folders).
type DisplayPreferencesDto struct {
	// Client Gets or sets the client.
	Client *string `json:"Client"`

	// CustomPrefs Gets or sets the custom prefs.
	CustomPrefs *map[string]*string `json:"CustomPrefs,omitempty"`

	// Id Gets or sets the user id.
	Id *string `json:"Id"`

	// IndexBy Gets or sets the index by.
	IndexBy *string `json:"IndexBy"`

	// PrimaryImageHeight Gets or sets the height of the primary image.
	PrimaryImageHeight *int32 `json:"PrimaryImageHeight,omitempty"`

	// PrimaryImageWidth Gets or sets the width of the primary image.
	PrimaryImageWidth *int32 `json:"PrimaryImageWidth,omitempty"`

	// RememberIndexing Gets or sets a value indicating whether [remember indexing].
	RememberIndexing *bool `json:"RememberIndexing,omitempty"`

	// RememberSorting Gets or sets a value indicating whether [remember sorting].
	RememberSorting *bool `json:"RememberSorting,omitempty"`

	// ScrollDirection Gets or sets the scroll direction.
	ScrollDirection *ScrollDirection `json:"ScrollDirection,omitempty"`

	// ShowBackdrop Gets or sets a value indicating whether to show backdrops on this item.
	ShowBackdrop *bool `json:"ShowBackdrop,omitempty"`

	// ShowSidebar Gets or sets a value indicating whether [show sidebar].
	ShowSidebar *bool `json:"ShowSidebar,omitempty"`

	// SortBy Gets or sets the sort by.
	SortBy *string `json:"SortBy"`

	// SortOrder Gets or sets the sort order.
	SortOrder *SortOrder `json:"SortOrder,omitempty"`

	// ViewType Gets or sets the type of the view.
	ViewType *string `json:"ViewType"`
}

// DlnaProfileType defines model for DlnaProfileType.
type DlnaProfileType string

// DynamicDayOfWeek An enum that represents a day of the week, weekdays, weekends, or all days.
type DynamicDayOfWeek string

// EmbeddedSubtitleOptions An enum representing the options to disable embedded subs.
type EmbeddedSubtitleOptions string

// EncodingContext defines model for EncodingContext.
type EncodingContext string

// EndPointInfo defines model for EndPointInfo.
type EndPointInfo struct {
	IsInNetwork *bool `json:"IsInNetwork,omitempty"`
	IsLocal     *bool `json:"IsLocal,omitempty"`
}

// ExternalIdInfo Represents the external id information for serialization to the client.
type ExternalIdInfo struct {
	// Key Gets or sets the unique key for this id. This key should be unique across all providers.
	Key *string `json:"Key,omitempty"`

	// Name Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc).
	Name *string `json:"Name,omitempty"`

	// Type Gets or sets the specific media type for this id. This is used to distinguish between the different
	// external id types for providers with multiple ids.
	// A null value indicates there is no specific media type associated with the external id, or this is the
	// default id for the external provider so there is no need to specify a type.
	Type *ExternalIdMediaType `json:"Type"`

	// UrlFormatString Gets or sets the URL format string.
	UrlFormatString *string `json:"UrlFormatString"`
}

// ExternalIdMediaType The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
type ExternalIdMediaType string

// ExternalUrl defines model for ExternalUrl.
type ExternalUrl struct {
	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Url Gets or sets the type of the item.
	Url *string `json:"Url"`
}

// FFmpegLocation Enum describing the location of the FFmpeg tool.
type FFmpegLocation string

// FileSystemEntryInfo Class FileSystemEntryInfo.
type FileSystemEntryInfo struct {
	// Name Gets the name.
	Name *string `json:"Name,omitempty"`

	// Path Gets the path.
	Path *string `json:"Path,omitempty"`

	// Type Gets the type.
	Type *FileSystemEntryType `json:"Type,omitempty"`
}

// FileSystemEntryType Enum FileSystemEntryType.
type FileSystemEntryType string

// FontFile Class FontFile.
type FontFile struct {
	// DateCreated Gets or sets the date created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`

	// DateModified Gets or sets the date modified.
	DateModified *time.Time `json:"DateModified,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Size Gets or sets the size.
	Size *int64 `json:"Size,omitempty"`
}

// ForgotPasswordAction defines model for ForgotPasswordAction.
type ForgotPasswordAction string

// ForgotPasswordDto Forgot Password request body DTO.
type ForgotPasswordDto struct {
	// EnteredUsername Gets or sets the entered username to have its password reset.
	EnteredUsername string `json:"EnteredUsername"`
}

// ForgotPasswordPinDto Forgot Password Pin enter request body DTO.
type ForgotPasswordPinDto struct {
	// Pin Gets or sets the entered pin to have the password reset.
	Pin string `json:"Pin"`
}

// ForgotPasswordResult defines model for ForgotPasswordResult.
type ForgotPasswordResult struct {
	// Action Gets or sets the action.
	Action *ForgotPasswordAction `json:"Action,omitempty"`

	// PinExpirationDate Gets or sets the pin expiration date.
	PinExpirationDate *time.Time `json:"PinExpirationDate"`

	// PinFile Gets or sets the pin file.
	PinFile *string `json:"PinFile"`
}

// GeneralCommand defines model for GeneralCommand.
type GeneralCommand struct {
	Arguments         *map[string]*string `json:"Arguments,omitempty"`
	ControllingUserId *openapi_types.UUID `json:"ControllingUserId,omitempty"`

	// Name This exists simply to identify a set of known commands.
	Name *GeneralCommandType `json:"Name,omitempty"`
}

// GeneralCommandType This exists simply to identify a set of known commands.
type GeneralCommandType string

// GetProgramsDto Get programs dto.
type GetProgramsDto struct {
	// ChannelIds Gets or sets the channels to return guide information for.
	ChannelIds *[]openapi_types.UUID `json:"ChannelIds,omitempty"`

	// EnableImageTypes Gets or sets the image types to include in the output.
	// Optional.
	EnableImageTypes *[]ImageType `json:"EnableImageTypes,omitempty"`

	// EnableImages Gets or sets include image information in output.
	// Optional.
	EnableImages *bool `json:"EnableImages"`

	// EnableTotalRecordCount Gets or sets a value indicating whether retrieve total record count.
	EnableTotalRecordCount *bool `json:"EnableTotalRecordCount,omitempty"`

	// EnableUserData Gets or sets include user data.
	// Optional.
	EnableUserData *bool `json:"EnableUserData"`

	// Fields Gets or sets specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
	// Optional.
	Fields *[]ItemFields `json:"Fields,omitempty"`

	// GenreIds Gets or sets the genre ids to return guide information for.
	GenreIds *[]openapi_types.UUID `json:"GenreIds,omitempty"`

	// Genres Gets or sets the genres to return guide information for.
	Genres *[]string `json:"Genres,omitempty"`

	// HasAired Gets or sets filter by programs that have completed airing, or not.
	// Optional.
	HasAired *bool `json:"HasAired"`

	// ImageTypeLimit Gets or sets the max number of images to return, per image type.
	// Optional.
	ImageTypeLimit *int32 `json:"ImageTypeLimit"`

	// IsAiring Gets or sets filter by programs that are currently airing, or not.
	// Optional.
	IsAiring *bool `json:"IsAiring"`

	// IsKids Gets or sets filter for kids.
	// Optional.
	IsKids *bool `json:"IsKids"`

	// IsMovie Gets or sets filter for movies.
	// Optional.
	IsMovie *bool `json:"IsMovie"`

	// IsNews Gets or sets filter for news.
	// Optional.
	IsNews *bool `json:"IsNews"`

	// IsSeries Gets or sets filter for series.
	// Optional.
	IsSeries *bool `json:"IsSeries"`

	// IsSports Gets or sets filter for sports.
	// Optional.
	IsSports *bool `json:"IsSports"`

	// LibrarySeriesId Gets or sets filter by library series id.
	// Optional.
	LibrarySeriesId *openapi_types.UUID `json:"LibrarySeriesId,omitempty"`

	// Limit Gets or sets the maximum number of records to return.
	// Optional.
	Limit *int32 `json:"Limit"`

	// MaxEndDate Gets or sets the maximum premiere end date.
	// Optional.
	MaxEndDate *time.Time `json:"MaxEndDate"`

	// MaxStartDate Gets or sets the maximum premiere start date.
	// Optional.
	MaxStartDate *time.Time `json:"MaxStartDate"`

	// MinEndDate Gets or sets the minimum premiere end date.
	// Optional.
	MinEndDate *time.Time `json:"MinEndDate"`

	// MinStartDate Gets or sets the minimum premiere start date.
	// Optional.
	MinStartDate *time.Time `json:"MinStartDate"`

	// SeriesTimerId Gets or sets filter by series timer id.
	// Optional.
	SeriesTimerId *string `json:"SeriesTimerId"`

	// SortBy Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.
	// Optional.
	SortBy *[]string `json:"SortBy,omitempty"`

	// SortOrder Gets or sets sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `json:"SortOrder,omitempty"`

	// StartIndex Gets or sets the record index to start at. All items with a lower index will be dropped from the results.
	// Optional.
	StartIndex *int32 `json:"StartIndex"`

	// UserId Gets or sets optional. Filter by user id.
	UserId *openapi_types.UUID `json:"UserId,omitempty"`
}

// GroupInfoDto Class GroupInfoDto.
type GroupInfoDto struct {
	// GroupId Gets the group identifier.
	GroupId *openapi_types.UUID `json:"GroupId,omitempty"`

	// GroupName Gets the group name.
	GroupName *string `json:"GroupName,omitempty"`

	// LastUpdatedAt Gets the date when this DTO has been created.
	LastUpdatedAt *time.Time `json:"LastUpdatedAt,omitempty"`

	// Participants Gets the participants.
	Participants *[]string `json:"Participants,omitempty"`

	// State Gets the group state.
	State *GroupStateType `json:"State,omitempty"`
}

// GroupQueueMode Enum GroupQueueMode.
type GroupQueueMode string

// GroupRepeatMode Enum GroupRepeatMode.
type GroupRepeatMode string

// GroupShuffleMode Enum GroupShuffleMode.
type GroupShuffleMode string

// GroupStateType Enum GroupState.
type GroupStateType string

// GuideInfo defines model for GuideInfo.
type GuideInfo struct {
	// EndDate Gets or sets the end date.
	EndDate *time.Time `json:"EndDate,omitempty"`

	// StartDate Gets or sets the start date.
	StartDate *time.Time `json:"StartDate,omitempty"`
}

// HardwareEncodingType Enum HardwareEncodingType.
type HardwareEncodingType string

// HeaderMatchType defines model for HeaderMatchType.
type HeaderMatchType string

// HeaderMetadata defines model for HeaderMetadata.
type HeaderMetadata string

// HttpHeaderInfo defines model for HttpHeaderInfo.
type HttpHeaderInfo struct {
	Match *HeaderMatchType `json:"Match,omitempty"`
	Name  *string          `json:"Name"`
	Value *string          `json:"Value"`
}

// IgnoreWaitRequestDto Class IgnoreWaitRequestDto.
type IgnoreWaitRequestDto struct {
	// IgnoreWait Gets or sets a value indicating whether the client should be ignored.
	IgnoreWait *bool `json:"IgnoreWait,omitempty"`
}

// ImageByNameInfo defines model for ImageByNameInfo.
type ImageByNameInfo struct {
	// Context Gets or sets the context.
	Context *string `json:"Context"`

	// FileLength Gets or sets the length of the file.
	FileLength *int64 `json:"FileLength,omitempty"`

	// Format Gets or sets the format.
	Format *string `json:"Format"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Theme Gets or sets the theme.
	Theme *string `json:"Theme"`
}

// ImageFormat Enum ImageOutputFormat.
type ImageFormat string

// ImageInfo Class ImageInfo.
type ImageInfo struct {
	// BlurHash Gets or sets the blurhash.
	BlurHash *string `json:"BlurHash"`

	// Height Gets or sets the height.
	Height *int32 `json:"Height"`

	// ImageIndex Gets or sets the index of the image.
	ImageIndex *int32 `json:"ImageIndex"`

	// ImageTag Gets or sets the image tag.
	ImageTag *string `json:"ImageTag"`

	// ImageType Gets or sets the type of the image.
	ImageType *ImageType `json:"ImageType,omitempty"`

	// Path Gets or sets the path.
	Path *string `json:"Path"`

	// Size Gets or sets the size.
	Size *int64 `json:"Size,omitempty"`

	// Width Gets or sets the width.
	Width *int32 `json:"Width"`
}

// ImageOption defines model for ImageOption.
type ImageOption struct {
	// Limit Gets or sets the limit.
	Limit *int32 `json:"Limit,omitempty"`

	// MinWidth Gets or sets the minimum width.
	MinWidth *int32 `json:"MinWidth,omitempty"`

	// Type Gets or sets the type.
	Type *ImageType `json:"Type,omitempty"`
}

// ImageOrientation defines model for ImageOrientation.
type ImageOrientation string

// ImageProviderInfo Class ImageProviderInfo.
type ImageProviderInfo struct {
	// Name Gets the name.
	Name *string `json:"Name,omitempty"`

	// SupportedImages Gets the supported image types.
	SupportedImages *[]ImageType `json:"SupportedImages,omitempty"`
}

// ImageSavingConvention defines model for ImageSavingConvention.
type ImageSavingConvention string

// ImageType Enum ImageType.
type ImageType string

// InstallationInfo Class InstallationInfo.
type InstallationInfo struct {
	// Changelog Gets or sets the changelog for this version.
	Changelog *string `json:"Changelog"`

	// Checksum Gets or sets a checksum for the binary.
	Checksum *string `json:"Checksum"`

	// Guid Gets or sets the Id.
	Guid *openapi_types.UUID `json:"Guid,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// PackageInfo Gets or sets package information for the installation.
	PackageInfo *PackageInfo `json:"PackageInfo"`

	// SourceUrl Gets or sets the source URL.
	SourceUrl *string `json:"SourceUrl"`

	// Version Gets or sets the version.
	Version *string `json:"Version"`
}

// IsoType Enum IsoType.
type IsoType string

// ItemCounts Class LibrarySummary.
type ItemCounts struct {
	// AlbumCount Gets or sets the album count.
	AlbumCount *int32 `json:"AlbumCount,omitempty"`

	// ArtistCount Gets or sets the artist count.
	ArtistCount *int32 `json:"ArtistCount,omitempty"`

	// BookCount Gets or sets the book count.
	BookCount *int32 `json:"BookCount,omitempty"`

	// BoxSetCount Gets or sets the box set count.
	BoxSetCount *int32 `json:"BoxSetCount,omitempty"`

	// EpisodeCount Gets or sets the episode count.
	EpisodeCount *int32 `json:"EpisodeCount,omitempty"`

	// ItemCount Gets or sets the item count.
	ItemCount *int32 `json:"ItemCount,omitempty"`

	// MovieCount Gets or sets the movie count.
	MovieCount *int32 `json:"MovieCount,omitempty"`

	// MusicVideoCount Gets or sets the music video count.
	MusicVideoCount *int32 `json:"MusicVideoCount,omitempty"`

	// ProgramCount Gets or sets the program count.
	ProgramCount *int32 `json:"ProgramCount,omitempty"`

	// SeriesCount Gets or sets the series count.
	SeriesCount *int32 `json:"SeriesCount,omitempty"`

	// SongCount Gets or sets the song count.
	SongCount *int32 `json:"SongCount,omitempty"`

	// TrailerCount Gets or sets the trailer count.
	TrailerCount *int32 `json:"TrailerCount,omitempty"`
}

// ItemFields Used to control the data that gets attached to DtoBaseItems.
type ItemFields string

// ItemFilter Enum ItemFilter.
type ItemFilter string

// ItemViewType defines model for ItemViewType.
type ItemViewType string

// JoinGroupRequestDto Class JoinGroupRequestDto.
type JoinGroupRequestDto struct {
	// GroupId Gets or sets the group identifier.
	GroupId *openapi_types.UUID `json:"GroupId,omitempty"`
}

// KeepUntil defines model for KeepUntil.
type KeepUntil string

// LibraryOptionInfoDto Library option info dto.
type LibraryOptionInfoDto struct {
	// DefaultEnabled Gets or sets a value indicating whether default enabled.
	DefaultEnabled *bool `json:"DefaultEnabled,omitempty"`

	// Name Gets or sets name.
	Name *string `json:"Name"`
}

// LibraryOptions defines model for LibraryOptions.
type LibraryOptions struct {
	// AllowEmbeddedSubtitles An enum representing the options to disable embedded subs.
	AllowEmbeddedSubtitles        *EmbeddedSubtitleOptions `json:"AllowEmbeddedSubtitles,omitempty"`
	AutomaticRefreshIntervalDays  *int32                   `json:"AutomaticRefreshIntervalDays,omitempty"`
	AutomaticallyAddToCollection  *bool                    `json:"AutomaticallyAddToCollection,omitempty"`
	DisabledLocalMetadataReaders  *[]string                `json:"DisabledLocalMetadataReaders,omitempty"`
	DisabledSubtitleFetchers      *[]string                `json:"DisabledSubtitleFetchers,omitempty"`
	EnableAutomaticSeriesGrouping *bool                    `json:"EnableAutomaticSeriesGrouping,omitempty"`
	EnableChapterImageExtraction  *bool                    `json:"EnableChapterImageExtraction,omitempty"`
	EnableEmbeddedEpisodeInfos    *bool                    `json:"EnableEmbeddedEpisodeInfos,omitempty"`
	EnableEmbeddedTitles          *bool                    `json:"EnableEmbeddedTitles,omitempty"`
	// Deprecated:
	EnableInternetProviders               *bool     `json:"EnableInternetProviders,omitempty"`
	EnablePhotos                          *bool     `json:"EnablePhotos,omitempty"`
	EnableRealtimeMonitor                 *bool     `json:"EnableRealtimeMonitor,omitempty"`
	ExtractChapterImagesDuringLibraryScan *bool     `json:"ExtractChapterImagesDuringLibraryScan,omitempty"`
	LocalMetadataReaderOrder              *[]string `json:"LocalMetadataReaderOrder"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string          `json:"MetadataCountryCode"`
	MetadataSavers      *[]string        `json:"MetadataSavers"`
	PathInfos           *[]MediaPathInfo `json:"PathInfos,omitempty"`

	// PreferredMetadataLanguage Gets or sets the preferred metadata language.
	PreferredMetadataLanguage               *string        `json:"PreferredMetadataLanguage"`
	RequirePerfectSubtitleMatch             *bool          `json:"RequirePerfectSubtitleMatch,omitempty"`
	SaveLocalMetadata                       *bool          `json:"SaveLocalMetadata,omitempty"`
	SaveSubtitlesWithMedia                  *bool          `json:"SaveSubtitlesWithMedia,omitempty"`
	SeasonZeroDisplayName                   *string        `json:"SeasonZeroDisplayName,omitempty"`
	SkipSubtitlesIfAudioTrackMatches        *bool          `json:"SkipSubtitlesIfAudioTrackMatches,omitempty"`
	SkipSubtitlesIfEmbeddedSubtitlesPresent *bool          `json:"SkipSubtitlesIfEmbeddedSubtitlesPresent,omitempty"`
	SubtitleDownloadLanguages               *[]string      `json:"SubtitleDownloadLanguages"`
	SubtitleFetcherOrder                    *[]string      `json:"SubtitleFetcherOrder,omitempty"`
	TypeOptions                             *[]TypeOptions `json:"TypeOptions,omitempty"`
}

// LibraryOptionsResultDto Library options result dto.
type LibraryOptionsResultDto struct {
	// MetadataReaders Gets or sets the metadata readers.
	MetadataReaders *[]LibraryOptionInfoDto `json:"MetadataReaders,omitempty"`

	// MetadataSavers Gets or sets the metadata savers.
	MetadataSavers *[]LibraryOptionInfoDto `json:"MetadataSavers,omitempty"`

	// SubtitleFetchers Gets or sets the subtitle fetchers.
	SubtitleFetchers *[]LibraryOptionInfoDto `json:"SubtitleFetchers,omitempty"`

	// TypeOptions Gets or sets the type options.
	TypeOptions *[]LibraryTypeOptionsDto `json:"TypeOptions,omitempty"`
}

// LibraryTypeOptionsDto Library type options dto.
type LibraryTypeOptionsDto struct {
	// DefaultImageOptions Gets or sets the default image options.
	DefaultImageOptions *[]ImageOption `json:"DefaultImageOptions,omitempty"`

	// ImageFetchers Gets or sets the image fetchers.
	ImageFetchers *[]LibraryOptionInfoDto `json:"ImageFetchers,omitempty"`

	// MetadataFetchers Gets or sets the metadata fetchers.
	MetadataFetchers *[]LibraryOptionInfoDto `json:"MetadataFetchers,omitempty"`

	// SupportedImageTypes Gets or sets the supported image types.
	SupportedImageTypes *[]ImageType `json:"SupportedImageTypes,omitempty"`

	// Type Gets or sets the type.
	Type *string `json:"Type"`
}

// ListingsProviderInfo defines model for ListingsProviderInfo.
type ListingsProviderInfo struct {
	ChannelMappings   *[]NameValuePair `json:"ChannelMappings"`
	Country           *string          `json:"Country"`
	EnableAllTuners   *bool            `json:"EnableAllTuners,omitempty"`
	EnabledTuners     *[]string        `json:"EnabledTuners"`
	Id                *string          `json:"Id"`
	KidsCategories    *[]string        `json:"KidsCategories"`
	ListingsId        *string          `json:"ListingsId"`
	MovieCategories   *[]string        `json:"MovieCategories"`
	MoviePrefix       *string          `json:"MoviePrefix"`
	NewsCategories    *[]string        `json:"NewsCategories"`
	Password          *string          `json:"Password"`
	Path              *string          `json:"Path"`
	PreferredLanguage *string          `json:"PreferredLanguage"`
	SportsCategories  *[]string        `json:"SportsCategories"`
	Type              *string          `json:"Type"`
	UserAgent         *string          `json:"UserAgent"`
	Username          *string          `json:"Username"`
	ZipCode           *string          `json:"ZipCode"`
}

// LiveStreamResponse defines model for LiveStreamResponse.
type LiveStreamResponse struct {
	MediaSource *MediaSourceInfo `json:"MediaSource,omitempty"`
}

// LiveTvInfo defines model for LiveTvInfo.
type LiveTvInfo struct {
	// EnabledUsers Gets or sets the enabled users.
	EnabledUsers *[]string `json:"EnabledUsers,omitempty"`

	// IsEnabled Gets or sets a value indicating whether this instance is enabled.
	IsEnabled *bool `json:"IsEnabled,omitempty"`

	// Services Gets or sets the services.
	Services *[]LiveTvServiceInfo `json:"Services,omitempty"`
}

// LiveTvServiceInfo Class ServiceInfo.
type LiveTvServiceInfo struct {
	// HasUpdateAvailable Gets or sets a value indicating whether this instance has update available.
	HasUpdateAvailable *bool `json:"HasUpdateAvailable,omitempty"`

	// HomePageUrl Gets or sets the home page URL.
	HomePageUrl *string `json:"HomePageUrl"`

	// IsVisible Gets or sets a value indicating whether this instance is visible.
	IsVisible *bool `json:"IsVisible,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Status Gets or sets the status.
	Status *LiveTvServiceStatus `json:"Status,omitempty"`

	// StatusMessage Gets or sets the status message.
	StatusMessage *string   `json:"StatusMessage"`
	Tuners        *[]string `json:"Tuners"`

	// Version Gets or sets the version.
	Version *string `json:"Version"`
}

// LiveTvServiceStatus defines model for LiveTvServiceStatus.
type LiveTvServiceStatus string

// LocalizationOption defines model for LocalizationOption.
type LocalizationOption struct {
	Name  *string `json:"Name"`
	Value *string `json:"Value"`
}

// LocationType Enum LocationType.
type LocationType string

// LogFile defines model for LogFile.
type LogFile struct {
	// DateCreated Gets or sets the date created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`

	// DateModified Gets or sets the date modified.
	DateModified *time.Time `json:"DateModified,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Size Gets or sets the size.
	Size *int64 `json:"Size,omitempty"`
}

// LogLevel defines model for LogLevel.
type LogLevel string

// LoginInfoInput defines model for LoginInfoInput.
type LoginInfoInput struct {
	CustomApiKey *string `json:"CustomApiKey,omitempty"`
	Password     string  `json:"Password"`
	Username     string  `json:"Username"`
}

// MediaAttachment Class MediaAttachment.
type MediaAttachment struct {
	// Codec Gets or sets the codec.
	Codec *string `json:"Codec"`

	// CodecTag Gets or sets the codec tag.
	CodecTag *string `json:"CodecTag"`

	// Comment Gets or sets the comment.
	Comment *string `json:"Comment"`

	// DeliveryUrl Gets or sets the delivery URL.
	DeliveryUrl *string `json:"DeliveryUrl"`

	// FileName Gets or sets the filename.
	FileName *string `json:"FileName"`

	// Index Gets or sets the index.
	Index *int32 `json:"Index,omitempty"`

	// MimeType Gets or sets the MIME type.
	MimeType *string `json:"MimeType"`
}

// MediaEncoderPathDto Media Encoder Path Dto.
type MediaEncoderPathDto struct {
	// Path Gets or sets media encoder path.
	Path *string `json:"Path,omitempty"`

	// PathType Gets or sets media encoder path type.
	PathType *string `json:"PathType,omitempty"`
}

// MediaPathDto Media Path dto.
type MediaPathDto struct {
	// Name Gets or sets the name of the library.
	Name string `json:"Name"`

	// Path Gets or sets the path to add.
	Path *string `json:"Path"`

	// PathInfo Gets or sets the path info.
	PathInfo *MediaPathInfo `json:"PathInfo"`
}

// MediaPathInfo defines model for MediaPathInfo.
type MediaPathInfo struct {
	NetworkPath *string `json:"NetworkPath"`
	Path        *string `json:"Path,omitempty"`
}

// MediaProtocol defines model for MediaProtocol.
type MediaProtocol string

// MediaSourceInfo defines model for MediaSourceInfo.
type MediaSourceInfo struct {
	AnalyzeDurationMs          *int32         `json:"AnalyzeDurationMs"`
	Bitrate                    *int32         `json:"Bitrate"`
	BufferMs                   *int32         `json:"BufferMs"`
	Container                  *string        `json:"Container"`
	DefaultAudioStreamIndex    *int32         `json:"DefaultAudioStreamIndex"`
	DefaultSubtitleStreamIndex *int32         `json:"DefaultSubtitleStreamIndex"`
	ETag                       *string        `json:"ETag"`
	EncoderPath                *string        `json:"EncoderPath"`
	EncoderProtocol            *MediaProtocol `json:"EncoderProtocol"`
	Formats                    *[]string      `json:"Formats"`
	GenPtsInput                *bool          `json:"GenPtsInput,omitempty"`
	Id                         *string        `json:"Id"`
	IgnoreDts                  *bool          `json:"IgnoreDts,omitempty"`
	IgnoreIndex                *bool          `json:"IgnoreIndex,omitempty"`
	IsInfiniteStream           *bool          `json:"IsInfiniteStream,omitempty"`

	// IsRemote Gets or sets a value indicating whether the media is remote.
	// Differentiate internet url vs local network.
	IsRemote               *bool                     `json:"IsRemote,omitempty"`
	IsoType                *IsoType                  `json:"IsoType"`
	LiveStreamId           *string                   `json:"LiveStreamId"`
	MediaAttachments       *[]MediaAttachment        `json:"MediaAttachments"`
	MediaStreams           *[]MediaStream            `json:"MediaStreams"`
	Name                   *string                   `json:"Name"`
	OpenToken              *string                   `json:"OpenToken"`
	Path                   *string                   `json:"Path"`
	Protocol               *MediaProtocol            `json:"Protocol,omitempty"`
	ReadAtNativeFramerate  *bool                     `json:"ReadAtNativeFramerate,omitempty"`
	RequiredHttpHeaders    *map[string]*string       `json:"RequiredHttpHeaders"`
	RequiresClosing        *bool                     `json:"RequiresClosing,omitempty"`
	RequiresLooping        *bool                     `json:"RequiresLooping,omitempty"`
	RequiresOpening        *bool                     `json:"RequiresOpening,omitempty"`
	RunTimeTicks           *int64                    `json:"RunTimeTicks"`
	Size                   *int64                    `json:"Size"`
	SupportsDirectPlay     *bool                     `json:"SupportsDirectPlay,omitempty"`
	SupportsDirectStream   *bool                     `json:"SupportsDirectStream,omitempty"`
	SupportsProbing        *bool                     `json:"SupportsProbing,omitempty"`
	SupportsTranscoding    *bool                     `json:"SupportsTranscoding,omitempty"`
	Timestamp              *TransportStreamTimestamp `json:"Timestamp"`
	TranscodingContainer   *string                   `json:"TranscodingContainer"`
	TranscodingSubProtocol *string                   `json:"TranscodingSubProtocol"`
	TranscodingUrl         *string                   `json:"TranscodingUrl"`
	Type                   *MediaSourceType          `json:"Type,omitempty"`
	Video3DFormat          *Video3DFormat            `json:"Video3DFormat"`
	VideoType              *VideoType                `json:"VideoType"`
}

// MediaSourceType defines model for MediaSourceType.
type MediaSourceType string

// MediaStream Class MediaStream.
type MediaStream struct {
	// AspectRatio Gets or sets the aspect ratio.
	AspectRatio *string `json:"AspectRatio"`

	// AverageFrameRate Gets or sets the average frame rate.
	AverageFrameRate *float32 `json:"AverageFrameRate"`

	// BitDepth Gets or sets the bit depth.
	BitDepth *int32 `json:"BitDepth"`

	// BitRate Gets or sets the bit rate.
	BitRate *int32 `json:"BitRate"`

	// BlPresentFlag Gets or sets the Dolby Vision bl present flag.
	BlPresentFlag *int32 `json:"BlPresentFlag"`

	// ChannelLayout Gets or sets the channel layout.
	ChannelLayout *string `json:"ChannelLayout"`

	// Channels Gets or sets the channels.
	Channels *int32 `json:"Channels"`

	// Codec Gets or sets the codec.
	Codec *string `json:"Codec"`

	// CodecTag Gets or sets the codec tag.
	CodecTag *string `json:"CodecTag"`

	// CodecTimeBase Gets or sets the codec time base.
	CodecTimeBase *string `json:"CodecTimeBase"`

	// ColorPrimaries Gets or sets the color primaries.
	ColorPrimaries *string `json:"ColorPrimaries"`

	// ColorRange Gets or sets the color range.
	ColorRange *string `json:"ColorRange"`

	// ColorSpace Gets or sets the color space.
	ColorSpace *string `json:"ColorSpace"`

	// ColorTransfer Gets or sets the color transfer.
	ColorTransfer *string `json:"ColorTransfer"`

	// Comment Gets or sets the comment.
	Comment *string `json:"Comment"`

	// DeliveryMethod Gets or sets the method.
	DeliveryMethod *SubtitleDeliveryMethod `json:"DeliveryMethod"`

	// DeliveryUrl Gets or sets the delivery URL.
	DeliveryUrl  *string `json:"DeliveryUrl"`
	DisplayTitle *string `json:"DisplayTitle"`

	// DvBlSignalCompatibilityId Gets or sets the Dolby Vision bl signal compatibility id.
	DvBlSignalCompatibilityId *int32 `json:"DvBlSignalCompatibilityId"`

	// DvLevel Gets or sets the Dolby Vision level.
	DvLevel *int32 `json:"DvLevel"`

	// DvProfile Gets or sets the Dolby Vision profile.
	DvProfile *int32 `json:"DvProfile"`

	// DvVersionMajor Gets or sets the Dolby Vision version major.
	DvVersionMajor *int32 `json:"DvVersionMajor"`

	// DvVersionMinor Gets or sets the Dolby Vision version minor.
	DvVersionMinor *int32 `json:"DvVersionMinor"`

	// ElPresentFlag Gets or sets the Dolby Vision el present flag.
	ElPresentFlag *int32 `json:"ElPresentFlag"`

	// Height Gets or sets the height.
	Height *int32 `json:"Height"`

	// Index Gets or sets the index.
	Index *int32 `json:"Index,omitempty"`
	IsAVC *bool  `json:"IsAVC"`

	// IsAnamorphic Gets or sets whether this instance is anamorphic.
	IsAnamorphic *bool `json:"IsAnamorphic"`

	// IsDefault Gets or sets a value indicating whether this instance is default.
	IsDefault *bool `json:"IsDefault,omitempty"`

	// IsExternal Gets or sets a value indicating whether this instance is external.
	IsExternal *bool `json:"IsExternal,omitempty"`

	// IsExternalUrl Gets or sets a value indicating whether this instance is external URL.
	IsExternalUrl *bool `json:"IsExternalUrl"`

	// IsForced Gets or sets a value indicating whether this instance is forced.
	IsForced *bool `json:"IsForced,omitempty"`

	// IsInterlaced Gets or sets a value indicating whether this instance is interlaced.
	IsInterlaced         *bool `json:"IsInterlaced,omitempty"`
	IsTextSubtitleStream *bool `json:"IsTextSubtitleStream,omitempty"`

	// Language Gets or sets the language.
	Language *string `json:"Language"`

	// Level Gets or sets the level.
	Level              *float64 `json:"Level"`
	LocalizedDefault   *string  `json:"LocalizedDefault"`
	LocalizedExternal  *string  `json:"LocalizedExternal"`
	LocalizedForced    *string  `json:"LocalizedForced"`
	LocalizedUndefined *string  `json:"LocalizedUndefined"`
	NalLengthSize      *string  `json:"NalLengthSize"`

	// PacketLength Gets or sets the length of the packet.
	PacketLength *int32 `json:"PacketLength"`

	// Path Gets or sets the filename.
	Path *string `json:"Path"`

	// PixelFormat Gets or sets the pixel format.
	PixelFormat *string `json:"PixelFormat"`

	// Profile Gets or sets the profile.
	Profile *string `json:"Profile"`

	// RealFrameRate Gets or sets the real frame rate.
	RealFrameRate *float32 `json:"RealFrameRate"`

	// RefFrames Gets or sets the reference frames.
	RefFrames *int32 `json:"RefFrames"`

	// RpuPresentFlag Gets or sets the Dolby Vision rpu present flag.
	RpuPresentFlag *int32 `json:"RpuPresentFlag"`

	// SampleRate Gets or sets the sample rate.
	SampleRate *int32 `json:"SampleRate"`

	// Score Gets or sets the score.
	Score *int32 `json:"Score"`

	// SupportsExternalStream Gets or sets a value indicating whether [supports external stream].
	SupportsExternalStream *bool `json:"SupportsExternalStream,omitempty"`

	// TimeBase Gets or sets the time base.
	TimeBase *string `json:"TimeBase"`

	// Title Gets or sets the title.
	Title *string `json:"Title"`

	// Type Gets or sets the type.
	Type *MediaStreamType `json:"Type,omitempty"`

	// VideoDoViTitle Gets the video dovi title.
	VideoDoViTitle *string `json:"VideoDoViTitle"`

	// VideoRange Gets the video range.
	VideoRange *string `json:"VideoRange"`

	// VideoRangeType Gets the video range type.
	VideoRangeType *string `json:"VideoRangeType"`

	// Width Gets or sets the width.
	Width *int32 `json:"Width"`
}

// MediaStreamType Enum MediaStreamType.
type MediaStreamType string

// MediaUpdateInfoDto Media Update Info Dto.
type MediaUpdateInfoDto struct {
	// Updates Gets or sets the list of updates.
	Updates *[]MediaUpdateInfoPathDto `json:"Updates,omitempty"`
}

// MediaUpdateInfoPathDto The media update info path.
type MediaUpdateInfoPathDto struct {
	// Path Gets or sets media path.
	Path *string `json:"Path"`

	// UpdateType Gets or sets media update type.
	// Created, Modified, Deleted.
	UpdateType *string `json:"UpdateType"`
}

// MediaUrl defines model for MediaUrl.
type MediaUrl struct {
	Name *string `json:"Name"`
	Url  *string `json:"Url"`
}

// MessageCommand defines model for MessageCommand.
type MessageCommand struct {
	Header    *string `json:"Header"`
	Text      string  `json:"Text"`
	TimeoutMs *int64  `json:"TimeoutMs"`
}

// MetadataEditorInfo defines model for MetadataEditorInfo.
type MetadataEditorInfo struct {
	ContentType           *string           `json:"ContentType"`
	ContentTypeOptions    *[]NameValuePair  `json:"ContentTypeOptions,omitempty"`
	Countries             *[]CountryInfo    `json:"Countries,omitempty"`
	Cultures              *[]CultureDto     `json:"Cultures,omitempty"`
	ExternalIdInfos       *[]ExternalIdInfo `json:"ExternalIdInfos,omitempty"`
	ParentalRatingOptions *[]ParentalRating `json:"ParentalRatingOptions,omitempty"`
}

// MetadataField Enum MetadataFields.
type MetadataField string

// MetadataOptions Class MetadataOptions.
type MetadataOptions struct {
	DisabledImageFetchers    *[]string `json:"DisabledImageFetchers"`
	DisabledMetadataFetchers *[]string `json:"DisabledMetadataFetchers"`
	DisabledMetadataSavers   *[]string `json:"DisabledMetadataSavers"`
	ImageFetcherOrder        *[]string `json:"ImageFetcherOrder"`
	ItemType                 *string   `json:"ItemType"`
	LocalMetadataReaderOrder *[]string `json:"LocalMetadataReaderOrder"`
	MetadataFetcherOrder     *[]string `json:"MetadataFetcherOrder"`
}

// MetadataRefreshMode defines model for MetadataRefreshMode.
type MetadataRefreshMode string

// MovePlaylistItemRequestDto Class MovePlaylistItemRequestDto.
type MovePlaylistItemRequestDto struct {
	// NewIndex Gets or sets the new position.
	NewIndex *int32 `json:"NewIndex,omitempty"`

	// PlaylistItemId Gets or sets the playlist identifier of the item.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`
}

// MovieInfo defines model for MovieInfo.
type MovieInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// MovieInfoRemoteSearchQuery defines model for MovieInfoRemoteSearchQuery.
type MovieInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *MovieInfo          `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// MusicVideoInfo defines model for MusicVideoInfo.
type MusicVideoInfo struct {
	Artists     *[]string `json:"Artists"`
	IndexNumber *int32    `json:"IndexNumber"`
	IsAutomated *bool     `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// MusicVideoInfoRemoteSearchQuery defines model for MusicVideoInfoRemoteSearchQuery.
type MusicVideoInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *MusicVideoInfo     `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// NameGuidPair defines model for NameGuidPair.
type NameGuidPair struct {
	Id   *openapi_types.UUID `json:"Id,omitempty"`
	Name *string             `json:"Name"`
}

// NameIdPair defines model for NameIdPair.
type NameIdPair struct {
	// Id Gets or sets the identifier.
	Id *string `json:"Id"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`
}

// NameValuePair defines model for NameValuePair.
type NameValuePair struct {
	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Value Gets or sets the value.
	Value *string `json:"Value"`
}

// NewGroupRequestDto Class NewGroupRequestDto.
type NewGroupRequestDto struct {
	// GroupName Gets or sets the group name.
	GroupName *string `json:"GroupName,omitempty"`
}

// NextItemRequestDto Class NextItemRequestDto.
type NextItemRequestDto struct {
	// PlaylistItemId Gets or sets the playing item identifier.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`
}

// NotificationDto The notification DTO.
type NotificationDto struct {
	// Date Gets or sets the notification date.
	Date *time.Time `json:"Date,omitempty"`

	// Description Gets or sets the notification's description. Defaults to an empty string.
	Description *string `json:"Description,omitempty"`

	// Id Gets or sets the notification ID. Defaults to an empty string.
	Id *string `json:"Id,omitempty"`

	// IsRead Gets or sets a value indicating whether the notification has been read. Defaults to false.
	IsRead *bool `json:"IsRead,omitempty"`

	// Level Gets or sets the notification level.
	Level *NotificationLevel `json:"Level,omitempty"`

	// Name Gets or sets the notification's name. Defaults to an empty string.
	Name *string `json:"Name,omitempty"`

	// Url Gets or sets the notification's URL. Defaults to an empty string.
	Url *string `json:"Url,omitempty"`

	// UserId Gets or sets the notification's user ID. Defaults to an empty string.
	UserId *string `json:"UserId,omitempty"`
}

// NotificationLevel defines model for NotificationLevel.
type NotificationLevel string

// NotificationResultDto A list of notifications with the total record count for pagination.
type NotificationResultDto struct {
	// Notifications Gets or sets the current page of notifications.
	Notifications *[]NotificationDto `json:"Notifications,omitempty"`

	// TotalRecordCount Gets or sets the total number of notifications.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// NotificationTypeInfo defines model for NotificationTypeInfo.
type NotificationTypeInfo struct {
	Category           *string `json:"Category"`
	Enabled            *bool   `json:"Enabled,omitempty"`
	IsBasedOnUserEvent *bool   `json:"IsBasedOnUserEvent,omitempty"`
	Name               *string `json:"Name"`
	Type               *string `json:"Type"`
}

// NotificationsSummaryDto The notification summary DTO.
type NotificationsSummaryDto struct {
	// MaxUnreadNotificationLevel Gets or sets the maximum unread notification level.
	MaxUnreadNotificationLevel *NotificationLevel `json:"MaxUnreadNotificationLevel"`

	// UnreadCount Gets or sets the number of unread notifications.
	UnreadCount *int32 `json:"UnreadCount,omitempty"`
}

// OpenLiveStreamDto Open live stream dto.
type OpenLiveStreamDto struct {
	// AudioStreamIndex Gets or sets the audio stream index.
	AudioStreamIndex *int32 `json:"AudioStreamIndex"`

	// DeviceProfile A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
	// <br />
	// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
	// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
	// the device is able to direct play (without transcoding or remuxing),
	// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
	DeviceProfile *DeviceProfile `json:"DeviceProfile"`

	// DirectPlayProtocols Gets or sets the device play protocols.
	DirectPlayProtocols *[]MediaProtocol `json:"DirectPlayProtocols,omitempty"`

	// EnableDirectPlay Gets or sets a value indicating whether to enable direct play.
	EnableDirectPlay *bool `json:"EnableDirectPlay"`

	// EnableDirectStream Gets or sets a value indicating whether to enale direct stream.
	EnableDirectStream *bool `json:"EnableDirectStream"`

	// ItemId Gets or sets the item id.
	ItemId *openapi_types.UUID `json:"ItemId"`

	// MaxAudioChannels Gets or sets the max audio channels.
	MaxAudioChannels *int32 `json:"MaxAudioChannels"`

	// MaxStreamingBitrate Gets or sets the max streaming bitrate.
	MaxStreamingBitrate *int32 `json:"MaxStreamingBitrate"`

	// OpenToken Gets or sets the open token.
	OpenToken *string `json:"OpenToken"`

	// PlaySessionId Gets or sets the play session id.
	PlaySessionId *string `json:"PlaySessionId"`

	// StartTimeTicks Gets or sets the start time in ticks.
	StartTimeTicks *int64 `json:"StartTimeTicks"`

	// SubtitleStreamIndex Gets or sets the subtitle stream index.
	SubtitleStreamIndex *int32 `json:"SubtitleStreamIndex"`

	// UserId Gets or sets the user id.
	UserId *openapi_types.UUID `json:"UserId"`
}

// PackageInfo Class PackageInfo.
type PackageInfo struct {
	// Category Gets or sets the category.
	Category *string `json:"category,omitempty"`

	// Description Gets or sets a long description of the plugin containing features or helpful explanations.
	Description *string `json:"description,omitempty"`

	// Guid Gets or sets the guid of the assembly associated with this plugin.
	// This is used to identify the proper item for automatic updates.
	Guid *openapi_types.UUID `json:"guid,omitempty"`

	// ImageUrl Gets or sets the image url for the package.
	ImageUrl *string `json:"imageUrl"`

	// Name Gets or sets the name.
	Name *string `json:"name,omitempty"`

	// Overview Gets or sets a short overview of what the plugin does.
	Overview *string `json:"overview,omitempty"`

	// Owner Gets or sets the owner.
	Owner *string `json:"owner,omitempty"`

	// Versions Gets or sets the versions.
	Versions *[]VersionInfo `json:"versions,omitempty"`
}

// ParentalRating Class ParentalRating.
type ParentalRating struct {
	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Value Gets or sets the value.
	Value *int32 `json:"Value,omitempty"`
}

// PathSubstitution Defines the MediaBrowser.Model.Configuration.PathSubstitution.
type PathSubstitution struct {
	// From Gets or sets the value to substitute.
	From *string `json:"From,omitempty"`

	// To Gets or sets the value to substitution with.
	To *string `json:"To,omitempty"`
}

// PersonLookupInfo defines model for PersonLookupInfo.
type PersonLookupInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// PersonLookupInfoRemoteSearchQuery defines model for PersonLookupInfoRemoteSearchQuery.
type PersonLookupInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *PersonLookupInfo   `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// PinRedeemResult defines model for PinRedeemResult.
type PinRedeemResult struct {
	// Success Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success.
	Success *bool `json:"Success,omitempty"`

	// UsersReset Gets or sets the users reset.
	UsersReset *[]string `json:"UsersReset,omitempty"`
}

// PingRequestDto Class PingRequestDto.
type PingRequestDto struct {
	// Ping Gets or sets the ping time.
	Ping *int64 `json:"Ping,omitempty"`
}

// PlayAccess defines model for PlayAccess.
type PlayAccess string

// PlayCommand Enum PlayCommand.
type PlayCommand string

// PlayMethod defines model for PlayMethod.
type PlayMethod string

// PlayRequestDto Class PlayRequestDto.
type PlayRequestDto struct {
	// PlayingItemPosition Gets or sets the position of the playing item in the queue.
	PlayingItemPosition *int32 `json:"PlayingItemPosition,omitempty"`

	// PlayingQueue Gets or sets the playing queue.
	PlayingQueue *[]openapi_types.UUID `json:"PlayingQueue,omitempty"`

	// StartPositionTicks Gets or sets the start position ticks.
	StartPositionTicks *int64 `json:"StartPositionTicks,omitempty"`
}

// PlaybackErrorCode defines model for PlaybackErrorCode.
type PlaybackErrorCode string

// PlaybackInfoDto Plabyback info dto.
type PlaybackInfoDto struct {
	// AllowAudioStreamCopy Gets or sets a value indicating whether to allow audio stream copy.
	AllowAudioStreamCopy *bool `json:"AllowAudioStreamCopy"`

	// AllowVideoStreamCopy Gets or sets a value indicating whether to enable video stream copy.
	AllowVideoStreamCopy *bool `json:"AllowVideoStreamCopy"`

	// AudioStreamIndex Gets or sets the audio stream index.
	AudioStreamIndex *int32 `json:"AudioStreamIndex"`

	// AutoOpenLiveStream Gets or sets a value indicating whether to auto open the live stream.
	AutoOpenLiveStream *bool `json:"AutoOpenLiveStream"`

	// DeviceProfile A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
	// <br />
	// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
	// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
	// the device is able to direct play (without transcoding or remuxing),
	// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
	DeviceProfile *DeviceProfile `json:"DeviceProfile"`

	// EnableDirectPlay Gets or sets a value indicating whether to enable direct play.
	EnableDirectPlay *bool `json:"EnableDirectPlay"`

	// EnableDirectStream Gets or sets a value indicating whether to enable direct stream.
	EnableDirectStream *bool `json:"EnableDirectStream"`

	// EnableTranscoding Gets or sets a value indicating whether to enable transcoding.
	EnableTranscoding *bool `json:"EnableTranscoding"`

	// LiveStreamId Gets or sets the live stream id.
	LiveStreamId *string `json:"LiveStreamId"`

	// MaxAudioChannels Gets or sets the max audio channels.
	MaxAudioChannels *int32 `json:"MaxAudioChannels"`

	// MaxStreamingBitrate Gets or sets the max streaming bitrate.
	MaxStreamingBitrate *int32 `json:"MaxStreamingBitrate"`

	// MediaSourceId Gets or sets the media source id.
	MediaSourceId *string `json:"MediaSourceId"`

	// StartTimeTicks Gets or sets the start time in ticks.
	StartTimeTicks *int64 `json:"StartTimeTicks"`

	// SubtitleStreamIndex Gets or sets the subtitle stream index.
	SubtitleStreamIndex *int32 `json:"SubtitleStreamIndex"`

	// UserId Gets or sets the playback userId.
	UserId *openapi_types.UUID `json:"UserId"`
}

// PlaybackInfoResponse Class PlaybackInfoResponse.
type PlaybackInfoResponse struct {
	// ErrorCode Gets or sets the error code.
	ErrorCode *PlaybackErrorCode `json:"ErrorCode"`

	// MediaSources Gets or sets the media sources.
	MediaSources *[]MediaSourceInfo `json:"MediaSources,omitempty"`

	// PlaySessionId Gets or sets the play session identifier.
	PlaySessionId *string `json:"PlaySessionId"`
}

// PlaybackProgressInfo Class PlaybackProgressInfo.
type PlaybackProgressInfo struct {
	AspectRatio *string `json:"AspectRatio"`

	// AudioStreamIndex Gets or sets the index of the audio stream.
	AudioStreamIndex *int32 `json:"AudioStreamIndex"`
	Brightness       *int32 `json:"Brightness"`

	// CanSeek Gets or sets a value indicating whether this instance can seek.
	CanSeek *bool `json:"CanSeek,omitempty"`

	// IsMuted Gets or sets a value indicating whether this instance is muted.
	IsMuted *bool `json:"IsMuted,omitempty"`

	// IsPaused Gets or sets a value indicating whether this instance is paused.
	IsPaused *bool `json:"IsPaused,omitempty"`

	// Item Gets or sets the item.
	Item *BaseItemDto `json:"Item"`

	// ItemId Gets or sets the item identifier.
	ItemId *openapi_types.UUID `json:"ItemId,omitempty"`

	// LiveStreamId Gets or sets the live stream identifier.
	LiveStreamId *string `json:"LiveStreamId"`

	// MediaSourceId Gets or sets the media version identifier.
	MediaSourceId   *string      `json:"MediaSourceId"`
	NowPlayingQueue *[]QueueItem `json:"NowPlayingQueue"`

	// PlayMethod Gets or sets the play method.
	PlayMethod *PlayMethod `json:"PlayMethod,omitempty"`

	// PlaySessionId Gets or sets the play session identifier.
	PlaySessionId          *string `json:"PlaySessionId"`
	PlaybackStartTimeTicks *int64  `json:"PlaybackStartTimeTicks"`
	PlaylistItemId         *string `json:"PlaylistItemId"`

	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks"`

	// RepeatMode Gets or sets the repeat mode.
	RepeatMode *RepeatMode `json:"RepeatMode,omitempty"`

	// SessionId Gets or sets the session id.
	SessionId *string `json:"SessionId"`

	// SubtitleStreamIndex Gets or sets the index of the subtitle stream.
	SubtitleStreamIndex *int32 `json:"SubtitleStreamIndex"`

	// VolumeLevel Gets or sets the volume level.
	VolumeLevel *int32 `json:"VolumeLevel"`
}

// PlaybackStartInfo Class PlaybackStartInfo.
type PlaybackStartInfo struct {
	AspectRatio *string `json:"AspectRatio"`

	// AudioStreamIndex Gets or sets the index of the audio stream.
	AudioStreamIndex *int32 `json:"AudioStreamIndex"`
	Brightness       *int32 `json:"Brightness"`

	// CanSeek Gets or sets a value indicating whether this instance can seek.
	CanSeek *bool `json:"CanSeek,omitempty"`

	// IsMuted Gets or sets a value indicating whether this instance is muted.
	IsMuted *bool `json:"IsMuted,omitempty"`

	// IsPaused Gets or sets a value indicating whether this instance is paused.
	IsPaused *bool `json:"IsPaused,omitempty"`

	// Item Gets or sets the item.
	Item *BaseItemDto `json:"Item"`

	// ItemId Gets or sets the item identifier.
	ItemId *openapi_types.UUID `json:"ItemId,omitempty"`

	// LiveStreamId Gets or sets the live stream identifier.
	LiveStreamId *string `json:"LiveStreamId"`

	// MediaSourceId Gets or sets the media version identifier.
	MediaSourceId   *string      `json:"MediaSourceId"`
	NowPlayingQueue *[]QueueItem `json:"NowPlayingQueue"`

	// PlayMethod Gets or sets the play method.
	PlayMethod *PlayMethod `json:"PlayMethod,omitempty"`

	// PlaySessionId Gets or sets the play session identifier.
	PlaySessionId          *string `json:"PlaySessionId"`
	PlaybackStartTimeTicks *int64  `json:"PlaybackStartTimeTicks"`
	PlaylistItemId         *string `json:"PlaylistItemId"`

	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks"`

	// RepeatMode Gets or sets the repeat mode.
	RepeatMode *RepeatMode `json:"RepeatMode,omitempty"`

	// SessionId Gets or sets the session id.
	SessionId *string `json:"SessionId"`

	// SubtitleStreamIndex Gets or sets the index of the subtitle stream.
	SubtitleStreamIndex *int32 `json:"SubtitleStreamIndex"`

	// VolumeLevel Gets or sets the volume level.
	VolumeLevel *int32 `json:"VolumeLevel"`
}

// PlaybackStopInfo Class PlaybackStopInfo.
type PlaybackStopInfo struct {
	// Failed Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed.
	Failed *bool `json:"Failed,omitempty"`

	// Item Gets or sets the item.
	Item *BaseItemDto `json:"Item"`

	// ItemId Gets or sets the item identifier.
	ItemId *openapi_types.UUID `json:"ItemId,omitempty"`

	// LiveStreamId Gets or sets the live stream identifier.
	LiveStreamId *string `json:"LiveStreamId"`

	// MediaSourceId Gets or sets the media version identifier.
	MediaSourceId   *string      `json:"MediaSourceId"`
	NextMediaType   *string      `json:"NextMediaType"`
	NowPlayingQueue *[]QueueItem `json:"NowPlayingQueue"`

	// PlaySessionId Gets or sets the play session identifier.
	PlaySessionId  *string `json:"PlaySessionId"`
	PlaylistItemId *string `json:"PlaylistItemId"`

	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks"`

	// SessionId Gets or sets the session id.
	SessionId *string `json:"SessionId"`
}

// PlayerStateInfo defines model for PlayerStateInfo.
type PlayerStateInfo struct {
	// AudioStreamIndex Gets or sets the index of the now playing audio stream.
	AudioStreamIndex *int32 `json:"AudioStreamIndex"`

	// CanSeek Gets or sets a value indicating whether this instance can seek.
	CanSeek *bool `json:"CanSeek,omitempty"`

	// IsMuted Gets or sets a value indicating whether this instance is muted.
	IsMuted *bool `json:"IsMuted,omitempty"`

	// IsPaused Gets or sets a value indicating whether this instance is paused.
	IsPaused *bool `json:"IsPaused,omitempty"`

	// LiveStreamId Gets or sets the now playing live stream identifier.
	LiveStreamId *string `json:"LiveStreamId"`

	// MediaSourceId Gets or sets the now playing media version identifier.
	MediaSourceId *string `json:"MediaSourceId"`

	// PlayMethod Gets or sets the play method.
	PlayMethod *PlayMethod `json:"PlayMethod"`

	// PositionTicks Gets or sets the now playing position ticks.
	PositionTicks *int64 `json:"PositionTicks"`

	// RepeatMode Gets or sets the repeat mode.
	RepeatMode *RepeatMode `json:"RepeatMode,omitempty"`

	// SubtitleStreamIndex Gets or sets the index of the now playing subtitle stream.
	SubtitleStreamIndex *int32 `json:"SubtitleStreamIndex"`

	// VolumeLevel Gets or sets the volume level.
	VolumeLevel *int32 `json:"VolumeLevel"`
}

// PlaylistCreationResult defines model for PlaylistCreationResult.
type PlaylistCreationResult struct {
	Id *string `json:"Id,omitempty"`
}

// PlaystateCommand Enum PlaystateCommand.
type PlaystateCommand string

// PluginInfo This is a serializable stub class that is used by the api to provide information about installed plugins.
type PluginInfo struct {
	// CanUninstall Gets or sets a value indicating whether the plugin can be uninstalled.
	CanUninstall *bool `json:"CanUninstall,omitempty"`

	// ConfigurationFileName Gets or sets the name of the configuration file.
	ConfigurationFileName *string `json:"ConfigurationFileName"`

	// Description Gets or sets the description.
	Description *string `json:"Description,omitempty"`

	// HasImage Gets or sets a value indicating whether this plugin has a valid image.
	HasImage *bool `json:"HasImage,omitempty"`

	// Id Gets or sets the unique id.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name,omitempty"`

	// Status Gets or sets a value indicating the status of the plugin.
	Status *PluginStatus `json:"Status,omitempty"`

	// Version Gets or sets the version.
	Version *string `json:"Version,omitempty"`
}

// PluginStatus Plugin load status.
type PluginStatus string

// PreviousItemRequestDto Class PreviousItemRequestDto.
type PreviousItemRequestDto struct {
	// PlaylistItemId Gets or sets the playing item identifier.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`
}

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	Detail               *string                `json:"detail"`
	Instance             *string                `json:"instance"`
	Status               *int32                 `json:"status"`
	Title                *string                `json:"title"`
	Type                 *string                `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ProfileCondition defines model for ProfileCondition.
type ProfileCondition struct {
	Condition  *ProfileConditionType  `json:"Condition,omitempty"`
	IsRequired *bool                  `json:"IsRequired,omitempty"`
	Property   *ProfileConditionValue `json:"Property,omitempty"`
	Value      *string                `json:"Value"`
}

// ProfileConditionType defines model for ProfileConditionType.
type ProfileConditionType string

// ProfileConditionValue defines model for ProfileConditionValue.
type ProfileConditionValue string

// ProgramAudio defines model for ProgramAudio.
type ProgramAudio string

// PublicSystemInfo defines model for PublicSystemInfo.
type PublicSystemInfo struct {
	// Id Gets or sets the id.
	Id *string `json:"Id"`

	// LocalAddress Gets or sets the local address.
	LocalAddress *string `json:"LocalAddress"`

	// OperatingSystem Gets or sets the operating system.
	OperatingSystem *string `json:"OperatingSystem"`

	// ProductName Gets or sets the product name. This is the AssemblyProduct name.
	ProductName *string `json:"ProductName"`

	// ServerName Gets or sets the name of the server.
	ServerName *string `json:"ServerName"`

	// StartupWizardCompleted Gets or sets a value indicating whether the startup wizard is completed.
	StartupWizardCompleted *bool `json:"StartupWizardCompleted"`

	// Version Gets or sets the server version.
	Version *string `json:"Version"`
}

// QueryFilters defines model for QueryFilters.
type QueryFilters struct {
	Genres *[]NameGuidPair `json:"Genres"`
	Tags   *[]string       `json:"Tags"`
}

// QueryFiltersLegacy defines model for QueryFiltersLegacy.
type QueryFiltersLegacy struct {
	Genres          *[]string `json:"Genres"`
	OfficialRatings *[]string `json:"OfficialRatings"`
	Tags            *[]string `json:"Tags"`
	Years           *[]int32  `json:"Years"`
}

// QueueItem defines model for QueueItem.
type QueueItem struct {
	Id             *openapi_types.UUID `json:"Id,omitempty"`
	PlaylistItemId *string             `json:"PlaylistItemId"`
}

// QueueRequestDto Class QueueRequestDto.
type QueueRequestDto struct {
	// ItemIds Gets or sets the items to enqueue.
	ItemIds *[]openapi_types.UUID `json:"ItemIds,omitempty"`

	// Mode Enum GroupQueueMode.
	Mode *GroupQueueMode `json:"Mode,omitempty"`
}

// QuickConnectDto The quick connect request body.
type QuickConnectDto struct {
	// Secret Gets or sets the quick connect secret.
	Secret string `json:"Secret"`
}

// QuickConnectResult Stores the state of an quick connect request.
type QuickConnectResult struct {
	// AppName Gets the requesting app name.
	AppName *string `json:"AppName,omitempty"`

	// AppVersion Gets the requesting app version.
	AppVersion *string `json:"AppVersion,omitempty"`

	// Authenticated Gets or sets a value indicating whether this request is authorized.
	Authenticated *bool `json:"Authenticated,omitempty"`

	// Code Gets the user facing code used so the user can quickly differentiate this request from others.
	Code *string `json:"Code,omitempty"`

	// DateAdded Gets or sets the DateTime that this request was created.
	DateAdded *time.Time `json:"DateAdded,omitempty"`

	// DeviceId Gets the requesting device id.
	DeviceId *string `json:"DeviceId,omitempty"`

	// DeviceName Gets the requesting device name.
	DeviceName *string `json:"DeviceName,omitempty"`

	// Secret Gets the secret value used to uniquely identify this request. Can be used to retrieve authentication information.
	Secret *string `json:"Secret,omitempty"`
}

// RatingType defines model for RatingType.
type RatingType string

// ReadyRequestDto Class ReadyRequest.
type ReadyRequestDto struct {
	// IsPlaying Gets or sets a value indicating whether the client playback is unpaused.
	IsPlaying *bool `json:"IsPlaying,omitempty"`

	// PlaylistItemId Gets or sets the playlist item identifier of the playing item.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`

	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks,omitempty"`

	// When Gets or sets when the request has been made by the client.
	When *time.Time `json:"When,omitempty"`
}

// RecommendationDto defines model for RecommendationDto.
type RecommendationDto struct {
	BaselineItemName   *string             `json:"BaselineItemName"`
	CategoryId         *openapi_types.UUID `json:"CategoryId,omitempty"`
	Items              *[]BaseItemDto      `json:"Items"`
	RecommendationType *RecommendationType `json:"RecommendationType,omitempty"`
}

// RecommendationType defines model for RecommendationType.
type RecommendationType string

// RecordingStatus defines model for RecordingStatus.
type RecordingStatus string

// RemoteImageInfo Class RemoteImageInfo.
type RemoteImageInfo struct {
	// CommunityRating Gets or sets the community rating.
	CommunityRating *float64 `json:"CommunityRating"`

	// Height Gets or sets the height.
	Height *int32 `json:"Height"`

	// Language Gets or sets the language.
	Language *string `json:"Language"`

	// ProviderName Gets or sets the name of the provider.
	ProviderName *string `json:"ProviderName"`

	// RatingType Gets or sets the type of the rating.
	RatingType *RatingType `json:"RatingType,omitempty"`

	// ThumbnailUrl Gets or sets a url used for previewing a smaller version.
	ThumbnailUrl *string `json:"ThumbnailUrl"`

	// Type Gets or sets the type.
	Type *ImageType `json:"Type,omitempty"`

	// Url Gets or sets the URL.
	Url *string `json:"Url"`

	// VoteCount Gets or sets the vote count.
	VoteCount *int32 `json:"VoteCount"`

	// Width Gets or sets the width.
	Width *int32 `json:"Width"`
}

// RemoteImageResult Class RemoteImageResult.
type RemoteImageResult struct {
	// Images Gets or sets the images.
	Images *[]RemoteImageInfo `json:"Images"`

	// Providers Gets or sets the providers.
	Providers *[]string `json:"Providers"`

	// TotalRecordCount Gets or sets the total record count.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// RemoteSearchResult defines model for RemoteSearchResult.
type RemoteSearchResult struct {
	AlbumArtist    *RemoteSearchResult   `json:"AlbumArtist"`
	Artists        *[]RemoteSearchResult `json:"Artists"`
	ImageUrl       *string               `json:"ImageUrl"`
	IndexNumber    *int32                `json:"IndexNumber"`
	IndexNumberEnd *int32                `json:"IndexNumberEnd"`

	// Name Gets or sets the name.
	Name              *string    `json:"Name"`
	Overview          *string    `json:"Overview"`
	ParentIndexNumber *int32     `json:"ParentIndexNumber"`
	PremiereDate      *time.Time `json:"PremiereDate"`

	// ProductionYear Gets or sets the year.
	ProductionYear *int32 `json:"ProductionYear"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds        *map[string]*string `json:"ProviderIds"`
	SearchProviderName *string             `json:"SearchProviderName"`
}

// RemoteSubtitleInfo defines model for RemoteSubtitleInfo.
type RemoteSubtitleInfo struct {
	Author                     *string    `json:"Author"`
	Comment                    *string    `json:"Comment"`
	CommunityRating            *float32   `json:"CommunityRating"`
	DateCreated                *time.Time `json:"DateCreated"`
	DownloadCount              *int32     `json:"DownloadCount"`
	Format                     *string    `json:"Format"`
	Id                         *string    `json:"Id"`
	IsHashMatch                *bool      `json:"IsHashMatch"`
	Name                       *string    `json:"Name"`
	ProviderName               *string    `json:"ProviderName"`
	ThreeLetterISOLanguageName *string    `json:"ThreeLetterISOLanguageName"`
}

// RemoveFromPlaylistRequestDto Class RemoveFromPlaylistRequestDto.
type RemoveFromPlaylistRequestDto struct {
	// ClearPlayingItem Gets or sets a value indicating whether the playing item should be removed as well. Used only when clearing the playlist.
	ClearPlayingItem *bool `json:"ClearPlayingItem,omitempty"`

	// ClearPlaylist Gets or sets a value indicating whether the entire playlist should be cleared.
	ClearPlaylist *bool `json:"ClearPlaylist,omitempty"`

	// PlaylistItemIds Gets or sets the playlist identifiers ot the items. Ignored when clearing the playlist.
	PlaylistItemIds *[]openapi_types.UUID `json:"PlaylistItemIds,omitempty"`
}

// RepeatMode defines model for RepeatMode.
type RepeatMode string

// ReportDisplayType defines model for ReportDisplayType.
type ReportDisplayType string

// ReportExportType defines model for ReportExportType.
type ReportExportType string

// ReportFieldType defines model for ReportFieldType.
type ReportFieldType string

// ReportGroup defines model for ReportGroup.
type ReportGroup struct {
	Name *string      `json:"Name,omitempty"`
	Rows *[]ReportRow `json:"Rows,omitempty"`
}

// ReportHeader defines model for ReportHeader.
type ReportHeader struct {
	CanGroup        *bool              `json:"CanGroup,omitempty"`
	DisplayType     *ReportDisplayType `json:"DisplayType,omitempty"`
	FieldName       *HeaderMetadata    `json:"FieldName,omitempty"`
	HeaderFieldType *ReportFieldType   `json:"HeaderFieldType,omitempty"`
	ItemViewType    *ItemViewType      `json:"ItemViewType,omitempty"`
	Name            *string            `json:"Name"`
	ShowHeaderLabel *bool              `json:"ShowHeaderLabel,omitempty"`
	SortField       *string            `json:"SortField"`
	Type            *string            `json:"Type"`
	Visible         *bool              `json:"Visible,omitempty"`
}

// ReportIncludeItemTypes defines model for ReportIncludeItemTypes.
type ReportIncludeItemTypes string

// ReportItem defines model for ReportItem.
type ReportItem struct {
	CustomTag *string `json:"CustomTag"`
	Id        *string `json:"Id"`
	Image     *string `json:"Image"`
	Name      *string `json:"Name"`
}

// ReportResult defines model for ReportResult.
type ReportResult struct {
	Groups           *[]ReportGroup  `json:"Groups"`
	Headers          *[]ReportHeader `json:"Headers"`
	IsGrouped        *bool           `json:"IsGrouped,omitempty"`
	Rows             *[]ReportRow    `json:"Rows"`
	TotalRecordCount *int32          `json:"TotalRecordCount,omitempty"`
}

// ReportRow defines model for ReportRow.
type ReportRow struct {
	Columns              *[]ReportItem           `json:"Columns"`
	HasEmbeddedImage     *bool                   `json:"HasEmbeddedImage,omitempty"`
	HasImageTagsBackdrop *bool                   `json:"HasImageTagsBackdrop,omitempty"`
	HasImageTagsLogo     *bool                   `json:"HasImageTagsLogo,omitempty"`
	HasImageTagsPrimary  *bool                   `json:"HasImageTagsPrimary,omitempty"`
	HasLocalTrailer      *bool                   `json:"HasLocalTrailer,omitempty"`
	HasLockData          *bool                   `json:"HasLockData,omitempty"`
	HasSpecials          *bool                   `json:"HasSpecials,omitempty"`
	HasSubtitles         *bool                   `json:"HasSubtitles,omitempty"`
	Id                   *string                 `json:"Id"`
	RowType              *ReportIncludeItemTypes `json:"RowType,omitempty"`
	UserId               *openapi_types.UUID     `json:"UserId,omitempty"`
}

// RepositoryInfo Class RepositoryInfo.
type RepositoryInfo struct {
	// Enabled Gets or sets a value indicating whether the repository is enabled.
	Enabled *bool `json:"Enabled,omitempty"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Url Gets or sets the URL.
	Url *string `json:"Url"`
}

// ResponseProfile defines model for ResponseProfile.
type ResponseProfile struct {
	AudioCodec *string             `json:"AudioCodec"`
	Conditions *[]ProfileCondition `json:"Conditions"`
	Container  *string             `json:"Container"`
	MimeType   *string             `json:"MimeType"`
	OrgPn      *string             `json:"OrgPn"`
	Type       *DlnaProfileType    `json:"Type,omitempty"`
	VideoCodec *string             `json:"VideoCodec"`
}

// ScrollDirection An enum representing the axis that should be scrolled.
type ScrollDirection string

// SearchHint Class SearchHintResult.
type SearchHint struct {
	// Album Gets or sets the album.
	Album *string `json:"Album"`

	// AlbumArtist Gets or sets the album artist.
	AlbumArtist *string             `json:"AlbumArtist"`
	AlbumId     *openapi_types.UUID `json:"AlbumId,omitempty"`

	// Artists Gets or sets the artists.
	Artists *[]string `json:"Artists"`

	// BackdropImageItemId Gets or sets the backdrop image item identifier.
	BackdropImageItemId *string `json:"BackdropImageItemId"`

	// BackdropImageTag Gets or sets the backdrop image tag.
	BackdropImageTag *string `json:"BackdropImageTag"`

	// ChannelId Gets or sets the channel identifier.
	ChannelId *openapi_types.UUID `json:"ChannelId,omitempty"`

	// ChannelName Gets or sets the name of the channel.
	ChannelName *string    `json:"ChannelName"`
	EndDate     *time.Time `json:"EndDate"`

	// EpisodeCount Gets or sets the episode count.
	EpisodeCount *int32              `json:"EpisodeCount"`
	Id           *openapi_types.UUID `json:"Id,omitempty"`

	// IndexNumber Gets or sets the index number.
	IndexNumber *int32 `json:"IndexNumber"`
	IsFolder    *bool  `json:"IsFolder"`

	// ItemId Gets or sets the item id.
	ItemId *openapi_types.UUID `json:"ItemId,omitempty"`

	// MatchedTerm Gets or sets the matched term.
	MatchedTerm *string `json:"MatchedTerm"`

	// MediaType Gets or sets the type of the media.
	MediaType *string `json:"MediaType"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// ParentIndexNumber Gets or sets the parent index number.
	ParentIndexNumber *int32 `json:"ParentIndexNumber"`

	// PrimaryImageAspectRatio Gets or sets the primary image aspect ratio.
	PrimaryImageAspectRatio *float64 `json:"PrimaryImageAspectRatio"`

	// PrimaryImageTag Gets or sets the image tag.
	PrimaryImageTag *string `json:"PrimaryImageTag"`

	// ProductionYear Gets or sets the production year.
	ProductionYear *int32 `json:"ProductionYear"`

	// RunTimeTicks Gets or sets the run time ticks.
	RunTimeTicks *int64 `json:"RunTimeTicks"`

	// Series Gets or sets the series.
	Series *string `json:"Series"`

	// SongCount Gets or sets the song count.
	SongCount *int32     `json:"SongCount"`
	StartDate *time.Time `json:"StartDate"`
	Status    *string    `json:"Status"`

	// ThumbImageItemId Gets or sets the thumb image item identifier.
	ThumbImageItemId *string `json:"ThumbImageItemId"`

	// ThumbImageTag Gets or sets the thumb image tag.
	ThumbImageTag *string `json:"ThumbImageTag"`

	// Type Gets or sets the type.
	Type *string `json:"Type"`
}

// SearchHintResult Class SearchHintResult.
type SearchHintResult struct {
	// SearchHints Gets the search hints.
	SearchHints *[]SearchHint `json:"SearchHints,omitempty"`

	// TotalRecordCount Gets the total record count.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// SeekRequestDto Class SeekRequestDto.
type SeekRequestDto struct {
	// PositionTicks Gets or sets the position ticks.
	PositionTicks *int64 `json:"PositionTicks,omitempty"`
}

// SeriesInfo defines model for SeriesInfo.
type SeriesInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// SeriesInfoRemoteSearchQuery defines model for SeriesInfoRemoteSearchQuery.
type SeriesInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *SeriesInfo         `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// SeriesStatus Enum SeriesStatus.
type SeriesStatus string

// SeriesTimerInfoDto Class SeriesTimerInfoDto.
type SeriesTimerInfoDto struct {
	// ChannelId Gets or sets the channel id of the recording.
	ChannelId *openapi_types.UUID `json:"ChannelId,omitempty"`

	// ChannelName Gets or sets the channel name of the recording.
	ChannelName            *string `json:"ChannelName"`
	ChannelPrimaryImageTag *string `json:"ChannelPrimaryImageTag"`

	// DayPattern Gets or sets the day pattern.
	DayPattern *DayPattern `json:"DayPattern"`

	// Days Gets or sets the days.
	Days *[]DayOfWeek `json:"Days"`

	// EndDate Gets or sets the end date of the recording, in UTC.
	EndDate *time.Time `json:"EndDate,omitempty"`

	// ExternalChannelId Gets or sets the external channel identifier.
	ExternalChannelId *string `json:"ExternalChannelId"`

	// ExternalId Gets or sets the external identifier.
	ExternalId *string `json:"ExternalId"`

	// ExternalProgramId Gets or sets the external program identifier.
	ExternalProgramId *string `json:"ExternalProgramId"`

	// Id Gets or sets the Id of the recording.
	Id *string `json:"Id"`

	// ImageTags Gets or sets the image tags.
	ImageTags *map[string]string `json:"ImageTags"`

	// IsPostPaddingRequired Gets or sets a value indicating whether this instance is post padding required.
	IsPostPaddingRequired *bool `json:"IsPostPaddingRequired,omitempty"`

	// IsPrePaddingRequired Gets or sets a value indicating whether this instance is pre padding required.
	IsPrePaddingRequired *bool      `json:"IsPrePaddingRequired,omitempty"`
	KeepUntil            *KeepUntil `json:"KeepUntil,omitempty"`
	KeepUpTo             *int32     `json:"KeepUpTo,omitempty"`

	// Name Gets or sets the name of the recording.
	Name *string `json:"Name"`

	// Overview Gets or sets the description of the recording.
	Overview *string `json:"Overview"`

	// ParentBackdropImageTags Gets or sets the parent backdrop image tags.
	ParentBackdropImageTags *[]string `json:"ParentBackdropImageTags"`

	// ParentBackdropItemId Gets or sets the Id of the Parent that has a backdrop if the item does not have one.
	ParentBackdropItemId *string `json:"ParentBackdropItemId"`

	// ParentPrimaryImageItemId Gets or sets the parent primary image item identifier.
	ParentPrimaryImageItemId *string `json:"ParentPrimaryImageItemId"`

	// ParentPrimaryImageTag Gets or sets the parent primary image tag.
	ParentPrimaryImageTag *string `json:"ParentPrimaryImageTag"`

	// ParentThumbImageTag Gets or sets the parent thumb image tag.
	ParentThumbImageTag *string `json:"ParentThumbImageTag"`

	// ParentThumbItemId Gets or sets the parent thumb item id.
	ParentThumbItemId *string `json:"ParentThumbItemId"`

	// PostPaddingSeconds Gets or sets the post padding seconds.
	PostPaddingSeconds *int32 `json:"PostPaddingSeconds,omitempty"`

	// PrePaddingSeconds Gets or sets the pre padding seconds.
	PrePaddingSeconds *int32 `json:"PrePaddingSeconds,omitempty"`

	// Priority Gets or sets the priority.
	Priority *int32 `json:"Priority,omitempty"`

	// ProgramId Gets or sets the program identifier.
	ProgramId *string `json:"ProgramId"`

	// RecordAnyChannel Gets or sets a value indicating whether [record any channel].
	RecordAnyChannel *bool `json:"RecordAnyChannel,omitempty"`

	// RecordAnyTime Gets or sets a value indicating whether [record any time].
	RecordAnyTime *bool `json:"RecordAnyTime,omitempty"`

	// RecordNewOnly Gets or sets a value indicating whether [record new only].
	RecordNewOnly *bool `json:"RecordNewOnly,omitempty"`

	// ServerId Gets or sets the server identifier.
	ServerId *string `json:"ServerId"`

	// ServiceName Gets or sets the name of the service.
	ServiceName           *string `json:"ServiceName"`
	SkipEpisodesInLibrary *bool   `json:"SkipEpisodesInLibrary,omitempty"`

	// StartDate Gets or sets the start date of the recording, in UTC.
	StartDate *time.Time `json:"StartDate,omitempty"`
	Type      *string    `json:"Type"`
}

// SeriesTimerInfoDtoQueryResult defines model for SeriesTimerInfoDtoQueryResult.
type SeriesTimerInfoDtoQueryResult struct {
	// Items Gets or sets the items.
	Items *[]SeriesTimerInfoDto `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// ServerConfiguration Represents the server configuration.
type ServerConfiguration struct {
	// ActivityLogRetentionDays Gets or sets the number of days we should retain activity logs.
	ActivityLogRetentionDays *int32 `json:"ActivityLogRetentionDays"`

	// AllowClientLogUpload Gets or sets a value indicating whether clients should be allowed to upload logs.
	AllowClientLogUpload *bool `json:"AllowClientLogUpload,omitempty"`

	// CachePath Gets or sets the cache path.
	CachePath    *string          `json:"CachePath"`
	CodecsUsed   *[]string        `json:"CodecsUsed,omitempty"`
	ContentTypes *[]NameValuePair `json:"ContentTypes,omitempty"`

	// CorsHosts Gets or sets the cors hosts.
	CorsHosts                        *[]string `json:"CorsHosts,omitempty"`
	DisableLiveTvChannelUserDataName *bool     `json:"DisableLiveTvChannelUserDataName,omitempty"`
	DisplaySpecialsWithinSeasons     *bool     `json:"DisplaySpecialsWithinSeasons,omitempty"`

	// EnableCaseSensitiveItemIds Gets or sets a value indicating whether [enable case sensitive item ids].
	EnableCaseSensitiveItemIds         *bool `json:"EnableCaseSensitiveItemIds,omitempty"`
	EnableExternalContentInSuggestions *bool `json:"EnableExternalContentInSuggestions,omitempty"`
	EnableFolderView                   *bool `json:"EnableFolderView,omitempty"`
	EnableGroupingIntoCollections      *bool `json:"EnableGroupingIntoCollections,omitempty"`

	// EnableMetrics Gets or sets a value indicating whether to enable prometheus metrics exporting.
	EnableMetrics                 *bool `json:"EnableMetrics,omitempty"`
	EnableNormalizedItemByNameIds *bool `json:"EnableNormalizedItemByNameIds,omitempty"`

	// EnableSlowResponseWarning Gets or sets a value indicating whether slow server responses should be logged as a warning.
	EnableSlowResponseWarning *bool  `json:"EnableSlowResponseWarning,omitempty"`
	ImageExtractionTimeoutMs  *int32 `json:"ImageExtractionTimeoutMs,omitempty"`

	// ImageSavingConvention Gets or sets the image saving convention.
	ImageSavingConvention *ImageSavingConvention `json:"ImageSavingConvention,omitempty"`

	// IsPortAuthorized Gets or sets a value indicating whether this instance is port authorized.
	IsPortAuthorized *bool `json:"IsPortAuthorized,omitempty"`

	// IsStartupWizardCompleted Gets or sets a value indicating whether this instance is first run.
	IsStartupWizardCompleted *bool `json:"IsStartupWizardCompleted,omitempty"`

	// LibraryMetadataRefreshConcurrency Gets or sets the how many metadata refreshes can run concurrently.
	LibraryMetadataRefreshConcurrency *int32 `json:"LibraryMetadataRefreshConcurrency,omitempty"`

	// LibraryMonitorDelay Gets or sets the delay in seconds that we will wait after a file system change to try and discover what has been added/removed
	// Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several
	// different directories and files.
	LibraryMonitorDelay *int32 `json:"LibraryMonitorDelay,omitempty"`

	// LibraryScanFanoutConcurrency Gets or sets the how the library scan fans out.
	LibraryScanFanoutConcurrency *int32 `json:"LibraryScanFanoutConcurrency,omitempty"`

	// LogFileRetentionDays Gets or sets the number of days we should retain log files.
	LogFileRetentionDays *int32 `json:"LogFileRetentionDays,omitempty"`

	// MaxAudiobookResume Gets or sets the remaining minutes of a book that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
	MaxAudiobookResume *int32 `json:"MaxAudiobookResume,omitempty"`

	// MaxResumePct Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
	MaxResumePct *int32 `json:"MaxResumePct,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string            `json:"MetadataCountryCode,omitempty"`
	MetadataNetworkPath *string            `json:"MetadataNetworkPath,omitempty"`
	MetadataOptions     *[]MetadataOptions `json:"MetadataOptions,omitempty"`

	// MetadataPath Gets or sets the metadata path.
	MetadataPath *string `json:"MetadataPath,omitempty"`

	// MinAudiobookResume Gets or sets the minimum minutes of a book that must be played in order for playstate to be updated.
	MinAudiobookResume *int32 `json:"MinAudiobookResume,omitempty"`

	// MinResumeDurationSeconds Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
	MinResumeDurationSeconds *int32 `json:"MinResumeDurationSeconds,omitempty"`

	// MinResumePct Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
	MinResumePct       *int32              `json:"MinResumePct,omitempty"`
	PathSubstitutions  *[]PathSubstitution `json:"PathSubstitutions,omitempty"`
	PluginRepositories *[]RepositoryInfo   `json:"PluginRepositories,omitempty"`

	// PreferredMetadataLanguage Gets or sets the preferred metadata language.
	PreferredMetadataLanguage *string `json:"PreferredMetadataLanguage,omitempty"`

	// PreviousVersion Gets or sets the last known version that was ran using the configuration.
	PreviousVersion *string `json:"PreviousVersion"`

	// PreviousVersionStr Gets or sets the stringified PreviousVersion to be stored/loaded,
	// because System.Version itself isn't xml-serializable.
	PreviousVersionStr *string `json:"PreviousVersionStr"`

	// QuickConnectAvailable Gets or sets a value indicating whether quick connect is available for use on this server.
	QuickConnectAvailable    *bool  `json:"QuickConnectAvailable,omitempty"`
	RemoteClientBitrateLimit *int32 `json:"RemoteClientBitrateLimit,omitempty"`

	// RemoveOldPlugins Gets or sets a value indicating whether older plugins should automatically be deleted from the plugin folder.
	RemoveOldPlugins                 *bool   `json:"RemoveOldPlugins,omitempty"`
	SaveMetadataHidden               *bool   `json:"SaveMetadataHidden,omitempty"`
	ServerName                       *string `json:"ServerName,omitempty"`
	SkipDeserializationForBasicTypes *bool   `json:"SkipDeserializationForBasicTypes,omitempty"`

	// SlowResponseThresholdMs Gets or sets the threshold for the slow response time warning in ms.
	SlowResponseThresholdMs *int64 `json:"SlowResponseThresholdMs,omitempty"`

	// SortRemoveCharacters Gets or sets characters to be removed from strings to create a sort name.
	SortRemoveCharacters *[]string `json:"SortRemoveCharacters,omitempty"`

	// SortRemoveWords Gets or sets words to be removed from strings to create a sort name.
	SortRemoveWords *[]string `json:"SortRemoveWords,omitempty"`

	// SortReplaceCharacters Gets or sets characters to be replaced with a ' ' in strings to create a sort name.
	SortReplaceCharacters *[]string `json:"SortReplaceCharacters,omitempty"`
	UICulture             *string   `json:"UICulture,omitempty"`
}

// SessionInfo Class SessionInfo.
type SessionInfo struct {
	AdditionalUsers *[]SessionUserInfo `json:"AdditionalUsers"`

	// ApplicationVersion Gets or sets the application version.
	ApplicationVersion *string             `json:"ApplicationVersion"`
	Capabilities       *ClientCapabilities `json:"Capabilities"`

	// Client Gets or sets the type of the client.
	Client *string `json:"Client"`

	// DeviceId Gets or sets the device id.
	DeviceId *string `json:"DeviceId"`

	// DeviceName Gets or sets the name of the device.
	DeviceName *string `json:"DeviceName"`

	// DeviceType Gets or sets the type of the device.
	DeviceType *string `json:"DeviceType"`

	// FullNowPlayingItem Class BaseItem.
	FullNowPlayingItem  *BaseItem `json:"FullNowPlayingItem"`
	HasCustomDeviceName *bool     `json:"HasCustomDeviceName,omitempty"`

	// Id Gets or sets the id.
	Id *string `json:"Id"`

	// IsActive Gets a value indicating whether this instance is active.
	IsActive *bool `json:"IsActive,omitempty"`

	// LastActivityDate Gets or sets the last activity date.
	LastActivityDate *time.Time `json:"LastActivityDate,omitempty"`

	// LastPlaybackCheckIn Gets or sets the last playback check in.
	LastPlaybackCheckIn *time.Time `json:"LastPlaybackCheckIn,omitempty"`

	// NowPlayingItem This is strictly used as a data transfer object from the api layer.
	// This holds information about a BaseItem in a format that is convenient for the client.
	NowPlayingItem           *BaseItemDto   `json:"NowPlayingItem"`
	NowPlayingQueue          *[]QueueItem   `json:"NowPlayingQueue"`
	NowPlayingQueueFullItems *[]BaseItemDto `json:"NowPlayingQueueFullItems"`

	// NowViewingItem This is strictly used as a data transfer object from the api layer.
	// This holds information about a BaseItem in a format that is convenient for the client.
	NowViewingItem *BaseItemDto     `json:"NowViewingItem"`
	PlayState      *PlayerStateInfo `json:"PlayState"`

	// PlayableMediaTypes Gets the playable media types.
	PlayableMediaTypes *[]string `json:"PlayableMediaTypes"`
	PlaylistItemId     *string   `json:"PlaylistItemId"`

	// RemoteEndPoint Gets or sets the remote end point.
	RemoteEndPoint *string `json:"RemoteEndPoint"`
	ServerId       *string `json:"ServerId"`

	// SupportedCommands Gets the supported commands.
	SupportedCommands     *[]GeneralCommandType `json:"SupportedCommands"`
	SupportsMediaControl  *bool                 `json:"SupportsMediaControl,omitempty"`
	SupportsRemoteControl *bool                 `json:"SupportsRemoteControl,omitempty"`
	TranscodingInfo       *TranscodingInfo      `json:"TranscodingInfo"`

	// UserId Gets or sets the user id.
	UserId *openapi_types.UUID `json:"UserId,omitempty"`

	// UserName Gets or sets the username.
	UserName            *string `json:"UserName"`
	UserPrimaryImageTag *string `json:"UserPrimaryImageTag"`
}

// SessionUserInfo Class SessionUserInfo.
type SessionUserInfo struct {
	// UserId Gets or sets the user identifier.
	UserId *openapi_types.UUID `json:"UserId,omitempty"`

	// UserName Gets or sets the name of the user.
	UserName *string `json:"UserName"`
}

// SetChannelMappingDto Set channel mapping dto.
type SetChannelMappingDto struct {
	// ProviderChannelId Gets or sets the provider channel id.
	ProviderChannelId string `json:"ProviderChannelId"`

	// ProviderId Gets or sets the provider id.
	ProviderId string `json:"ProviderId"`

	// TunerChannelId Gets or sets the tuner channel id.
	TunerChannelId string `json:"TunerChannelId"`
}

// SetPlaylistItemRequestDto Class SetPlaylistItemRequestDto.
type SetPlaylistItemRequestDto struct {
	// PlaylistItemId Gets or sets the playlist identifier of the playing item.
	PlaylistItemId *openapi_types.UUID `json:"PlaylistItemId,omitempty"`
}

// SetRepeatModeRequestDto Class SetRepeatModeRequestDto.
type SetRepeatModeRequestDto struct {
	// Mode Enum GroupRepeatMode.
	Mode *GroupRepeatMode `json:"Mode,omitempty"`
}

// SetShuffleModeRequestDto Class SetShuffleModeRequestDto.
type SetShuffleModeRequestDto struct {
	// Mode Enum GroupShuffleMode.
	Mode *GroupShuffleMode `json:"Mode,omitempty"`
}

// SongInfo defines model for SongInfo.
type SongInfo struct {
	Album        *string   `json:"Album"`
	AlbumArtists *[]string `json:"AlbumArtists"`
	Artists      *[]string `json:"Artists"`
	IndexNumber  *int32    `json:"IndexNumber"`
	IsAutomated  *bool     `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// SortOrder An enum representing the sorting order.
type SortOrder string

// SpecialViewOptionDto Special view option dto.
type SpecialViewOptionDto struct {
	// Id Gets or sets view option id.
	Id *string `json:"Id"`

	// Name Gets or sets view option name.
	Name *string `json:"Name"`
}

// StartupConfigurationDto The startup configuration DTO.
type StartupConfigurationDto struct {
	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// PreferredMetadataLanguage Gets or sets the preferred language for the metadata.
	PreferredMetadataLanguage *string `json:"PreferredMetadataLanguage"`

	// UICulture Gets or sets UI language culture.
	UICulture *string `json:"UICulture"`
}

// StartupRemoteAccessDto Startup remote access dto.
type StartupRemoteAccessDto struct {
	// EnableAutomaticPortMapping Gets or sets a value indicating whether enable automatic port mapping.
	EnableAutomaticPortMapping bool `json:"EnableAutomaticPortMapping"`

	// EnableRemoteAccess Gets or sets a value indicating whether enable remote access.
	EnableRemoteAccess bool `json:"EnableRemoteAccess"`
}

// StartupUserDto The startup user DTO.
type StartupUserDto struct {
	// Name Gets or sets the username.
	Name *string `json:"Name"`

	// Password Gets or sets the user's password.
	Password *string `json:"Password"`
}

// SubtitleDeliveryMethod Delivery method to use during playback of a specific subtitle format.
type SubtitleDeliveryMethod string

// SubtitlePlaybackMode An enum representing a subtitle playback mode.
type SubtitlePlaybackMode string

// SubtitleProfile defines model for SubtitleProfile.
type SubtitleProfile struct {
	Container *string `json:"Container"`
	DidlMode  *string `json:"DidlMode"`
	Format    *string `json:"Format"`
	Language  *string `json:"Language"`

	// Method Delivery method to use during playback of a specific subtitle format.
	Method *SubtitleDeliveryMethod `json:"Method,omitempty"`
}

// SyncPlayUserAccessType Enum SyncPlayUserAccessType.
type SyncPlayUserAccessType string

// SystemInfo Class SystemInfo.
type SystemInfo struct {
	// CachePath Gets or sets the cache path.
	CachePath           *string `json:"CachePath"`
	CanLaunchWebBrowser *bool   `json:"CanLaunchWebBrowser,omitempty"`

	// CanSelfRestart Gets or sets a value indicating whether this instance can self restart.
	CanSelfRestart *bool `json:"CanSelfRestart,omitempty"`

	// CompletedInstallations Gets or sets the completed installations.
	CompletedInstallations *[]InstallationInfo `json:"CompletedInstallations"`

	// EncoderLocation Enum describing the location of the FFmpeg tool.
	// Deprecated:
	EncoderLocation *FFmpegLocation `json:"EncoderLocation,omitempty"`

	// HasPendingRestart Gets or sets a value indicating whether this instance has pending restart.
	HasPendingRestart *bool `json:"HasPendingRestart,omitempty"`

	// HasUpdateAvailable Gets or sets a value indicating whether this instance has update available.
	// Deprecated:
	HasUpdateAvailable *bool `json:"HasUpdateAvailable,omitempty"`

	// Id Gets or sets the id.
	Id *string `json:"Id"`

	// InternalMetadataPath Gets or sets the internal metadata path.
	InternalMetadataPath *string `json:"InternalMetadataPath"`
	IsShuttingDown       *bool   `json:"IsShuttingDown,omitempty"`

	// ItemsByNamePath Gets or sets the items by name path.
	ItemsByNamePath *string `json:"ItemsByNamePath"`

	// LocalAddress Gets or sets the local address.
	LocalAddress *string `json:"LocalAddress"`

	// LogPath Gets or sets the log path.
	LogPath *string `json:"LogPath"`

	// OperatingSystem Gets or sets the operating system.
	OperatingSystem *string `json:"OperatingSystem"`

	// OperatingSystemDisplayName Gets or sets the display name of the operating system.
	OperatingSystemDisplayName *string `json:"OperatingSystemDisplayName"`

	// PackageName Gets or sets the package name.
	PackageName *string `json:"PackageName"`

	// ProductName Gets or sets the product name. This is the AssemblyProduct name.
	ProductName *string `json:"ProductName"`

	// ProgramDataPath Gets or sets the program data path.
	ProgramDataPath *string `json:"ProgramDataPath"`

	// ServerName Gets or sets the name of the server.
	ServerName *string `json:"ServerName"`

	// StartupWizardCompleted Gets or sets a value indicating whether the startup wizard is completed.
	StartupWizardCompleted *bool `json:"StartupWizardCompleted"`

	// SupportsLibraryMonitor Gets or sets a value indicating whether [supports library monitor].
	SupportsLibraryMonitor *bool         `json:"SupportsLibraryMonitor,omitempty"`
	SystemArchitecture     *Architecture `json:"SystemArchitecture,omitempty"`

	// TranscodingTempPath Gets or sets the transcode path.
	TranscodingTempPath *string `json:"TranscodingTempPath"`

	// Version Gets or sets the server version.
	Version *string `json:"Version"`

	// WebPath Gets or sets the web UI resources path.
	WebPath *string `json:"WebPath"`

	// WebSocketPortNumber Gets or sets the web socket port number.
	WebSocketPortNumber *int32 `json:"WebSocketPortNumber,omitempty"`
}

// TaskCompletionStatus Enum TaskCompletionStatus.
type TaskCompletionStatus string

// TaskInfo Class TaskInfo.
type TaskInfo struct {
	// Category Gets or sets the category.
	Category *string `json:"Category"`

	// CurrentProgressPercentage Gets or sets the progress.
	CurrentProgressPercentage *float64 `json:"CurrentProgressPercentage"`

	// Description Gets or sets the description.
	Description *string `json:"Description"`

	// Id Gets or sets the id.
	Id *string `json:"Id"`

	// IsHidden Gets or sets a value indicating whether this instance is hidden.
	IsHidden *bool `json:"IsHidden,omitempty"`

	// Key Gets or sets the key.
	Key *string `json:"Key"`

	// LastExecutionResult Gets or sets the last execution result.
	LastExecutionResult *TaskResult `json:"LastExecutionResult"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// State Gets or sets the state of the task.
	State *TaskState `json:"State,omitempty"`

	// Triggers Gets or sets the triggers.
	Triggers *[]TaskTriggerInfo `json:"Triggers"`
}

// TaskResult Class TaskExecutionInfo.
type TaskResult struct {
	// EndTimeUtc Gets or sets the end time UTC.
	EndTimeUtc *time.Time `json:"EndTimeUtc,omitempty"`

	// ErrorMessage Gets or sets the error message.
	ErrorMessage *string `json:"ErrorMessage"`

	// Id Gets or sets the id.
	Id *string `json:"Id"`

	// Key Gets or sets the key.
	Key *string `json:"Key"`

	// LongErrorMessage Gets or sets the long error message.
	LongErrorMessage *string `json:"LongErrorMessage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// StartTimeUtc Gets or sets the start time UTC.
	StartTimeUtc *time.Time `json:"StartTimeUtc,omitempty"`

	// Status Gets or sets the status.
	Status *TaskCompletionStatus `json:"Status,omitempty"`
}

// TaskState Enum TaskState.
type TaskState string

// TaskTriggerInfo Class TaskTriggerInfo.
type TaskTriggerInfo struct {
	// DayOfWeek Gets or sets the day of week.
	DayOfWeek *DayOfWeek `json:"DayOfWeek"`

	// IntervalTicks Gets or sets the interval.
	IntervalTicks *int64 `json:"IntervalTicks"`

	// MaxRuntimeTicks Gets or sets the maximum runtime ticks.
	MaxRuntimeTicks *int64 `json:"MaxRuntimeTicks"`

	// TimeOfDayTicks Gets or sets the time of day.
	TimeOfDayTicks *int64 `json:"TimeOfDayTicks"`

	// Type Gets or sets the type.
	Type *string `json:"Type"`
}

// ThemeMediaResult Class ThemeMediaResult.
type ThemeMediaResult struct {
	// Items Gets or sets the items.
	Items *[]BaseItemDto `json:"Items"`

	// OwnerId Gets or sets the owner id.
	OwnerId *openapi_types.UUID `json:"OwnerId,omitempty"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// TimerInfoDto defines model for TimerInfoDto.
type TimerInfoDto struct {
	// ChannelId Gets or sets the channel id of the recording.
	ChannelId *openapi_types.UUID `json:"ChannelId,omitempty"`

	// ChannelName Gets or sets the channel name of the recording.
	ChannelName            *string `json:"ChannelName"`
	ChannelPrimaryImageTag *string `json:"ChannelPrimaryImageTag"`

	// EndDate Gets or sets the end date of the recording, in UTC.
	EndDate *time.Time `json:"EndDate,omitempty"`

	// ExternalChannelId Gets or sets the external channel identifier.
	ExternalChannelId *string `json:"ExternalChannelId"`

	// ExternalId Gets or sets the external identifier.
	ExternalId *string `json:"ExternalId"`

	// ExternalProgramId Gets or sets the external program identifier.
	ExternalProgramId *string `json:"ExternalProgramId"`

	// ExternalSeriesTimerId Gets or sets the external series timer identifier.
	ExternalSeriesTimerId *string `json:"ExternalSeriesTimerId"`

	// Id Gets or sets the Id of the recording.
	Id *string `json:"Id"`

	// IsPostPaddingRequired Gets or sets a value indicating whether this instance is post padding required.
	IsPostPaddingRequired *bool `json:"IsPostPaddingRequired,omitempty"`

	// IsPrePaddingRequired Gets or sets a value indicating whether this instance is pre padding required.
	IsPrePaddingRequired *bool      `json:"IsPrePaddingRequired,omitempty"`
	KeepUntil            *KeepUntil `json:"KeepUntil,omitempty"`

	// Name Gets or sets the name of the recording.
	Name *string `json:"Name"`

	// Overview Gets or sets the description of the recording.
	Overview *string `json:"Overview"`

	// ParentBackdropImageTags Gets or sets the parent backdrop image tags.
	ParentBackdropImageTags *[]string `json:"ParentBackdropImageTags"`

	// ParentBackdropItemId Gets or sets the Id of the Parent that has a backdrop if the item does not have one.
	ParentBackdropItemId *string `json:"ParentBackdropItemId"`

	// PostPaddingSeconds Gets or sets the post padding seconds.
	PostPaddingSeconds *int32 `json:"PostPaddingSeconds,omitempty"`

	// PrePaddingSeconds Gets or sets the pre padding seconds.
	PrePaddingSeconds *int32 `json:"PrePaddingSeconds,omitempty"`

	// Priority Gets or sets the priority.
	Priority *int32 `json:"Priority,omitempty"`

	// ProgramId Gets or sets the program identifier.
	ProgramId *string `json:"ProgramId"`

	// ProgramInfo Gets or sets the program information.
	ProgramInfo *BaseItemDto `json:"ProgramInfo"`

	// RunTimeTicks Gets or sets the run time ticks.
	RunTimeTicks *int64 `json:"RunTimeTicks"`

	// SeriesTimerId Gets or sets the series timer identifier.
	SeriesTimerId *string `json:"SeriesTimerId"`

	// ServerId Gets or sets the server identifier.
	ServerId *string `json:"ServerId"`

	// ServiceName Gets or sets the name of the service.
	ServiceName *string `json:"ServiceName"`

	// StartDate Gets or sets the start date of the recording, in UTC.
	StartDate *time.Time `json:"StartDate,omitempty"`

	// Status Gets or sets the status.
	Status *RecordingStatus `json:"Status,omitempty"`
	Type   *string          `json:"Type"`
}

// TimerInfoDtoQueryResult defines model for TimerInfoDtoQueryResult.
type TimerInfoDtoQueryResult struct {
	// Items Gets or sets the items.
	Items *[]TimerInfoDto `json:"Items"`

	// StartIndex Gets or sets the index of the first record in Items.
	StartIndex *int32 `json:"StartIndex,omitempty"`

	// TotalRecordCount Gets or sets the total number of records available.
	TotalRecordCount *int32 `json:"TotalRecordCount,omitempty"`
}

// TrailerInfo defines model for TrailerInfo.
type TrailerInfo struct {
	IndexNumber *int32 `json:"IndexNumber"`
	IsAutomated *bool  `json:"IsAutomated,omitempty"`

	// MetadataCountryCode Gets or sets the metadata country code.
	MetadataCountryCode *string `json:"MetadataCountryCode"`

	// MetadataLanguage Gets or sets the metadata language.
	MetadataLanguage *string `json:"MetadataLanguage"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// OriginalTitle Gets or sets the original title.
	OriginalTitle     *string `json:"OriginalTitle"`
	ParentIndexNumber *int32  `json:"ParentIndexNumber"`

	// Path Gets or sets the path.
	Path         *string    `json:"Path"`
	PremiereDate *time.Time `json:"PremiereDate"`

	// ProviderIds Gets or sets the provider ids.
	ProviderIds *map[string]*string `json:"ProviderIds"`

	// Year Gets or sets the year.
	Year *int32 `json:"Year"`
}

// TrailerInfoRemoteSearchQuery defines model for TrailerInfoRemoteSearchQuery.
type TrailerInfoRemoteSearchQuery struct {
	// IncludeDisabledProviders Gets or sets a value indicating whether disabled providers should be included.
	IncludeDisabledProviders *bool               `json:"IncludeDisabledProviders,omitempty"`
	ItemId                   *openapi_types.UUID `json:"ItemId,omitempty"`
	SearchInfo               *TrailerInfo        `json:"SearchInfo"`

	// SearchProviderName Gets or sets the provider name to search within if set.
	SearchProviderName *string `json:"SearchProviderName"`
}

// TranscodeReason defines model for TranscodeReason.
type TranscodeReason string

// TranscodeSeekInfo defines model for TranscodeSeekInfo.
type TranscodeSeekInfo string

// TranscodingInfo defines model for TranscodingInfo.
type TranscodingInfo struct {
	AudioChannels            *int32                `json:"AudioChannels"`
	AudioCodec               *string               `json:"AudioCodec"`
	Bitrate                  *int32                `json:"Bitrate"`
	CompletionPercentage     *float64              `json:"CompletionPercentage"`
	Container                *string               `json:"Container"`
	Framerate                *float32              `json:"Framerate"`
	HardwareAccelerationType *HardwareEncodingType `json:"HardwareAccelerationType"`
	Height                   *int32                `json:"Height"`
	IsAudioDirect            *bool                 `json:"IsAudioDirect,omitempty"`
	IsVideoDirect            *bool                 `json:"IsVideoDirect,omitempty"`
	TranscodeReasons         *[]TranscodeReason    `json:"TranscodeReasons,omitempty"`
	VideoCodec               *string               `json:"VideoCodec"`
	Width                    *int32                `json:"Width"`
}

// TranscodingProfile defines model for TranscodingProfile.
type TranscodingProfile struct {
	AudioCodec                *string             `json:"AudioCodec,omitempty"`
	BreakOnNonKeyFrames       *bool               `json:"BreakOnNonKeyFrames,omitempty"`
	Conditions                *[]ProfileCondition `json:"Conditions,omitempty"`
	Container                 *string             `json:"Container,omitempty"`
	Context                   *EncodingContext    `json:"Context,omitempty"`
	CopyTimestamps            *bool               `json:"CopyTimestamps,omitempty"`
	EnableMpegtsM2TsMode      *bool               `json:"EnableMpegtsM2TsMode,omitempty"`
	EnableSubtitlesInManifest *bool               `json:"EnableSubtitlesInManifest,omitempty"`
	EstimateContentLength     *bool               `json:"EstimateContentLength,omitempty"`
	MaxAudioChannels          *string             `json:"MaxAudioChannels"`
	MinSegments               *int32              `json:"MinSegments,omitempty"`
	Protocol                  *string             `json:"Protocol,omitempty"`
	SegmentLength             *int32              `json:"SegmentLength,omitempty"`
	TranscodeSeekInfo         *TranscodeSeekInfo  `json:"TranscodeSeekInfo,omitempty"`
	Type                      *DlnaProfileType    `json:"Type,omitempty"`
	VideoCodec                *string             `json:"VideoCodec,omitempty"`
}

// TransportStreamTimestamp defines model for TransportStreamTimestamp.
type TransportStreamTimestamp string

// TunerChannelMapping defines model for TunerChannelMapping.
type TunerChannelMapping struct {
	Id                  *string `json:"Id"`
	Name                *string `json:"Name"`
	ProviderChannelId   *string `json:"ProviderChannelId"`
	ProviderChannelName *string `json:"ProviderChannelName"`
}

// TunerHostInfo defines model for TunerHostInfo.
type TunerHostInfo struct {
	AllowHWTranscoding  *bool   `json:"AllowHWTranscoding,omitempty"`
	DeviceId            *string `json:"DeviceId"`
	EnableStreamLooping *bool   `json:"EnableStreamLooping,omitempty"`
	FriendlyName        *string `json:"FriendlyName"`
	Id                  *string `json:"Id"`
	ImportFavoritesOnly *bool   `json:"ImportFavoritesOnly,omitempty"`
	Source              *string `json:"Source"`
	TunerCount          *int32  `json:"TunerCount,omitempty"`
	Type                *string `json:"Type"`
	Url                 *string `json:"Url"`
	UserAgent           *string `json:"UserAgent"`
}

// TypeOptions defines model for TypeOptions.
type TypeOptions struct {
	ImageFetcherOrder    *[]string      `json:"ImageFetcherOrder"`
	ImageFetchers        *[]string      `json:"ImageFetchers"`
	ImageOptions         *[]ImageOption `json:"ImageOptions"`
	MetadataFetcherOrder *[]string      `json:"MetadataFetcherOrder"`
	MetadataFetchers     *[]string      `json:"MetadataFetchers"`
	Type                 *string        `json:"Type"`
}

// UnratedItem An enum representing an unrated item.
type UnratedItem string

// UpdateLibraryOptionsDto Update library options dto.
type UpdateLibraryOptionsDto struct {
	// Id Gets or sets the library item id.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// LibraryOptions Gets or sets library options.
	LibraryOptions *LibraryOptions `json:"LibraryOptions"`
}

// UpdateMediaPathRequestDto Update library options dto.
type UpdateMediaPathRequestDto struct {
	// Name Gets or sets the library name.
	Name string `json:"Name"`

	// PathInfo Gets or sets library folder path information.
	PathInfo MediaPathInfo `json:"PathInfo"`
}

// UpdateUserEasyPassword The update user easy password request body.
type UpdateUserEasyPassword struct {
	// NewPassword Gets or sets the new sha1-hashed password.
	NewPassword *string `json:"NewPassword"`

	// NewPw Gets or sets the new password.
	NewPw *string `json:"NewPw"`

	// ResetPassword Gets or sets a value indicating whether to reset the password.
	ResetPassword *bool `json:"ResetPassword,omitempty"`
}

// UpdateUserPassword The update user password request body.
type UpdateUserPassword struct {
	// CurrentPassword Gets or sets the current sha1-hashed password.
	CurrentPassword *string `json:"CurrentPassword"`

	// CurrentPw Gets or sets the current plain text password.
	CurrentPw *string `json:"CurrentPw"`

	// NewPw Gets or sets the new plain text password.
	NewPw *string `json:"NewPw"`

	// ResetPassword Gets or sets a value indicating whether to reset the password.
	ResetPassword *bool `json:"ResetPassword,omitempty"`
}

// UploadSubtitleDto Upload subtitles dto.
type UploadSubtitleDto struct {
	// Data Gets or sets the subtitle data.
	Data string `json:"Data"`

	// Format Gets or sets the subtitle format.
	Format string `json:"Format"`

	// IsForced Gets or sets a value indicating whether the subtitle is forced.
	IsForced bool `json:"IsForced"`

	// Language Gets or sets the subtitle language.
	Language string `json:"Language"`
}

// UserConfiguration Class UserConfiguration.
type UserConfiguration struct {
	// AudioLanguagePreference Gets or sets the audio language preference.
	AudioLanguagePreference   *string   `json:"AudioLanguagePreference"`
	DisplayCollectionsView    *bool     `json:"DisplayCollectionsView,omitempty"`
	DisplayMissingEpisodes    *bool     `json:"DisplayMissingEpisodes,omitempty"`
	EnableLocalPassword       *bool     `json:"EnableLocalPassword,omitempty"`
	EnableNextEpisodeAutoPlay *bool     `json:"EnableNextEpisodeAutoPlay,omitempty"`
	GroupedFolders            *[]string `json:"GroupedFolders,omitempty"`
	HidePlayedInLatest        *bool     `json:"HidePlayedInLatest,omitempty"`
	LatestItemsExcludes       *[]string `json:"LatestItemsExcludes,omitempty"`
	MyMediaExcludes           *[]string `json:"MyMediaExcludes,omitempty"`
	OrderedViews              *[]string `json:"OrderedViews,omitempty"`

	// PlayDefaultAudioTrack Gets or sets a value indicating whether [play default audio track].
	PlayDefaultAudioTrack      *bool `json:"PlayDefaultAudioTrack,omitempty"`
	RememberAudioSelections    *bool `json:"RememberAudioSelections,omitempty"`
	RememberSubtitleSelections *bool `json:"RememberSubtitleSelections,omitempty"`

	// SubtitleLanguagePreference Gets or sets the subtitle language preference.
	SubtitleLanguagePreference *string `json:"SubtitleLanguagePreference"`

	// SubtitleMode An enum representing a subtitle playback mode.
	SubtitleMode *SubtitlePlaybackMode `json:"SubtitleMode,omitempty"`
}

// UserDto Class UserDto.
type UserDto struct {
	// Configuration Gets or sets the configuration.
	Configuration *UserConfiguration `json:"Configuration"`

	// EnableAutoLogin Gets or sets whether async login is enabled or not.
	EnableAutoLogin *bool `json:"EnableAutoLogin"`

	// HasConfiguredEasyPassword Gets or sets a value indicating whether this instance has configured easy password.
	HasConfiguredEasyPassword *bool `json:"HasConfiguredEasyPassword,omitempty"`

	// HasConfiguredPassword Gets or sets a value indicating whether this instance has configured password.
	HasConfiguredPassword *bool `json:"HasConfiguredPassword,omitempty"`

	// HasPassword Gets or sets a value indicating whether this instance has password.
	HasPassword *bool `json:"HasPassword,omitempty"`

	// Id Gets or sets the id.
	Id *openapi_types.UUID `json:"Id,omitempty"`

	// LastActivityDate Gets or sets the last activity date.
	LastActivityDate *time.Time `json:"LastActivityDate"`

	// LastLoginDate Gets or sets the last login date.
	LastLoginDate *time.Time `json:"LastLoginDate"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// Policy Gets or sets the policy.
	Policy *UserPolicy `json:"Policy"`

	// PrimaryImageAspectRatio Gets or sets the primary image aspect ratio.
	PrimaryImageAspectRatio *float64 `json:"PrimaryImageAspectRatio"`

	// PrimaryImageTag Gets or sets the primary image tag.
	PrimaryImageTag *string `json:"PrimaryImageTag"`

	// ServerId Gets or sets the server identifier.
	ServerId *string `json:"ServerId"`

	// ServerName Gets or sets the name of the server.
	// This is not used by the server and is for client-side usage only.
	ServerName *string `json:"ServerName"`
}

// UserItemDataDto Class UserItemDataDto.
type UserItemDataDto struct {
	// IsFavorite Gets or sets a value indicating whether this instance is favorite.
	IsFavorite *bool `json:"IsFavorite,omitempty"`

	// ItemId Gets or sets the item identifier.
	ItemId *string `json:"ItemId"`

	// Key Gets or sets the key.
	Key *string `json:"Key"`

	// LastPlayedDate Gets or sets the last played date.
	LastPlayedDate *time.Time `json:"LastPlayedDate"`

	// Likes Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
	Likes *bool `json:"Likes"`

	// PlayCount Gets or sets the play count.
	PlayCount *int32 `json:"PlayCount,omitempty"`

	// PlaybackPositionTicks Gets or sets the playback position ticks.
	PlaybackPositionTicks *int64 `json:"PlaybackPositionTicks,omitempty"`

	// Played Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
	Played *bool `json:"Played,omitempty"`

	// PlayedPercentage Gets or sets the played percentage.
	PlayedPercentage *float64 `json:"PlayedPercentage"`

	// Rating Gets or sets the rating.
	Rating *float64 `json:"Rating"`

	// UnplayedItemCount Gets or sets the unplayed item count.
	UnplayedItemCount *int32 `json:"UnplayedItemCount"`
}

// UserPolicy defines model for UserPolicy.
type UserPolicy struct {
	AccessSchedules                  *[]AccessSchedule     `json:"AccessSchedules"`
	AuthenticationProviderId         *string               `json:"AuthenticationProviderId"`
	BlockUnratedItems                *[]UnratedItem        `json:"BlockUnratedItems"`
	BlockedChannels                  *[]openapi_types.UUID `json:"BlockedChannels"`
	BlockedMediaFolders              *[]openapi_types.UUID `json:"BlockedMediaFolders"`
	BlockedTags                      *[]string             `json:"BlockedTags"`
	EnableAllChannels                *bool                 `json:"EnableAllChannels,omitempty"`
	EnableAllDevices                 *bool                 `json:"EnableAllDevices,omitempty"`
	EnableAllFolders                 *bool                 `json:"EnableAllFolders,omitempty"`
	EnableAudioPlaybackTranscoding   *bool                 `json:"EnableAudioPlaybackTranscoding,omitempty"`
	EnableContentDeletion            *bool                 `json:"EnableContentDeletion,omitempty"`
	EnableContentDeletionFromFolders *[]string             `json:"EnableContentDeletionFromFolders"`
	EnableContentDownloading         *bool                 `json:"EnableContentDownloading,omitempty"`
	EnableLiveTvAccess               *bool                 `json:"EnableLiveTvAccess,omitempty"`
	EnableLiveTvManagement           *bool                 `json:"EnableLiveTvManagement,omitempty"`
	EnableMediaConversion            *bool                 `json:"EnableMediaConversion,omitempty"`
	EnableMediaPlayback              *bool                 `json:"EnableMediaPlayback,omitempty"`
	EnablePlaybackRemuxing           *bool                 `json:"EnablePlaybackRemuxing,omitempty"`
	EnablePublicSharing              *bool                 `json:"EnablePublicSharing,omitempty"`
	EnableRemoteAccess               *bool                 `json:"EnableRemoteAccess,omitempty"`
	EnableRemoteControlOfOtherUsers  *bool                 `json:"EnableRemoteControlOfOtherUsers,omitempty"`
	EnableSharedDeviceControl        *bool                 `json:"EnableSharedDeviceControl,omitempty"`

	// EnableSyncTranscoding Gets or sets a value indicating whether [enable synchronize].
	EnableSyncTranscoding          *bool                 `json:"EnableSyncTranscoding,omitempty"`
	EnableUserPreferenceAccess     *bool                 `json:"EnableUserPreferenceAccess,omitempty"`
	EnableVideoPlaybackTranscoding *bool                 `json:"EnableVideoPlaybackTranscoding,omitempty"`
	EnabledChannels                *[]openapi_types.UUID `json:"EnabledChannels"`
	EnabledDevices                 *[]string             `json:"EnabledDevices"`
	EnabledFolders                 *[]openapi_types.UUID `json:"EnabledFolders"`
	ForceRemoteSourceTranscoding   *bool                 `json:"ForceRemoteSourceTranscoding,omitempty"`
	InvalidLoginAttemptCount       *int32                `json:"InvalidLoginAttemptCount,omitempty"`

	// IsAdministrator Gets or sets a value indicating whether this instance is administrator.
	IsAdministrator *bool `json:"IsAdministrator,omitempty"`

	// IsDisabled Gets or sets a value indicating whether this instance is disabled.
	IsDisabled *bool `json:"IsDisabled,omitempty"`

	// IsHidden Gets or sets a value indicating whether this instance is hidden.
	IsHidden                   *bool  `json:"IsHidden,omitempty"`
	LoginAttemptsBeforeLockout *int32 `json:"LoginAttemptsBeforeLockout,omitempty"`
	MaxActiveSessions          *int32 `json:"MaxActiveSessions,omitempty"`

	// MaxParentalRating Gets or sets the max parental rating.
	MaxParentalRating        *int32  `json:"MaxParentalRating"`
	PasswordResetProviderId  *string `json:"PasswordResetProviderId"`
	RemoteClientBitrateLimit *int32  `json:"RemoteClientBitrateLimit,omitempty"`

	// SyncPlayAccess Gets or sets a value indicating what SyncPlay features the user can access.
	SyncPlayAccess *SyncPlayUserAccessType `json:"SyncPlayAccess,omitempty"`
}

// UtcTimeResponse Class UtcTimeResponse.
type UtcTimeResponse struct {
	// RequestReceptionTime Gets the UTC time when request has been received.
	RequestReceptionTime *time.Time `json:"RequestReceptionTime,omitempty"`

	// ResponseTransmissionTime Gets the UTC time when response has been sent.
	ResponseTransmissionTime *time.Time `json:"ResponseTransmissionTime,omitempty"`
}

// ValidatePathDto Validate path object.
type ValidatePathDto struct {
	// IsFile Gets or sets is path file.
	IsFile *bool `json:"IsFile"`

	// Path Gets or sets the path.
	Path *string `json:"Path"`

	// ValidateWritable Gets or sets a value indicating whether validate if path is writable.
	ValidateWritable *bool `json:"ValidateWritable,omitempty"`
}

// VersionInfo Defines the MediaBrowser.Model.Updates.VersionInfo class.
type VersionInfo struct {
	// VersionNumber Gets the version as a System.Version.
	VersionNumber *string `json:"VersionNumber,omitempty"`

	// Changelog Gets or sets the changelog for this version.
	Changelog *string `json:"changelog"`

	// Checksum Gets or sets a checksum for the binary.
	Checksum *string `json:"checksum"`

	// RepositoryName Gets or sets the repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// RepositoryUrl Gets or sets the repository url.
	RepositoryUrl *string `json:"repositoryUrl,omitempty"`

	// SourceUrl Gets or sets the source URL.
	SourceUrl *string `json:"sourceUrl"`

	// TargetAbi Gets or sets the ABI that this version was built against.
	TargetAbi *string `json:"targetAbi"`

	// Timestamp Gets or sets a timestamp of when the binary was built.
	Timestamp *string `json:"timestamp"`

	// Version Gets or sets the version.
	Version *string `json:"version,omitempty"`
}

// Video3DFormat defines model for Video3DFormat.
type Video3DFormat string

// VideoType Enum VideoType.
type VideoType string

// VirtualFolderInfo Used to hold information about a user's list of configured virtual folders.
type VirtualFolderInfo struct {
	// CollectionType Gets or sets the type of the collection.
	CollectionType *CollectionTypeOptions `json:"CollectionType"`

	// ItemId Gets or sets the item identifier.
	ItemId         *string         `json:"ItemId"`
	LibraryOptions *LibraryOptions `json:"LibraryOptions"`

	// Locations Gets or sets the locations.
	Locations *[]string `json:"Locations"`

	// Name Gets or sets the name.
	Name *string `json:"Name"`

	// PrimaryImageItemId Gets or sets the primary image item identifier.
	PrimaryImageItemId *string  `json:"PrimaryImageItemId"`
	RefreshProgress    *float64 `json:"RefreshProgress"`
	RefreshStatus      *string  `json:"RefreshStatus"`
}

// WakeOnLanInfo Provides the MAC address and port for wake-on-LAN functionality.
type WakeOnLanInfo struct {
	// MacAddress Gets the MAC address of the device.
	MacAddress *string `json:"MacAddress"`

	// Port Gets or sets the wake-on-LAN port.
	Port *int32 `json:"Port,omitempty"`
}

// XmlAttribute Defines the MediaBrowser.Model.Dlna.XmlAttribute.
type XmlAttribute struct {
	// Name Gets or sets the name of the attribute.
	Name *string `json:"Name"`

	// Value Gets or sets the value of the attribute.
	Value *string `json:"Value"`
}

// GetInstantMixFromAlbumParams defines parameters for GetInstantMixFromAlbum.
type GetInstantMixFromAlbumParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// GetSimilarAlbumsParams defines parameters for GetSimilarAlbums.
type GetSimilarAlbumsParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetArtistsParams defines parameters for GetArtists.
type GetArtistsParams struct {
	// MinCommunityRating Optional filter by minimum community rating.
	MinCommunityRating *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm Optional. Search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// Filters Optional. Specify additional filters to apply.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// MediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// Genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// GenreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// OfficialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
	OfficialRatings *[]string `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`

	// Tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
	Years *[]int32 `form:"years,omitempty" json:"years,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Person Optional. If specified, results will be filtered to include only those containing the specified person.
	Person *string `form:"person,omitempty" json:"person,omitempty"`

	// PersonIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
	PersonIds *[]openapi_types.UUID `form:"personIds,omitempty" json:"personIds,omitempty"`

	// PersonTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// Studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
	Studios *[]string `form:"studios,omitempty" json:"studios,omitempty"`

	// StudioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
	StudioIds *[]openapi_types.UUID `form:"studioIds,omitempty" json:"studioIds,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableTotalRecordCount Total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetAlbumArtistsParams defines parameters for GetAlbumArtists.
type GetAlbumArtistsParams struct {
	// MinCommunityRating Optional filter by minimum community rating.
	MinCommunityRating *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm Optional. Search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// Filters Optional. Specify additional filters to apply.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// MediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// Genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// GenreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// OfficialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
	OfficialRatings *[]string `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`

	// Tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
	Years *[]int32 `form:"years,omitempty" json:"years,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Person Optional. If specified, results will be filtered to include only those containing the specified person.
	Person *string `form:"person,omitempty" json:"person,omitempty"`

	// PersonIds Optional. If specified, results will be filtered to include only those containing the specified person ids.
	PersonIds *[]openapi_types.UUID `form:"personIds,omitempty" json:"personIds,omitempty"`

	// PersonTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// Studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
	Studios *[]string `form:"studios,omitempty" json:"studios,omitempty"`

	// StudioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
	StudioIds *[]openapi_types.UUID `form:"studioIds,omitempty" json:"studioIds,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableTotalRecordCount Total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetInstantMixFromArtists2Params defines parameters for GetInstantMixFromArtists2.
type GetInstantMixFromArtists2Params struct {
	// Id The item id.
	Id openapi_types.UUID `form:"id" json:"id"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// GetInstantMixFromArtistsParams defines parameters for GetInstantMixFromArtists.
type GetInstantMixFromArtistsParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// GetSimilarArtistsParams defines parameters for GetSimilarArtists.
type GetSimilarArtistsParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetArtistByNameParams defines parameters for GetArtistByName.
type GetArtistByNameParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetArtistImageParams defines parameters for GetArtistImage.
type GetArtistImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadArtistImageParams defines parameters for HeadArtistImage.
type HeadArtistImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// GetHlsAudioSegmentParams defines parameters for GetHlsAudioSegment.
type GetHlsAudioSegmentParams struct {
	// RuntimeTicks The position of the requested segment in ticks.
	RuntimeTicks int64 `form:"runtimeTicks" json:"runtimeTicks"`

	// ActualSegmentLengthTicks The length of the requested segment in ticks.
	ActualSegmentLengthTicks int64 `form:"actualSegmentLengthTicks" json:"actualSegmentLengthTicks"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetVariantHlsAudioPlaylistParams defines parameters for GetVariantHlsAudioPlaylist.
type GetVariantHlsAudioPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetMasterHlsAudioPlaylistParams defines parameters for GetMasterHlsAudioPlaylist.
type GetMasterHlsAudioPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId string `form:"mediaSourceId" json:"mediaSourceId"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`

	// EnableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
	EnableAdaptiveBitrateStreaming *bool `form:"enableAdaptiveBitrateStreaming,omitempty" json:"enableAdaptiveBitrateStreaming,omitempty"`
}

// HeadMasterHlsAudioPlaylistParams defines parameters for HeadMasterHlsAudioPlaylist.
type HeadMasterHlsAudioPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId string `form:"mediaSourceId" json:"mediaSourceId"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`

	// EnableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
	EnableAdaptiveBitrateStreaming *bool `form:"enableAdaptiveBitrateStreaming,omitempty" json:"enableAdaptiveBitrateStreaming,omitempty"`
}

// GetAudioStreamParams defines parameters for GetAudioStream.
type GetAudioStreamParams struct {
	// Container The audio container.
	Container *string `form:"container,omitempty" json:"container,omitempty"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// HeadAudioStreamParams defines parameters for HeadAudioStream.
type HeadAudioStreamParams struct {
	// Container The audio container.
	Container *string `form:"container,omitempty" json:"container,omitempty"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetAudioStreamByContainerParams defines parameters for GetAudioStreamByContainer.
type GetAudioStreamByContainerParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment lenght.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamporphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// HeadAudioStreamByContainerParams defines parameters for HeadAudioStreamByContainer.
type HeadAudioStreamByContainerParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment lenght.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamporphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetUniversalAudioStreamParams defines parameters for GetUniversalAudioStream.
type GetUniversalAudioStreamParams struct {
	// Container Optional. The audio container.
	Container *[]string `form:"container,omitempty" json:"container,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// UserId Optional. The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// AudioCodec Optional. The audio codec to transcode to.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// MaxAudioChannels Optional. The maximum number of audio channels.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// TranscodingAudioChannels Optional. The number of how many audio channels to transcode to.
	TranscodingAudioChannels *int32 `form:"transcodingAudioChannels,omitempty" json:"transcodingAudioChannels,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// TranscodingContainer Optional. The container to transcode to.
	TranscodingContainer *string `form:"transcodingContainer,omitempty" json:"transcodingContainer,omitempty"`

	// TranscodingProtocol Optional. The transcoding protocol.
	TranscodingProtocol *string `form:"transcodingProtocol,omitempty" json:"transcodingProtocol,omitempty"`

	// MaxAudioSampleRate Optional. The maximum audio sample rate.
	MaxAudioSampleRate *int32 `form:"maxAudioSampleRate,omitempty" json:"maxAudioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// EnableRemoteMedia Optional. Whether to enable remote media.
	EnableRemoteMedia *bool `form:"enableRemoteMedia,omitempty" json:"enableRemoteMedia,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// EnableRedirection Whether to enable redirection. Defaults to true.
	EnableRedirection *bool `form:"enableRedirection,omitempty" json:"enableRedirection,omitempty"`
}

// HeadUniversalAudioStreamParams defines parameters for HeadUniversalAudioStream.
type HeadUniversalAudioStreamParams struct {
	// Container Optional. The audio container.
	Container *[]string `form:"container,omitempty" json:"container,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// UserId Optional. The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// AudioCodec Optional. The audio codec to transcode to.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// MaxAudioChannels Optional. The maximum number of audio channels.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// TranscodingAudioChannels Optional. The number of how many audio channels to transcode to.
	TranscodingAudioChannels *int32 `form:"transcodingAudioChannels,omitempty" json:"transcodingAudioChannels,omitempty"`

	// MaxStreamingBitrate Optional. The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// TranscodingContainer Optional. The container to transcode to.
	TranscodingContainer *string `form:"transcodingContainer,omitempty" json:"transcodingContainer,omitempty"`

	// TranscodingProtocol Optional. The transcoding protocol.
	TranscodingProtocol *string `form:"transcodingProtocol,omitempty" json:"transcodingProtocol,omitempty"`

	// MaxAudioSampleRate Optional. The maximum audio sample rate.
	MaxAudioSampleRate *int32 `form:"maxAudioSampleRate,omitempty" json:"maxAudioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// EnableRemoteMedia Optional. Whether to enable remote media.
	EnableRemoteMedia *bool `form:"enableRemoteMedia,omitempty" json:"enableRemoteMedia,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// EnableRedirection Whether to enable redirection. Defaults to true.
	EnableRedirection *bool `form:"enableRedirection,omitempty" json:"enableRedirection,omitempty"`
}

// CreateKeyParams defines parameters for CreateKey.
type CreateKeyParams struct {
	// App Name of the app using the authentication key.
	App string `form:"app" json:"app"`
}

// GetSplashscreenParams defines parameters for GetSplashscreen.
type GetSplashscreenParams struct {
	// Tag Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// Blur Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// Quality Quality setting, from 0-100.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`
}

// GetChannelsParams defines parameters for GetChannels.
type GetChannelsParams struct {
	// UserId User Id to filter by. Use System.Guid.Empty to not filter by user.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SupportsLatestItems Optional. Filter by channels that support getting latest items.
	SupportsLatestItems *bool `form:"supportsLatestItems,omitempty" json:"supportsLatestItems,omitempty"`

	// SupportsMediaDeletion Optional. Filter by channels that support media deletion.
	SupportsMediaDeletion *bool `form:"supportsMediaDeletion,omitempty" json:"supportsMediaDeletion,omitempty"`

	// IsFavorite Optional. Filter by channels that are favorite.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`
}

// GetLatestChannelItemsParams defines parameters for GetLatestChannelItems.
type GetLatestChannelItemsParams struct {
	// UserId Optional. User Id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Filters Optional. Specify additional filters to apply.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ChannelIds Optional. Specify one or more channel id's, comma delimited.
	ChannelIds *[]openapi_types.UUID `form:"channelIds,omitempty" json:"channelIds,omitempty"`
}

// GetChannelItemsParams defines parameters for GetChannelItems.
type GetChannelItemsParams struct {
	// FolderId Optional. Folder Id.
	FolderId *openapi_types.UUID `form:"folderId,omitempty" json:"folderId,omitempty"`

	// UserId Optional. User Id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SortOrder Optional. Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Filters Optional. Specify additional filters to apply.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// LogFileTextBody defines parameters for LogFile.
type LogFileTextBody = openapi_types.File

// CreateCollectionParams defines parameters for CreateCollection.
type CreateCollectionParams struct {
	// Name The name of the collection.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Ids Item Ids to add to the collection.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`

	// ParentId Optional. Create the collection within a specific folder.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// IsLocked Whether or not to lock the new collection.
	IsLocked *bool `form:"isLocked,omitempty" json:"isLocked,omitempty"`
}

// RemoveFromCollectionParams defines parameters for RemoveFromCollection.
type RemoveFromCollectionParams struct {
	// Ids Item ids, comma delimited.
	Ids []openapi_types.UUID `form:"ids" json:"ids"`
}

// AddToCollectionParams defines parameters for AddToCollection.
type AddToCollectionParams struct {
	// Ids Item ids, comma delimited.
	Ids []openapi_types.UUID `form:"ids" json:"ids"`
}

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Id Device Id.
	Id string `form:"id" json:"id"`
}

// GetDevicesParams defines parameters for GetDevices.
type GetDevicesParams struct {
	// SupportsSync Gets or sets a value indicating whether [supports synchronize].
	SupportsSync *bool `form:"supportsSync,omitempty" json:"supportsSync,omitempty"`

	// UserId Gets or sets the user identifier.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetDeviceInfoParams defines parameters for GetDeviceInfo.
type GetDeviceInfoParams struct {
	// Id Device Id.
	Id string `form:"id" json:"id"`
}

// GetDeviceOptionsParams defines parameters for GetDeviceOptions.
type GetDeviceOptionsParams struct {
	// Id Device Id.
	Id string `form:"id" json:"id"`
}

// UpdateDeviceOptionsApplicationWildcardPlusJSONBody defines parameters for UpdateDeviceOptions.
type UpdateDeviceOptionsApplicationWildcardPlusJSONBody = DeviceOptionsDto

// UpdateDeviceOptionsJSONBody defines parameters for UpdateDeviceOptions.
type UpdateDeviceOptionsJSONBody = DeviceOptionsDto

// UpdateDeviceOptionsParams defines parameters for UpdateDeviceOptions.
type UpdateDeviceOptionsParams struct {
	// Id Device Id.
	Id string `form:"id" json:"id"`
}

// GetDisplayPreferencesParams defines parameters for GetDisplayPreferences.
type GetDisplayPreferencesParams struct {
	// UserId User id.
	UserId openapi_types.UUID `form:"userId" json:"userId"`

	// Client Client.
	Client string `form:"client" json:"client"`
}

// UpdateDisplayPreferencesApplicationWildcardPlusJSONBody defines parameters for UpdateDisplayPreferences.
type UpdateDisplayPreferencesApplicationWildcardPlusJSONBody = DisplayPreferencesDto

// UpdateDisplayPreferencesJSONBody defines parameters for UpdateDisplayPreferences.
type UpdateDisplayPreferencesJSONBody = DisplayPreferencesDto

// UpdateDisplayPreferencesParams defines parameters for UpdateDisplayPreferences.
type UpdateDisplayPreferencesParams struct {
	// UserId User Id.
	UserId openapi_types.UUID `form:"userId" json:"userId"`

	// Client Client.
	Client string `form:"client" json:"client"`
}

// CreateProfileApplicationWildcardPlusJSONBody defines parameters for CreateProfile.
type CreateProfileApplicationWildcardPlusJSONBody = DeviceProfile

// CreateProfileJSONBody defines parameters for CreateProfile.
type CreateProfileJSONBody = DeviceProfile

// UpdateProfileApplicationWildcardPlusJSONBody defines parameters for UpdateProfile.
type UpdateProfileApplicationWildcardPlusJSONBody = DeviceProfile

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody = DeviceProfile

// GetDirectoryContentsParams defines parameters for GetDirectoryContents.
type GetDirectoryContentsParams struct {
	// Path The path.
	Path string `form:"path" json:"path"`

	// IncludeFiles An optional filter to include or exclude files from the results. true/false.
	IncludeFiles *bool `form:"includeFiles,omitempty" json:"includeFiles,omitempty"`

	// IncludeDirectories An optional filter to include or exclude folders from the results. true/false.
	IncludeDirectories *bool `form:"includeDirectories,omitempty" json:"includeDirectories,omitempty"`
}

// GetParentPathParams defines parameters for GetParentPath.
type GetParentPathParams struct {
	// Path The path.
	Path string `form:"path" json:"path"`
}

// ValidatePathApplicationWildcardPlusJSONBody defines parameters for ValidatePath.
type ValidatePathApplicationWildcardPlusJSONBody = ValidatePathDto

// ValidatePathJSONBody defines parameters for ValidatePath.
type ValidatePathJSONBody = ValidatePathDto

// GetGenresParams defines parameters for GetGenres.
type GetGenresParams struct {
	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm The search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableTotalRecordCount Optional. Include total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetGenreParams defines parameters for GetGenre.
type GetGenreParams struct {
	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetGenreImageParams defines parameters for GetGenreImage.
type GetGenreImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadGenreImageParams defines parameters for HeadGenreImage.
type HeadGenreImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetGenreImageByIndexParams defines parameters for GetGenreImageByIndex.
type GetGenreImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadGenreImageByIndexParams defines parameters for HeadGenreImageByIndex.
type HeadGenreImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// DeleteItemsParams defines parameters for DeleteItems.
type DeleteItemsParams struct {
	// Ids The item ids.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`
}

// GetItemsParams defines parameters for GetItems.
type GetItemsParams struct {
	// UserId The user id supplied as query parameter.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// MaxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
	MaxOfficialRating *string `form:"maxOfficialRating,omitempty" json:"maxOfficialRating,omitempty"`

	// HasThemeSong Optional filter by items with theme songs.
	HasThemeSong *bool `form:"hasThemeSong,omitempty" json:"hasThemeSong,omitempty"`

	// HasThemeVideo Optional filter by items with theme videos.
	HasThemeVideo *bool `form:"hasThemeVideo,omitempty" json:"hasThemeVideo,omitempty"`

	// HasSubtitles Optional filter by items with subtitles.
	HasSubtitles *bool `form:"hasSubtitles,omitempty" json:"hasSubtitles,omitempty"`

	// HasSpecialFeature Optional filter by items with special features.
	HasSpecialFeature *bool `form:"hasSpecialFeature,omitempty" json:"hasSpecialFeature,omitempty"`

	// HasTrailer Optional filter by items with trailers.
	HasTrailer *bool `form:"hasTrailer,omitempty" json:"hasTrailer,omitempty"`

	// AdjacentTo Optional. Return items that are siblings of a supplied item.
	AdjacentTo *string `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`

	// ParentIndexNumber Optional filter by parent index number.
	ParentIndexNumber *int32 `form:"parentIndexNumber,omitempty" json:"parentIndexNumber,omitempty"`

	// HasParentalRating Optional filter by items that have or do not have a parental rating.
	HasParentalRating *bool `form:"hasParentalRating,omitempty" json:"hasParentalRating,omitempty"`

	// IsHd Optional filter by items that are HD or not.
	IsHd *bool `form:"isHd,omitempty" json:"isHd,omitempty"`

	// Is4K Optional filter by items that are 4K or not.
	Is4K *bool `form:"is4K,omitempty" json:"is4K,omitempty"`

	// LocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
	LocationTypes *[]LocationType `form:"locationTypes,omitempty" json:"locationTypes,omitempty"`

	// ExcludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
	ExcludeLocationTypes *[]LocationType `form:"excludeLocationTypes,omitempty" json:"excludeLocationTypes,omitempty"`

	// IsMissing Optional filter by items that are missing episodes or not.
	IsMissing *bool `form:"isMissing,omitempty" json:"isMissing,omitempty"`

	// IsUnaired Optional filter by items that are unaired episodes or not.
	IsUnaired *bool `form:"isUnaired,omitempty" json:"isUnaired,omitempty"`

	// MinCommunityRating Optional filter by minimum community rating.
	MinCommunityRating *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`

	// MinCriticRating Optional filter by minimum critic rating.
	MinCriticRating *float64 `form:"minCriticRating,omitempty" json:"minCriticRating,omitempty"`

	// MinPremiereDate Optional. The minimum premiere date. Format = ISO.
	MinPremiereDate *time.Time `form:"minPremiereDate,omitempty" json:"minPremiereDate,omitempty"`

	// MinDateLastSaved Optional. The minimum last saved date. Format = ISO.
	MinDateLastSaved *time.Time `form:"minDateLastSaved,omitempty" json:"minDateLastSaved,omitempty"`

	// MinDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
	MinDateLastSavedForUser *time.Time `form:"minDateLastSavedForUser,omitempty" json:"minDateLastSavedForUser,omitempty"`

	// MaxPremiereDate Optional. The maximum premiere date. Format = ISO.
	MaxPremiereDate *time.Time `form:"maxPremiereDate,omitempty" json:"maxPremiereDate,omitempty"`

	// HasOverview Optional filter by items that have an overview or not.
	HasOverview *bool `form:"hasOverview,omitempty" json:"hasOverview,omitempty"`

	// HasImdbId Optional filter by items that have an imdb id or not.
	HasImdbId *bool `form:"hasImdbId,omitempty" json:"hasImdbId,omitempty"`

	// HasTmdbId Optional filter by items that have a tmdb id or not.
	HasTmdbId *bool `form:"hasTmdbId,omitempty" json:"hasTmdbId,omitempty"`

	// HasTvdbId Optional filter by items that have a tvdb id or not.
	HasTvdbId *bool `form:"hasTvdbId,omitempty" json:"hasTvdbId,omitempty"`

	// IsMovie Optional filter for live tv movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional filter for live tv series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional filter for live tv news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional filter for live tv kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional filter for live tv sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// ExcludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
	ExcludeItemIds *[]openapi_types.UUID `form:"excludeItemIds,omitempty" json:"excludeItemIds,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// SearchTerm Optional. Filter based on a search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// Filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// MediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// ImageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
	ImageTypes *[]ImageType `form:"imageTypes,omitempty" json:"imageTypes,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// IsPlayed Optional filter by items that are played, or not.
	IsPlayed *bool `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`

	// Genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// OfficialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
	OfficialRatings *[]string `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`

	// Tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
	Years *[]int32 `form:"years,omitempty" json:"years,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Person Optional. If specified, results will be filtered to include only those containing the specified person.
	Person *string `form:"person,omitempty" json:"person,omitempty"`

	// PersonIds Optional. If specified, results will be filtered to include only those containing the specified person id.
	PersonIds *[]openapi_types.UUID `form:"personIds,omitempty" json:"personIds,omitempty"`

	// PersonTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// Studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
	Studios *[]string `form:"studios,omitempty" json:"studios,omitempty"`

	// Artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
	Artists *[]string `form:"artists,omitempty" json:"artists,omitempty"`

	// ExcludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// ArtistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
	ArtistIds *[]openapi_types.UUID `form:"artistIds,omitempty" json:"artistIds,omitempty"`

	// AlbumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
	AlbumArtistIds *[]openapi_types.UUID `form:"albumArtistIds,omitempty" json:"albumArtistIds,omitempty"`

	// ContributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
	ContributingArtistIds *[]openapi_types.UUID `form:"contributingArtistIds,omitempty" json:"contributingArtistIds,omitempty"`

	// Albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
	Albums *[]string `form:"albums,omitempty" json:"albums,omitempty"`

	// AlbumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
	AlbumIds *[]openapi_types.UUID `form:"albumIds,omitempty" json:"albumIds,omitempty"`

	// Ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// VideoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
	VideoTypes *[]VideoType `form:"videoTypes,omitempty" json:"videoTypes,omitempty"`

	// MinOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
	MinOfficialRating *string `form:"minOfficialRating,omitempty" json:"minOfficialRating,omitempty"`

	// IsLocked Optional filter by items that are locked.
	IsLocked *bool `form:"isLocked,omitempty" json:"isLocked,omitempty"`

	// IsPlaceHolder Optional filter by items that are placeholders.
	IsPlaceHolder *bool `form:"isPlaceHolder,omitempty" json:"isPlaceHolder,omitempty"`

	// HasOfficialRating Optional filter by items that have official ratings.
	HasOfficialRating *bool `form:"hasOfficialRating,omitempty" json:"hasOfficialRating,omitempty"`

	// CollapseBoxSetItems Whether or not to hide items behind their boxsets.
	CollapseBoxSetItems *bool `form:"collapseBoxSetItems,omitempty" json:"collapseBoxSetItems,omitempty"`

	// MinWidth Optional. Filter by the minimum width of the item.
	MinWidth *int32 `form:"minWidth,omitempty" json:"minWidth,omitempty"`

	// MinHeight Optional. Filter by the minimum height of the item.
	MinHeight *int32 `form:"minHeight,omitempty" json:"minHeight,omitempty"`

	// MaxWidth Optional. Filter by the maximum width of the item.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. Filter by the maximum height of the item.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Is3D Optional filter by items that are 3D, or not.
	Is3D *bool `form:"is3D,omitempty" json:"is3D,omitempty"`

	// SeriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
	SeriesStatus *[]SeriesStatus `form:"seriesStatus,omitempty" json:"seriesStatus,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// StudioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
	StudioIds *[]openapi_types.UUID `form:"studioIds,omitempty" json:"studioIds,omitempty"`

	// GenreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// EnableTotalRecordCount Optional. Enable the total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetItemCountsParams defines parameters for GetItemCounts.
type GetItemCountsParams struct {
	// UserId Optional. Get counts from a specific user's library.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// IsFavorite Optional. Get counts of favorite items.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`
}

// GetQueryFiltersLegacyParams defines parameters for GetQueryFiltersLegacy.
type GetQueryFiltersLegacyParams struct {
	// UserId Optional. User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// ParentId Optional. Parent id.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// MediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`
}

// GetQueryFiltersParams defines parameters for GetQueryFilters.
type GetQueryFiltersParams struct {
	// UserId Optional. User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// ParentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// IsAiring Optional. Is item airing.
	IsAiring *bool `form:"isAiring,omitempty" json:"isAiring,omitempty"`

	// IsMovie Optional. Is item movie.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSports Optional. Is item sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// IsKids Optional. Is item kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsNews Optional. Is item news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsSeries Optional. Is item series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// Recursive Optional. Search recursive.
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`
}

// ApplySearchCriteriaApplicationWildcardPlusJSONBody defines parameters for ApplySearchCriteria.
type ApplySearchCriteriaApplicationWildcardPlusJSONBody = RemoteSearchResult

// ApplySearchCriteriaJSONBody defines parameters for ApplySearchCriteria.
type ApplySearchCriteriaJSONBody = RemoteSearchResult

// ApplySearchCriteriaParams defines parameters for ApplySearchCriteria.
type ApplySearchCriteriaParams struct {
	// ReplaceAllImages Optional. Whether or not to replace all images. Default: True.
	ReplaceAllImages *bool `form:"replaceAllImages,omitempty" json:"replaceAllImages,omitempty"`
}

// GetBookRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetBookRemoteSearchResults.
type GetBookRemoteSearchResultsApplicationWildcardPlusJSONBody = BookInfoRemoteSearchQuery

// GetBookRemoteSearchResultsJSONBody defines parameters for GetBookRemoteSearchResults.
type GetBookRemoteSearchResultsJSONBody = BookInfoRemoteSearchQuery

// GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetBoxSetRemoteSearchResults.
type GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONBody = BoxSetInfoRemoteSearchQuery

// GetBoxSetRemoteSearchResultsJSONBody defines parameters for GetBoxSetRemoteSearchResults.
type GetBoxSetRemoteSearchResultsJSONBody = BoxSetInfoRemoteSearchQuery

// GetMovieRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetMovieRemoteSearchResults.
type GetMovieRemoteSearchResultsApplicationWildcardPlusJSONBody = MovieInfoRemoteSearchQuery

// GetMovieRemoteSearchResultsJSONBody defines parameters for GetMovieRemoteSearchResults.
type GetMovieRemoteSearchResultsJSONBody = MovieInfoRemoteSearchQuery

// GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetMusicAlbumRemoteSearchResults.
type GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONBody = AlbumInfoRemoteSearchQuery

// GetMusicAlbumRemoteSearchResultsJSONBody defines parameters for GetMusicAlbumRemoteSearchResults.
type GetMusicAlbumRemoteSearchResultsJSONBody = AlbumInfoRemoteSearchQuery

// GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetMusicArtistRemoteSearchResults.
type GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONBody = ArtistInfoRemoteSearchQuery

// GetMusicArtistRemoteSearchResultsJSONBody defines parameters for GetMusicArtistRemoteSearchResults.
type GetMusicArtistRemoteSearchResultsJSONBody = ArtistInfoRemoteSearchQuery

// GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetMusicVideoRemoteSearchResults.
type GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONBody = MusicVideoInfoRemoteSearchQuery

// GetMusicVideoRemoteSearchResultsJSONBody defines parameters for GetMusicVideoRemoteSearchResults.
type GetMusicVideoRemoteSearchResultsJSONBody = MusicVideoInfoRemoteSearchQuery

// GetPersonRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetPersonRemoteSearchResults.
type GetPersonRemoteSearchResultsApplicationWildcardPlusJSONBody = PersonLookupInfoRemoteSearchQuery

// GetPersonRemoteSearchResultsJSONBody defines parameters for GetPersonRemoteSearchResults.
type GetPersonRemoteSearchResultsJSONBody = PersonLookupInfoRemoteSearchQuery

// GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetSeriesRemoteSearchResults.
type GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONBody = SeriesInfoRemoteSearchQuery

// GetSeriesRemoteSearchResultsJSONBody defines parameters for GetSeriesRemoteSearchResults.
type GetSeriesRemoteSearchResultsJSONBody = SeriesInfoRemoteSearchQuery

// GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONBody defines parameters for GetTrailerRemoteSearchResults.
type GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONBody = TrailerInfoRemoteSearchQuery

// GetTrailerRemoteSearchResultsJSONBody defines parameters for GetTrailerRemoteSearchResults.
type GetTrailerRemoteSearchResultsJSONBody = TrailerInfoRemoteSearchQuery

// GetInstantMixFromItemParams defines parameters for GetInstantMixFromItem.
type GetInstantMixFromItemParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// UpdateItemApplicationWildcardPlusJSONBody defines parameters for UpdateItem.
type UpdateItemApplicationWildcardPlusJSONBody = BaseItemDto

// UpdateItemJSONBody defines parameters for UpdateItem.
type UpdateItemJSONBody = BaseItemDto

// GetAncestorsParams defines parameters for GetAncestors.
type GetAncestorsParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// UpdateItemContentTypeParams defines parameters for UpdateItemContentType.
type UpdateItemContentTypeParams struct {
	// ContentType The content type of the item.
	ContentType *string `form:"contentType,omitempty" json:"contentType,omitempty"`
}

// DeleteItemImageParams defines parameters for DeleteItemImage.
type DeleteItemImageParams struct {
	// ImageIndex The image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetItemImageParams defines parameters for GetItemImage.
type GetItemImageParams struct {
	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// Format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadItemImageParams defines parameters for HeadItemImage.
type HeadItemImageParams struct {
	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// Format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetItemImageByIndexParams defines parameters for GetItemImageByIndex.
type GetItemImageByIndexParams struct {
	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// Format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadItemImageByIndexParams defines parameters for HeadItemImageByIndex.
type HeadItemImageByIndexParams struct {
	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// Format Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// UpdateItemImageIndexParams defines parameters for UpdateItemImageIndex.
type UpdateItemImageIndexParams struct {
	// NewIndex New image index.
	NewIndex int32 `form:"newIndex" json:"newIndex"`
}

// GetItemImage2Params defines parameters for GetItemImage2.
type GetItemImage2Params struct {
	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadItemImage2Params defines parameters for HeadItemImage2.
type HeadItemImage2Params struct {
	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// GetPlaybackInfoParams defines parameters for GetPlaybackInfo.
type GetPlaybackInfoParams struct {
	// UserId The user id.
	UserId openapi_types.UUID `form:"userId" json:"userId"`
}

// GetPostedPlaybackInfoApplicationWildcardPlusJSONBody defines parameters for GetPostedPlaybackInfo.
type GetPostedPlaybackInfoApplicationWildcardPlusJSONBody = PlaybackInfoDto

// GetPostedPlaybackInfoJSONBody defines parameters for GetPostedPlaybackInfo.
type GetPostedPlaybackInfoJSONBody = PlaybackInfoDto

// GetPostedPlaybackInfoParams defines parameters for GetPostedPlaybackInfo.
type GetPostedPlaybackInfoParams struct {
	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// MaxStreamingBitrate The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// StartTimeTicks The start time in ticks.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// AudioStreamIndex The audio stream index.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// SubtitleStreamIndex The subtitle stream index.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// MaxAudioChannels The maximum number of audio channels.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// MediaSourceId The media source id.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// LiveStreamId The livestream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// AutoOpenLiveStream Whether to auto open the livestream.
	AutoOpenLiveStream *bool `form:"autoOpenLiveStream,omitempty" json:"autoOpenLiveStream,omitempty"`

	// EnableDirectPlay Whether to enable direct play. Default: true.
	EnableDirectPlay *bool `form:"enableDirectPlay,omitempty" json:"enableDirectPlay,omitempty"`

	// EnableDirectStream Whether to enable direct stream. Default: true.
	EnableDirectStream *bool `form:"enableDirectStream,omitempty" json:"enableDirectStream,omitempty"`

	// EnableTranscoding Whether to enable transcoding. Default: true.
	EnableTranscoding *bool `form:"enableTranscoding,omitempty" json:"enableTranscoding,omitempty"`

	// AllowVideoStreamCopy Whether to allow to copy the video stream. Default: true.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether to allow to copy the audio stream. Default: true.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`
}

// RefreshItemParams defines parameters for RefreshItem.
type RefreshItemParams struct {
	// MetadataRefreshMode (Optional) Specifies the metadata refresh mode.
	MetadataRefreshMode *MetadataRefreshMode `form:"metadataRefreshMode,omitempty" json:"metadataRefreshMode,omitempty"`

	// ImageRefreshMode (Optional) Specifies the image refresh mode.
	ImageRefreshMode *MetadataRefreshMode `form:"imageRefreshMode,omitempty" json:"imageRefreshMode,omitempty"`

	// ReplaceAllMetadata (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
	ReplaceAllMetadata *bool `form:"replaceAllMetadata,omitempty" json:"replaceAllMetadata,omitempty"`

	// ReplaceAllImages (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
	ReplaceAllImages *bool `form:"replaceAllImages,omitempty" json:"replaceAllImages,omitempty"`
}

// GetRemoteImagesParams defines parameters for GetRemoteImages.
type GetRemoteImagesParams struct {
	// Type The image type.
	Type *ImageType `form:"type,omitempty" json:"type,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// ProviderName Optional. The image provider to use.
	ProviderName *string `form:"providerName,omitempty" json:"providerName,omitempty"`

	// IncludeAllLanguages Optional. Include all languages.
	IncludeAllLanguages *bool `form:"includeAllLanguages,omitempty" json:"includeAllLanguages,omitempty"`
}

// DownloadRemoteImageParams defines parameters for DownloadRemoteImage.
type DownloadRemoteImageParams struct {
	// Type The image type.
	Type ImageType `form:"type" json:"type"`

	// ImageUrl The image url.
	ImageUrl *string `form:"imageUrl,omitempty" json:"imageUrl,omitempty"`
}

// SearchRemoteSubtitlesParams defines parameters for SearchRemoteSubtitles.
type SearchRemoteSubtitlesParams struct {
	// IsPerfectMatch Optional. Only show subtitles which are a perfect match.
	IsPerfectMatch *bool `form:"isPerfectMatch,omitempty" json:"isPerfectMatch,omitempty"`
}

// GetSimilarItemsParams defines parameters for GetSimilarItems.
type GetSimilarItemsParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetThemeMediaParams defines parameters for GetThemeMedia.
type GetThemeMediaParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// InheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
	InheritFromParent *bool `form:"inheritFromParent,omitempty" json:"inheritFromParent,omitempty"`
}

// GetThemeSongsParams defines parameters for GetThemeSongs.
type GetThemeSongsParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// InheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
	InheritFromParent *bool `form:"inheritFromParent,omitempty" json:"inheritFromParent,omitempty"`
}

// GetThemeVideosParams defines parameters for GetThemeVideos.
type GetThemeVideosParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// InheritFromParent Optional. Determines whether or not parent items should be searched for theme media.
	InheritFromParent *bool `form:"inheritFromParent,omitempty" json:"inheritFromParent,omitempty"`
}

// ValidateLoginInfoApplicationWildcardPlusJSONBody defines parameters for ValidateLoginInfo.
type ValidateLoginInfoApplicationWildcardPlusJSONBody = LoginInfoInput

// ValidateLoginInfoJSONBody defines parameters for ValidateLoginInfo.
type ValidateLoginInfoJSONBody = LoginInfoInput

// GetLibraryOptionsInfoParams defines parameters for GetLibraryOptionsInfo.
type GetLibraryOptionsInfoParams struct {
	// LibraryContentType Library content type.
	LibraryContentType *string `form:"libraryContentType,omitempty" json:"libraryContentType,omitempty"`

	// IsNewLibrary Whether this is a new library.
	IsNewLibrary *bool `form:"isNewLibrary,omitempty" json:"isNewLibrary,omitempty"`
}

// PostUpdatedMediaApplicationWildcardPlusJSONBody defines parameters for PostUpdatedMedia.
type PostUpdatedMediaApplicationWildcardPlusJSONBody = MediaUpdateInfoDto

// PostUpdatedMediaJSONBody defines parameters for PostUpdatedMedia.
type PostUpdatedMediaJSONBody = MediaUpdateInfoDto

// GetMediaFoldersParams defines parameters for GetMediaFolders.
type GetMediaFoldersParams struct {
	// IsHidden Optional. Filter by folders that are marked hidden, or not.
	IsHidden *bool `form:"isHidden,omitempty" json:"isHidden,omitempty"`
}

// PostAddedMoviesParams defines parameters for PostAddedMovies.
type PostAddedMoviesParams struct {
	// TmdbId The tmdbId.
	TmdbId *string `form:"tmdbId,omitempty" json:"tmdbId,omitempty"`

	// ImdbId The imdbId.
	ImdbId *string `form:"imdbId,omitempty" json:"imdbId,omitempty"`
}

// PostUpdatedMoviesParams defines parameters for PostUpdatedMovies.
type PostUpdatedMoviesParams struct {
	// TmdbId The tmdbId.
	TmdbId *string `form:"tmdbId,omitempty" json:"tmdbId,omitempty"`

	// ImdbId The imdbId.
	ImdbId *string `form:"imdbId,omitempty" json:"imdbId,omitempty"`
}

// PostAddedSeriesParams defines parameters for PostAddedSeries.
type PostAddedSeriesParams struct {
	// TvdbId The tvdbId.
	TvdbId *string `form:"tvdbId,omitempty" json:"tvdbId,omitempty"`
}

// PostUpdatedSeriesParams defines parameters for PostUpdatedSeries.
type PostUpdatedSeriesParams struct {
	// TvdbId The tvdbId.
	TvdbId *string `form:"tvdbId,omitempty" json:"tvdbId,omitempty"`
}

// RemoveVirtualFolderParams defines parameters for RemoveVirtualFolder.
type RemoveVirtualFolderParams struct {
	// Name The name of the folder.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// RefreshLibrary Whether to refresh the library.
	RefreshLibrary *bool `form:"refreshLibrary,omitempty" json:"refreshLibrary,omitempty"`
}

// AddVirtualFolderApplicationWildcardPlusJSONBody defines parameters for AddVirtualFolder.
type AddVirtualFolderApplicationWildcardPlusJSONBody = AddVirtualFolderDto

// AddVirtualFolderJSONBody defines parameters for AddVirtualFolder.
type AddVirtualFolderJSONBody = AddVirtualFolderDto

// AddVirtualFolderParams defines parameters for AddVirtualFolder.
type AddVirtualFolderParams struct {
	// Name The name of the virtual folder.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// CollectionType The type of the collection.
	CollectionType *CollectionTypeOptions `form:"collectionType,omitempty" json:"collectionType,omitempty"`

	// Paths The paths of the virtual folder.
	Paths *[]string `form:"paths,omitempty" json:"paths,omitempty"`

	// RefreshLibrary Whether to refresh the library.
	RefreshLibrary *bool `form:"refreshLibrary,omitempty" json:"refreshLibrary,omitempty"`
}

// UpdateLibraryOptionsApplicationWildcardPlusJSONBody defines parameters for UpdateLibraryOptions.
type UpdateLibraryOptionsApplicationWildcardPlusJSONBody = UpdateLibraryOptionsDto

// UpdateLibraryOptionsJSONBody defines parameters for UpdateLibraryOptions.
type UpdateLibraryOptionsJSONBody = UpdateLibraryOptionsDto

// RenameVirtualFolderParams defines parameters for RenameVirtualFolder.
type RenameVirtualFolderParams struct {
	// Name The name of the virtual folder.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NewName The new name.
	NewName *string `form:"newName,omitempty" json:"newName,omitempty"`

	// RefreshLibrary Whether to refresh the library.
	RefreshLibrary *bool `form:"refreshLibrary,omitempty" json:"refreshLibrary,omitempty"`
}

// RemoveMediaPathParams defines parameters for RemoveMediaPath.
type RemoveMediaPathParams struct {
	// Name The name of the library.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Path The path to remove.
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// RefreshLibrary Whether to refresh the library.
	RefreshLibrary *bool `form:"refreshLibrary,omitempty" json:"refreshLibrary,omitempty"`
}

// AddMediaPathApplicationWildcardPlusJSONBody defines parameters for AddMediaPath.
type AddMediaPathApplicationWildcardPlusJSONBody = MediaPathDto

// AddMediaPathJSONBody defines parameters for AddMediaPath.
type AddMediaPathJSONBody = MediaPathDto

// AddMediaPathParams defines parameters for AddMediaPath.
type AddMediaPathParams struct {
	// RefreshLibrary Whether to refresh the library.
	RefreshLibrary *bool `form:"refreshLibrary,omitempty" json:"refreshLibrary,omitempty"`
}

// UpdateMediaPathApplicationWildcardPlusJSONBody defines parameters for UpdateMediaPath.
type UpdateMediaPathApplicationWildcardPlusJSONBody = UpdateMediaPathRequestDto

// UpdateMediaPathJSONBody defines parameters for UpdateMediaPath.
type UpdateMediaPathJSONBody = UpdateMediaPathRequestDto

// CloseLiveStreamParams defines parameters for CloseLiveStream.
type CloseLiveStreamParams struct {
	// LiveStreamId The livestream id.
	LiveStreamId string `form:"liveStreamId" json:"liveStreamId"`
}

// OpenLiveStreamApplicationWildcardPlusJSONBody defines parameters for OpenLiveStream.
type OpenLiveStreamApplicationWildcardPlusJSONBody = OpenLiveStreamDto

// OpenLiveStreamJSONBody defines parameters for OpenLiveStream.
type OpenLiveStreamJSONBody = OpenLiveStreamDto

// OpenLiveStreamParams defines parameters for OpenLiveStream.
type OpenLiveStreamParams struct {
	// OpenToken The open token.
	OpenToken *string `form:"openToken,omitempty" json:"openToken,omitempty"`

	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// MaxStreamingBitrate The maximum streaming bitrate.
	MaxStreamingBitrate *int32 `form:"maxStreamingBitrate,omitempty" json:"maxStreamingBitrate,omitempty"`

	// StartTimeTicks The start time in ticks.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// AudioStreamIndex The audio stream index.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// SubtitleStreamIndex The subtitle stream index.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// MaxAudioChannels The maximum number of audio channels.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// ItemId The item id.
	ItemId *openapi_types.UUID `form:"itemId,omitempty" json:"itemId,omitempty"`

	// EnableDirectPlay Whether to enable direct play. Default: true.
	EnableDirectPlay *bool `form:"enableDirectPlay,omitempty" json:"enableDirectPlay,omitempty"`

	// EnableDirectStream Whether to enable direct stream. Default: true.
	EnableDirectStream *bool `form:"enableDirectStream,omitempty" json:"enableDirectStream,omitempty"`
}

// GetChannelMappingOptionsParams defines parameters for GetChannelMappingOptions.
type GetChannelMappingOptionsParams struct {
	// ProviderId Provider id.
	ProviderId *string `form:"providerId,omitempty" json:"providerId,omitempty"`
}

// SetChannelMappingApplicationWildcardPlusJSONBody defines parameters for SetChannelMapping.
type SetChannelMappingApplicationWildcardPlusJSONBody = SetChannelMappingDto

// SetChannelMappingJSONBody defines parameters for SetChannelMapping.
type SetChannelMappingJSONBody = SetChannelMappingDto

// GetLiveTvChannelsParams defines parameters for GetLiveTvChannels.
type GetLiveTvChannelsParams struct {
	// Type Optional. Filter by channel type.
	Type *ChannelType `form:"type,omitempty" json:"type,omitempty"`

	// UserId Optional. Filter by user and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// IsMovie Optional. Filter for movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional. Filter for series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional. Filter for news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional. Filter for kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional. Filter for sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IsFavorite Optional. Filter by channels that are favorites, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// IsLiked Optional. Filter by channels that are liked, or not.
	IsLiked *bool `form:"isLiked,omitempty" json:"isLiked,omitempty"`

	// IsDisliked Optional. Filter by channels that are disliked, or not.
	IsDisliked *bool `form:"isDisliked,omitempty" json:"isDisliked,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes "Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// SortBy Optional. Key to sort by.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Optional. Sort order.
	SortOrder *SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// EnableFavoriteSorting Optional. Incorporate favorite and like status into channel sorting.
	EnableFavoriteSorting *bool `form:"enableFavoriteSorting,omitempty" json:"enableFavoriteSorting,omitempty"`

	// AddCurrentProgram Optional. Adds current program info to each channel.
	AddCurrentProgram *bool `form:"addCurrentProgram,omitempty" json:"addCurrentProgram,omitempty"`
}

// GetChannelParams defines parameters for GetChannel.
type GetChannelParams struct {
	// UserId Optional. Attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// DeleteListingProviderParams defines parameters for DeleteListingProvider.
type DeleteListingProviderParams struct {
	// Id Listing provider id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// AddListingProviderApplicationWildcardPlusJSONBody defines parameters for AddListingProvider.
type AddListingProviderApplicationWildcardPlusJSONBody = ListingsProviderInfo

// AddListingProviderJSONBody defines parameters for AddListingProvider.
type AddListingProviderJSONBody = ListingsProviderInfo

// AddListingProviderParams defines parameters for AddListingProvider.
type AddListingProviderParams struct {
	// Pw Password.
	Pw *string `form:"pw,omitempty" json:"pw,omitempty"`

	// ValidateListings Validate listings.
	ValidateListings *bool `form:"validateListings,omitempty" json:"validateListings,omitempty"`

	// ValidateLogin Validate login.
	ValidateLogin *bool `form:"validateLogin,omitempty" json:"validateLogin,omitempty"`
}

// GetLineupsParams defines parameters for GetLineups.
type GetLineupsParams struct {
	// Id Provider id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Type Provider type.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Location Location.
	Location *string `form:"location,omitempty" json:"location,omitempty"`

	// Country Country.
	Country *string `form:"country,omitempty" json:"country,omitempty"`
}

// GetLiveTvProgramsParams defines parameters for GetLiveTvPrograms.
type GetLiveTvProgramsParams struct {
	// ChannelIds The channels to return guide information for.
	ChannelIds *[]openapi_types.UUID `form:"channelIds,omitempty" json:"channelIds,omitempty"`

	// UserId Optional. Filter by user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// MinStartDate Optional. The minimum premiere start date.
	MinStartDate *time.Time `form:"minStartDate,omitempty" json:"minStartDate,omitempty"`

	// HasAired Optional. Filter by programs that have completed airing, or not.
	HasAired *bool `form:"hasAired,omitempty" json:"hasAired,omitempty"`

	// IsAiring Optional. Filter by programs that are currently airing, or not.
	IsAiring *bool `form:"isAiring,omitempty" json:"isAiring,omitempty"`

	// MaxStartDate Optional. The maximum premiere start date.
	MaxStartDate *time.Time `form:"maxStartDate,omitempty" json:"maxStartDate,omitempty"`

	// MinEndDate Optional. The minimum premiere end date.
	MinEndDate *time.Time `form:"minEndDate,omitempty" json:"minEndDate,omitempty"`

	// MaxEndDate Optional. The maximum premiere end date.
	MaxEndDate *time.Time `form:"maxEndDate,omitempty" json:"maxEndDate,omitempty"`

	// IsMovie Optional. Filter for movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional. Filter for series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional. Filter for news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional. Filter for kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional. Filter for sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// Genres The genres to return guide information for.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// GenreIds The genre ids to return guide information for.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// SeriesTimerId Optional. Filter by series timer id.
	SeriesTimerId *string `form:"seriesTimerId,omitempty" json:"seriesTimerId,omitempty"`

	// LibrarySeriesId Optional. Filter by library series id.
	LibrarySeriesId *openapi_types.UUID `form:"librarySeriesId,omitempty" json:"librarySeriesId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableTotalRecordCount Retrieve total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetProgramsApplicationWildcardPlusJSONBody defines parameters for GetPrograms.
type GetProgramsApplicationWildcardPlusJSONBody = GetProgramsDto

// GetProgramsJSONBody defines parameters for GetPrograms.
type GetProgramsJSONBody = GetProgramsDto

// GetRecommendedProgramsParams defines parameters for GetRecommendedPrograms.
type GetRecommendedProgramsParams struct {
	// UserId Optional. filter by user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// IsAiring Optional. Filter by programs that are currently airing, or not.
	IsAiring *bool `form:"isAiring,omitempty" json:"isAiring,omitempty"`

	// HasAired Optional. Filter by programs that have completed airing, or not.
	HasAired *bool `form:"hasAired,omitempty" json:"hasAired,omitempty"`

	// IsSeries Optional. Filter for series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsMovie Optional. Filter for movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsNews Optional. Filter for news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional. Filter for kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional. Filter for sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// GenreIds The genres to return guide information for.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableUserData Optional. include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// EnableTotalRecordCount Retrieve total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetProgramParams defines parameters for GetProgram.
type GetProgramParams struct {
	// UserId Optional. Attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetRecordingsParams defines parameters for GetRecordings.
type GetRecordingsParams struct {
	// ChannelId Optional. Filter by channel id.
	ChannelId *string `form:"channelId,omitempty" json:"channelId,omitempty"`

	// UserId Optional. Filter by user and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Optional. Filter by recording status.
	Status *RecordingStatus `form:"status,omitempty" json:"status,omitempty"`

	// IsInProgress Optional. Filter by recordings that are in progress, or not.
	IsInProgress *bool `form:"isInProgress,omitempty" json:"isInProgress,omitempty"`

	// SeriesTimerId Optional. Filter by recordings belonging to a series timer.
	SeriesTimerId *string `form:"seriesTimerId,omitempty" json:"seriesTimerId,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// IsMovie Optional. Filter for movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional. Filter for series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsKids Optional. Filter for kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional. Filter for sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// IsNews Optional. Filter for news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsLibraryItem Optional. Filter for is library item.
	IsLibraryItem *bool `form:"isLibraryItem,omitempty" json:"isLibraryItem,omitempty"`

	// EnableTotalRecordCount Optional. Return total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetRecordingFoldersParams defines parameters for GetRecordingFolders.
type GetRecordingFoldersParams struct {
	// UserId Optional. Filter by user and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetRecordingGroupsParams defines parameters for GetRecordingGroups.
type GetRecordingGroupsParams struct {
	// UserId Optional. Filter by user and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetRecordingsSeriesParams defines parameters for GetRecordingsSeries.
type GetRecordingsSeriesParams struct {
	// ChannelId Optional. Filter by channel id.
	ChannelId *string `form:"channelId,omitempty" json:"channelId,omitempty"`

	// UserId Optional. Filter by user and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// GroupId Optional. Filter by recording group.
	GroupId *string `form:"groupId,omitempty" json:"groupId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Status Optional. Filter by recording status.
	Status *RecordingStatus `form:"status,omitempty" json:"status,omitempty"`

	// IsInProgress Optional. Filter by recordings that are in progress, or not.
	IsInProgress *bool `form:"isInProgress,omitempty" json:"isInProgress,omitempty"`

	// SeriesTimerId Optional. Filter by recordings belonging to a series timer.
	SeriesTimerId *string `form:"seriesTimerId,omitempty" json:"seriesTimerId,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// EnableTotalRecordCount Optional. Return total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetRecordingParams defines parameters for GetRecording.
type GetRecordingParams struct {
	// UserId Optional. Attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetSeriesTimersParams defines parameters for GetSeriesTimers.
type GetSeriesTimersParams struct {
	// SortBy Optional. Sort by SortName or Priority.
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Optional. Sort in Ascending or Descending order.
	SortOrder *SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
}

// CreateSeriesTimerApplicationWildcardPlusJSONBody defines parameters for CreateSeriesTimer.
type CreateSeriesTimerApplicationWildcardPlusJSONBody = SeriesTimerInfoDto

// CreateSeriesTimerJSONBody defines parameters for CreateSeriesTimer.
type CreateSeriesTimerJSONBody = SeriesTimerInfoDto

// UpdateSeriesTimerApplicationWildcardPlusJSONBody defines parameters for UpdateSeriesTimer.
type UpdateSeriesTimerApplicationWildcardPlusJSONBody = SeriesTimerInfoDto

// UpdateSeriesTimerJSONBody defines parameters for UpdateSeriesTimer.
type UpdateSeriesTimerJSONBody = SeriesTimerInfoDto

// GetTimersParams defines parameters for GetTimers.
type GetTimersParams struct {
	// ChannelId Optional. Filter by channel id.
	ChannelId *string `form:"channelId,omitempty" json:"channelId,omitempty"`

	// SeriesTimerId Optional. Filter by timers belonging to a series timer.
	SeriesTimerId *string `form:"seriesTimerId,omitempty" json:"seriesTimerId,omitempty"`

	// IsActive Optional. Filter by timers that are active.
	IsActive *bool `form:"isActive,omitempty" json:"isActive,omitempty"`

	// IsScheduled Optional. Filter by timers that are scheduled.
	IsScheduled *bool `form:"isScheduled,omitempty" json:"isScheduled,omitempty"`
}

// CreateTimerApplicationWildcardPlusJSONBody defines parameters for CreateTimer.
type CreateTimerApplicationWildcardPlusJSONBody = TimerInfoDto

// CreateTimerJSONBody defines parameters for CreateTimer.
type CreateTimerJSONBody = TimerInfoDto

// GetDefaultTimerParams defines parameters for GetDefaultTimer.
type GetDefaultTimerParams struct {
	// ProgramId Optional. To attach default values based on a program.
	ProgramId *string `form:"programId,omitempty" json:"programId,omitempty"`
}

// UpdateTimerApplicationWildcardPlusJSONBody defines parameters for UpdateTimer.
type UpdateTimerApplicationWildcardPlusJSONBody = TimerInfoDto

// UpdateTimerJSONBody defines parameters for UpdateTimer.
type UpdateTimerJSONBody = TimerInfoDto

// DeleteTunerHostParams defines parameters for DeleteTunerHost.
type DeleteTunerHostParams struct {
	// Id Tuner host id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// AddTunerHostApplicationWildcardPlusJSONBody defines parameters for AddTunerHost.
type AddTunerHostApplicationWildcardPlusJSONBody = TunerHostInfo

// AddTunerHostJSONBody defines parameters for AddTunerHost.
type AddTunerHostJSONBody = TunerHostInfo

// DiscoverTunersParams defines parameters for DiscoverTuners.
type DiscoverTunersParams struct {
	// NewDevicesOnly Only discover new tuners.
	NewDevicesOnly *bool `form:"newDevicesOnly,omitempty" json:"newDevicesOnly,omitempty"`
}

// DiscvoverTunersParams defines parameters for DiscvoverTuners.
type DiscvoverTunersParams struct {
	// NewDevicesOnly Only discover new tuners.
	NewDevicesOnly *bool `form:"newDevicesOnly,omitempty" json:"newDevicesOnly,omitempty"`
}

// GetMovieRecommendationsParams defines parameters for GetMovieRecommendations.
type GetMovieRecommendationsParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. The fields to return.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// CategoryLimit The max number of categories to return.
	CategoryLimit *int32 `form:"categoryLimit,omitempty" json:"categoryLimit,omitempty"`

	// ItemLimit The max number of items to return per category.
	ItemLimit *int32 `form:"itemLimit,omitempty" json:"itemLimit,omitempty"`
}

// GetSimilarMoviesParams defines parameters for GetSimilarMovies.
type GetSimilarMoviesParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetMusicGenresParams defines parameters for GetMusicGenres.
type GetMusicGenresParams struct {
	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm The search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableTotalRecordCount Optional. Include total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetInstantMixFromMusicGenreByIdParams defines parameters for GetInstantMixFromMusicGenreById.
type GetInstantMixFromMusicGenreByIdParams struct {
	// Id The item id.
	Id openapi_types.UUID `form:"id" json:"id"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// GetMusicGenreParams defines parameters for GetMusicGenre.
type GetMusicGenreParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetMusicGenreImageParams defines parameters for GetMusicGenreImage.
type GetMusicGenreImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadMusicGenreImageParams defines parameters for HeadMusicGenreImage.
type HeadMusicGenreImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetMusicGenreImageByIndexParams defines parameters for GetMusicGenreImageByIndex.
type GetMusicGenreImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadMusicGenreImageByIndexParams defines parameters for HeadMusicGenreImageByIndex.
type HeadMusicGenreImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// GetInstantMixFromMusicGenreByNameParams defines parameters for GetInstantMixFromMusicGenreByName.
type GetInstantMixFromMusicGenreByNameParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// CreateAdminNotificationApplicationWildcardPlusJSONBody defines parameters for CreateAdminNotification.
type CreateAdminNotificationApplicationWildcardPlusJSONBody = AdminNotificationDto

// CreateAdminNotificationJSONBody defines parameters for CreateAdminNotification.
type CreateAdminNotificationJSONBody = AdminNotificationDto

// InstallPackageParams defines parameters for InstallPackage.
type InstallPackageParams struct {
	// AssemblyGuid GUID of the associated assembly.
	AssemblyGuid *openapi_types.UUID `form:"assemblyGuid,omitempty" json:"assemblyGuid,omitempty"`

	// Version Optional version. Defaults to latest version.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// RepositoryUrl Optional. Specify the repository to install from.
	RepositoryUrl *string `form:"repositoryUrl,omitempty" json:"repositoryUrl,omitempty"`
}

// GetPackageInfoParams defines parameters for GetPackageInfo.
type GetPackageInfoParams struct {
	// AssemblyGuid The GUID of the associated assembly.
	AssemblyGuid *openapi_types.UUID `form:"assemblyGuid,omitempty" json:"assemblyGuid,omitempty"`
}

// GetPersonsParams defines parameters for GetPersons.
type GetPersonsParams struct {
	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm The search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filters Optional. Specify additional filters to apply.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not. userId is required.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// ExcludePersonTypes Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
	ExcludePersonTypes *[]string `form:"excludePersonTypes,omitempty" json:"excludePersonTypes,omitempty"`

	// PersonTypes Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// AppearsInItemId Optional. If specified, person results will be filtered on items related to said persons.
	AppearsInItemId *openapi_types.UUID `form:"appearsInItemId,omitempty" json:"appearsInItemId,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetPersonParams defines parameters for GetPerson.
type GetPersonParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetPersonImageParams defines parameters for GetPersonImage.
type GetPersonImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadPersonImageParams defines parameters for HeadPersonImage.
type HeadPersonImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetPersonImageByIndexParams defines parameters for GetPersonImageByIndex.
type GetPersonImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadPersonImageByIndexParams defines parameters for HeadPersonImageByIndex.
type HeadPersonImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// GetBitrateTestBytesParams defines parameters for GetBitrateTestBytes.
type GetBitrateTestBytesParams struct {
	// Size The bitrate. Defaults to 102400.
	Size *int32 `form:"size,omitempty" json:"size,omitempty"`
}

// CreatePlaylistApplicationWildcardPlusJSONBody defines parameters for CreatePlaylist.
type CreatePlaylistApplicationWildcardPlusJSONBody = CreatePlaylistDto

// CreatePlaylistJSONBody defines parameters for CreatePlaylist.
type CreatePlaylistJSONBody = CreatePlaylistDto

// CreatePlaylistParams defines parameters for CreatePlaylist.
type CreatePlaylistParams struct {
	// Name The playlist name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Ids The item ids.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// MediaType The media type.
	MediaType *string `form:"mediaType,omitempty" json:"mediaType,omitempty"`
}

// GetInstantMixFromPlaylistParams defines parameters for GetInstantMixFromPlaylist.
type GetInstantMixFromPlaylistParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// RemoveFromPlaylistParams defines parameters for RemoveFromPlaylist.
type RemoveFromPlaylistParams struct {
	// EntryIds The item ids, comma delimited.
	EntryIds *[]string `form:"entryIds,omitempty" json:"entryIds,omitempty"`
}

// GetPlaylistItemsParams defines parameters for GetPlaylistItems.
type GetPlaylistItemsParams struct {
	// UserId User id.
	UserId openapi_types.UUID `form:"userId" json:"userId"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// AddToPlaylistParams defines parameters for AddToPlaylist.
type AddToPlaylistParams struct {
	// Ids Item id, comma delimited.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// UserId The userId.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// Code Quick connect code to authorize.
	Code string `form:"code" json:"code"`
}

// ConnectParams defines parameters for Connect.
type ConnectParams struct {
	// Secret Secret previously returned from the Initiate endpoint.
	Secret string `form:"secret" json:"secret"`
}

// GetActivityLogsParams defines parameters for GetActivityLogs.
type GetActivityLogsParams struct {
	ReportView       *string `form:"reportView,omitempty" json:"reportView,omitempty"`
	DisplayType      *string `form:"displayType,omitempty" json:"displayType,omitempty"`
	HasQueryLimit    *bool   `form:"hasQueryLimit,omitempty" json:"hasQueryLimit,omitempty"`
	GroupBy          *string `form:"groupBy,omitempty" json:"groupBy,omitempty"`
	ReportColumns    *string `form:"reportColumns,omitempty" json:"reportColumns,omitempty"`
	StartIndex       *int32  `form:"startIndex,omitempty" json:"startIndex,omitempty"`
	Limit            *int32  `form:"limit,omitempty" json:"limit,omitempty"`
	MinDate          *string `form:"minDate,omitempty" json:"minDate,omitempty"`
	IncludeItemTypes *string `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`
}

// GetReportHeadersParams defines parameters for GetReportHeaders.
type GetReportHeadersParams struct {
	ReportView       *string `form:"reportView,omitempty" json:"reportView,omitempty"`
	IncludeItemTypes *string `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`
}

// GetItemReportParams defines parameters for GetItemReport.
type GetItemReportParams struct {
	HasThemeSong            *bool    `form:"hasThemeSong,omitempty" json:"hasThemeSong,omitempty"`
	HasThemeVideo           *bool    `form:"hasThemeVideo,omitempty" json:"hasThemeVideo,omitempty"`
	HasSubtitles            *bool    `form:"hasSubtitles,omitempty" json:"hasSubtitles,omitempty"`
	HasSpecialFeature       *bool    `form:"hasSpecialFeature,omitempty" json:"hasSpecialFeature,omitempty"`
	HasTrailer              *bool    `form:"hasTrailer,omitempty" json:"hasTrailer,omitempty"`
	AdjacentTo              *string  `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`
	MinIndexNumber          *int32   `form:"minIndexNumber,omitempty" json:"minIndexNumber,omitempty"`
	ParentIndexNumber       *int32   `form:"parentIndexNumber,omitempty" json:"parentIndexNumber,omitempty"`
	HasParentalRating       *bool    `form:"hasParentalRating,omitempty" json:"hasParentalRating,omitempty"`
	IsHd                    *bool    `form:"isHd,omitempty" json:"isHd,omitempty"`
	LocationTypes           *string  `form:"locationTypes,omitempty" json:"locationTypes,omitempty"`
	ExcludeLocationTypes    *string  `form:"excludeLocationTypes,omitempty" json:"excludeLocationTypes,omitempty"`
	IsMissing               *bool    `form:"isMissing,omitempty" json:"isMissing,omitempty"`
	IsUnaried               *bool    `form:"isUnaried,omitempty" json:"isUnaried,omitempty"`
	MinCommunityRating      *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`
	MinCriticRating         *float64 `form:"minCriticRating,omitempty" json:"minCriticRating,omitempty"`
	AiredDuringSeason       *int32   `form:"airedDuringSeason,omitempty" json:"airedDuringSeason,omitempty"`
	MinPremiereDate         *string  `form:"minPremiereDate,omitempty" json:"minPremiereDate,omitempty"`
	MinDateLastSaved        *string  `form:"minDateLastSaved,omitempty" json:"minDateLastSaved,omitempty"`
	MinDateLastSavedForUser *string  `form:"minDateLastSavedForUser,omitempty" json:"minDateLastSavedForUser,omitempty"`
	MaxPremiereDate         *string  `form:"maxPremiereDate,omitempty" json:"maxPremiereDate,omitempty"`
	HasOverview             *bool    `form:"hasOverview,omitempty" json:"hasOverview,omitempty"`
	HasImdbId               *bool    `form:"hasImdbId,omitempty" json:"hasImdbId,omitempty"`
	HasTmdbId               *bool    `form:"hasTmdbId,omitempty" json:"hasTmdbId,omitempty"`
	HasTvdbId               *bool    `form:"hasTvdbId,omitempty" json:"hasTvdbId,omitempty"`
	IsInBoxSet              *bool    `form:"isInBoxSet,omitempty" json:"isInBoxSet,omitempty"`
	ExcludeItemIds          *string  `form:"excludeItemIds,omitempty" json:"excludeItemIds,omitempty"`
	EnableTotalRecordCount  *bool    `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
	StartIndex              *int32   `form:"startIndex,omitempty" json:"startIndex,omitempty"`
	Limit                   *int32   `form:"limit,omitempty" json:"limit,omitempty"`
	Recursive               *bool    `form:"recursive,omitempty" json:"recursive,omitempty"`
	SortOrder               *string  `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ParentId                *string  `form:"parentId,omitempty" json:"parentId,omitempty"`
	Fields                  *string  `form:"fields,omitempty" json:"fields,omitempty"`
	ExcludeItemTypes        *string  `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`
	IncludeItemTypes        *string  `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`
	Filters                 *string  `form:"filters,omitempty" json:"filters,omitempty"`
	IsFavorite              *bool    `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`
	IsNotFavorite           *bool    `form:"isNotFavorite,omitempty" json:"isNotFavorite,omitempty"`
	MediaTypes              *string  `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`
	ImageTypes              *string  `form:"imageTypes,omitempty" json:"imageTypes,omitempty"`
	SortBy                  *string  `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	IsPlayed                *bool    `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`
	Genres                  *string  `form:"genres,omitempty" json:"genres,omitempty"`
	GenreIds                *string  `form:"genreIds,omitempty" json:"genreIds,omitempty"`
	OfficialRatings         *string  `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`
	Tags                    *string  `form:"tags,omitempty" json:"tags,omitempty"`
	Years                   *string  `form:"years,omitempty" json:"years,omitempty"`
	EnableUserData          *bool    `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`
	ImageTypeLimit          *int32   `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`
	EnableImageTypes        *string  `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
	Person                  *string  `form:"person,omitempty" json:"person,omitempty"`
	PersonIds               *string  `form:"personIds,omitempty" json:"personIds,omitempty"`
	PersonTypes             *string  `form:"personTypes,omitempty" json:"personTypes,omitempty"`
	Studios                 *string  `form:"studios,omitempty" json:"studios,omitempty"`
	StudioIds               *string  `form:"studioIds,omitempty" json:"studioIds,omitempty"`
	Artists                 *string  `form:"artists,omitempty" json:"artists,omitempty"`
	ExcludeArtistIds        *string  `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`
	ArtistIds               *string  `form:"artistIds,omitempty" json:"artistIds,omitempty"`
	Albums                  *string  `form:"albums,omitempty" json:"albums,omitempty"`
	AlbumIds                *string  `form:"albumIds,omitempty" json:"albumIds,omitempty"`
	Ids                     *string  `form:"ids,omitempty" json:"ids,omitempty"`
	VideoTypes              *string  `form:"videoTypes,omitempty" json:"videoTypes,omitempty"`
	UserId                  *string  `form:"userId,omitempty" json:"userId,omitempty"`
	MinOfficialRating       *string  `form:"minOfficialRating,omitempty" json:"minOfficialRating,omitempty"`
	IsLocked                *bool    `form:"isLocked,omitempty" json:"isLocked,omitempty"`
	IsPlaceHolder           *bool    `form:"isPlaceHolder,omitempty" json:"isPlaceHolder,omitempty"`
	HasOfficialRating       *bool    `form:"hasOfficialRating,omitempty" json:"hasOfficialRating,omitempty"`
	CollapseBoxSetItems     *bool    `form:"collapseBoxSetItems,omitempty" json:"collapseBoxSetItems,omitempty"`
	Is3D                    *bool    `form:"is3D,omitempty" json:"is3D,omitempty"`
	SeriesStatus            *string  `form:"seriesStatus,omitempty" json:"seriesStatus,omitempty"`
	NameStartsWithOrGreater *string  `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`
	NameStartsWith          *string  `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`
	NameLessThan            *string  `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`
	ReportView              *string  `form:"reportView,omitempty" json:"reportView,omitempty"`
	DisplayType             *string  `form:"displayType,omitempty" json:"displayType,omitempty"`
	HasQueryLimit           *bool    `form:"hasQueryLimit,omitempty" json:"hasQueryLimit,omitempty"`
	GroupBy                 *string  `form:"groupBy,omitempty" json:"groupBy,omitempty"`
	ReportColumns           *string  `form:"reportColumns,omitempty" json:"reportColumns,omitempty"`
	EnableImages            *bool    `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetReportDownloadParams defines parameters for GetReportDownload.
type GetReportDownloadParams struct {
	HasThemeSong            *bool             `form:"hasThemeSong,omitempty" json:"hasThemeSong,omitempty"`
	HasThemeVideo           *bool             `form:"hasThemeVideo,omitempty" json:"hasThemeVideo,omitempty"`
	HasSubtitles            *bool             `form:"hasSubtitles,omitempty" json:"hasSubtitles,omitempty"`
	HasSpecialFeature       *bool             `form:"hasSpecialFeature,omitempty" json:"hasSpecialFeature,omitempty"`
	HasTrailer              *bool             `form:"hasTrailer,omitempty" json:"hasTrailer,omitempty"`
	AdjacentTo              *string           `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`
	MinIndexNumber          *int32            `form:"minIndexNumber,omitempty" json:"minIndexNumber,omitempty"`
	ParentIndexNumber       *int32            `form:"parentIndexNumber,omitempty" json:"parentIndexNumber,omitempty"`
	HasParentalRating       *bool             `form:"hasParentalRating,omitempty" json:"hasParentalRating,omitempty"`
	IsHd                    *bool             `form:"isHd,omitempty" json:"isHd,omitempty"`
	LocationTypes           *string           `form:"locationTypes,omitempty" json:"locationTypes,omitempty"`
	ExcludeLocationTypes    *string           `form:"excludeLocationTypes,omitempty" json:"excludeLocationTypes,omitempty"`
	IsMissing               *bool             `form:"isMissing,omitempty" json:"isMissing,omitempty"`
	IsUnaried               *bool             `form:"isUnaried,omitempty" json:"isUnaried,omitempty"`
	MinCommunityRating      *float64          `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`
	MinCriticRating         *float64          `form:"minCriticRating,omitempty" json:"minCriticRating,omitempty"`
	AiredDuringSeason       *int32            `form:"airedDuringSeason,omitempty" json:"airedDuringSeason,omitempty"`
	MinPremiereDate         *string           `form:"minPremiereDate,omitempty" json:"minPremiereDate,omitempty"`
	MinDateLastSaved        *string           `form:"minDateLastSaved,omitempty" json:"minDateLastSaved,omitempty"`
	MinDateLastSavedForUser *string           `form:"minDateLastSavedForUser,omitempty" json:"minDateLastSavedForUser,omitempty"`
	MaxPremiereDate         *string           `form:"maxPremiereDate,omitempty" json:"maxPremiereDate,omitempty"`
	HasOverview             *bool             `form:"hasOverview,omitempty" json:"hasOverview,omitempty"`
	HasImdbId               *bool             `form:"hasImdbId,omitempty" json:"hasImdbId,omitempty"`
	HasTmdbId               *bool             `form:"hasTmdbId,omitempty" json:"hasTmdbId,omitempty"`
	HasTvdbId               *bool             `form:"hasTvdbId,omitempty" json:"hasTvdbId,omitempty"`
	IsInBoxSet              *bool             `form:"isInBoxSet,omitempty" json:"isInBoxSet,omitempty"`
	ExcludeItemIds          *string           `form:"excludeItemIds,omitempty" json:"excludeItemIds,omitempty"`
	EnableTotalRecordCount  *bool             `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
	StartIndex              *int32            `form:"startIndex,omitempty" json:"startIndex,omitempty"`
	Limit                   *int32            `form:"limit,omitempty" json:"limit,omitempty"`
	Recursive               *bool             `form:"recursive,omitempty" json:"recursive,omitempty"`
	SortOrder               *string           `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ParentId                *string           `form:"parentId,omitempty" json:"parentId,omitempty"`
	Fields                  *string           `form:"fields,omitempty" json:"fields,omitempty"`
	ExcludeItemTypes        *string           `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`
	IncludeItemTypes        *string           `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`
	Filters                 *string           `form:"filters,omitempty" json:"filters,omitempty"`
	IsFavorite              *bool             `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`
	IsNotFavorite           *bool             `form:"isNotFavorite,omitempty" json:"isNotFavorite,omitempty"`
	MediaTypes              *string           `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`
	ImageTypes              *string           `form:"imageTypes,omitempty" json:"imageTypes,omitempty"`
	SortBy                  *string           `form:"sortBy,omitempty" json:"sortBy,omitempty"`
	IsPlayed                *bool             `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`
	Genres                  *string           `form:"genres,omitempty" json:"genres,omitempty"`
	GenreIds                *string           `form:"genreIds,omitempty" json:"genreIds,omitempty"`
	OfficialRatings         *string           `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`
	Tags                    *string           `form:"tags,omitempty" json:"tags,omitempty"`
	Years                   *string           `form:"years,omitempty" json:"years,omitempty"`
	EnableUserData          *bool             `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`
	ImageTypeLimit          *int32            `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`
	EnableImageTypes        *string           `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
	Person                  *string           `form:"person,omitempty" json:"person,omitempty"`
	PersonIds               *string           `form:"personIds,omitempty" json:"personIds,omitempty"`
	PersonTypes             *string           `form:"personTypes,omitempty" json:"personTypes,omitempty"`
	Studios                 *string           `form:"studios,omitempty" json:"studios,omitempty"`
	StudioIds               *string           `form:"studioIds,omitempty" json:"studioIds,omitempty"`
	Artists                 *string           `form:"artists,omitempty" json:"artists,omitempty"`
	ExcludeArtistIds        *string           `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`
	ArtistIds               *string           `form:"artistIds,omitempty" json:"artistIds,omitempty"`
	Albums                  *string           `form:"albums,omitempty" json:"albums,omitempty"`
	AlbumIds                *string           `form:"albumIds,omitempty" json:"albumIds,omitempty"`
	Ids                     *string           `form:"ids,omitempty" json:"ids,omitempty"`
	VideoTypes              *string           `form:"videoTypes,omitempty" json:"videoTypes,omitempty"`
	UserId                  *string           `form:"userId,omitempty" json:"userId,omitempty"`
	MinOfficialRating       *string           `form:"minOfficialRating,omitempty" json:"minOfficialRating,omitempty"`
	IsLocked                *bool             `form:"isLocked,omitempty" json:"isLocked,omitempty"`
	IsPlaceHolder           *bool             `form:"isPlaceHolder,omitempty" json:"isPlaceHolder,omitempty"`
	HasOfficialRating       *bool             `form:"hasOfficialRating,omitempty" json:"hasOfficialRating,omitempty"`
	CollapseBoxSetItems     *bool             `form:"collapseBoxSetItems,omitempty" json:"collapseBoxSetItems,omitempty"`
	Is3D                    *bool             `form:"is3D,omitempty" json:"is3D,omitempty"`
	SeriesStatus            *string           `form:"seriesStatus,omitempty" json:"seriesStatus,omitempty"`
	NameStartsWithOrGreater *string           `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`
	NameStartsWith          *string           `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`
	NameLessThan            *string           `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`
	ReportView              *string           `form:"reportView,omitempty" json:"reportView,omitempty"`
	DisplayType             *string           `form:"displayType,omitempty" json:"displayType,omitempty"`
	HasQueryLimit           *bool             `form:"hasQueryLimit,omitempty" json:"hasQueryLimit,omitempty"`
	GroupBy                 *string           `form:"groupBy,omitempty" json:"groupBy,omitempty"`
	ReportColumns           *string           `form:"reportColumns,omitempty" json:"reportColumns,omitempty"`
	MinDate                 *string           `form:"minDate,omitempty" json:"minDate,omitempty"`
	ExportType              *ReportExportType `form:"exportType,omitempty" json:"exportType,omitempty"`
	EnableImages            *bool             `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// SetRepositoriesApplicationWildcardPlusJSONBody defines parameters for SetRepositories.
type SetRepositoriesApplicationWildcardPlusJSONBody = []RepositoryInfo

// SetRepositoriesJSONBody defines parameters for SetRepositories.
type SetRepositoriesJSONBody = []RepositoryInfo

// GetTasksParams defines parameters for GetTasks.
type GetTasksParams struct {
	// IsHidden Optional filter tasks that are hidden, or not.
	IsHidden *bool `form:"isHidden,omitempty" json:"isHidden,omitempty"`

	// IsEnabled Optional filter tasks that are enabled, or not.
	IsEnabled *bool `form:"isEnabled,omitempty" json:"isEnabled,omitempty"`
}

// UpdateTaskApplicationWildcardPlusJSONBody defines parameters for UpdateTask.
type UpdateTaskApplicationWildcardPlusJSONBody = []TaskTriggerInfo

// UpdateTaskJSONBody defines parameters for UpdateTask.
type UpdateTaskJSONBody = []TaskTriggerInfo

// GetParams defines parameters for Get.
type GetParams struct {
	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// UserId Optional. Supply a user id to search within a user's library or omit to search all.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// SearchTerm The search term to filter on.
	SearchTerm string `form:"searchTerm" json:"searchTerm"`

	// IncludeItemTypes If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// ExcludeItemTypes If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// MediaTypes If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// ParentId If specified, only children of the parent are returned.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// IsMovie Optional filter for movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional filter for series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional filter for news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional filter for kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional filter for sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// IncludePeople Optional filter whether to include people.
	IncludePeople *bool `form:"includePeople,omitempty" json:"includePeople,omitempty"`

	// IncludeMedia Optional filter whether to include media.
	IncludeMedia *bool `form:"includeMedia,omitempty" json:"includeMedia,omitempty"`

	// IncludeGenres Optional filter whether to include genres.
	IncludeGenres *bool `form:"includeGenres,omitempty" json:"includeGenres,omitempty"`

	// IncludeStudios Optional filter whether to include studios.
	IncludeStudios *bool `form:"includeStudios,omitempty" json:"includeStudios,omitempty"`

	// IncludeArtists Optional filter whether to include artists.
	IncludeArtists *bool `form:"includeArtists,omitempty" json:"includeArtists,omitempty"`
}

// GetSessionsParams defines parameters for GetSessions.
type GetSessionsParams struct {
	// ControllableByUserId Filter by sessions that a given user is allowed to remote control.
	ControllableByUserId *openapi_types.UUID `form:"controllableByUserId,omitempty" json:"controllableByUserId,omitempty"`

	// DeviceId Filter by device Id.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// ActiveWithinSeconds Optional. Filter by sessions that were active in the last n seconds.
	ActiveWithinSeconds *int32 `form:"activeWithinSeconds,omitempty" json:"activeWithinSeconds,omitempty"`
}

// PostCapabilitiesParams defines parameters for PostCapabilities.
type PostCapabilitiesParams struct {
	// Id The session id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// PlayableMediaTypes A list of playable media types, comma delimited. Audio, Video, Book, Photo.
	PlayableMediaTypes *[]string `form:"playableMediaTypes,omitempty" json:"playableMediaTypes,omitempty"`

	// SupportedCommands A list of supported remote control commands, comma delimited.
	SupportedCommands *[]GeneralCommandType `form:"supportedCommands,omitempty" json:"supportedCommands,omitempty"`

	// SupportsMediaControl Determines whether media can be played remotely..
	SupportsMediaControl *bool `form:"supportsMediaControl,omitempty" json:"supportsMediaControl,omitempty"`

	// SupportsSync Determines whether sync is supported.
	SupportsSync *bool `form:"supportsSync,omitempty" json:"supportsSync,omitempty"`

	// SupportsPersistentIdentifier Determines whether the device supports a unique identifier.
	SupportsPersistentIdentifier *bool `form:"supportsPersistentIdentifier,omitempty" json:"supportsPersistentIdentifier,omitempty"`
}

// PostFullCapabilitiesApplicationWildcardPlusJSONBody defines parameters for PostFullCapabilities.
type PostFullCapabilitiesApplicationWildcardPlusJSONBody = ClientCapabilitiesDto

// PostFullCapabilitiesJSONBody defines parameters for PostFullCapabilities.
type PostFullCapabilitiesJSONBody = ClientCapabilitiesDto

// PostFullCapabilitiesParams defines parameters for PostFullCapabilities.
type PostFullCapabilitiesParams struct {
	// Id The session id.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// ReportPlaybackStartApplicationWildcardPlusJSONBody defines parameters for ReportPlaybackStart.
type ReportPlaybackStartApplicationWildcardPlusJSONBody = PlaybackStartInfo

// ReportPlaybackStartJSONBody defines parameters for ReportPlaybackStart.
type ReportPlaybackStartJSONBody = PlaybackStartInfo

// PingPlaybackSessionParams defines parameters for PingPlaybackSession.
type PingPlaybackSessionParams struct {
	// PlaySessionId Playback session id.
	PlaySessionId string `form:"playSessionId" json:"playSessionId"`
}

// ReportPlaybackProgressApplicationWildcardPlusJSONBody defines parameters for ReportPlaybackProgress.
type ReportPlaybackProgressApplicationWildcardPlusJSONBody = PlaybackProgressInfo

// ReportPlaybackProgressJSONBody defines parameters for ReportPlaybackProgress.
type ReportPlaybackProgressJSONBody = PlaybackProgressInfo

// ReportPlaybackStoppedApplicationWildcardPlusJSONBody defines parameters for ReportPlaybackStopped.
type ReportPlaybackStoppedApplicationWildcardPlusJSONBody = PlaybackStopInfo

// ReportPlaybackStoppedJSONBody defines parameters for ReportPlaybackStopped.
type ReportPlaybackStoppedJSONBody = PlaybackStopInfo

// ReportViewingParams defines parameters for ReportViewing.
type ReportViewingParams struct {
	// SessionId The session id.
	SessionId *string `form:"sessionId,omitempty" json:"sessionId,omitempty"`

	// ItemId The item id.
	ItemId string `form:"itemId" json:"itemId"`
}

// SendFullGeneralCommandApplicationWildcardPlusJSONBody defines parameters for SendFullGeneralCommand.
type SendFullGeneralCommandApplicationWildcardPlusJSONBody = GeneralCommand

// SendFullGeneralCommandJSONBody defines parameters for SendFullGeneralCommand.
type SendFullGeneralCommandJSONBody = GeneralCommand

// SendMessageCommandApplicationWildcardPlusJSONBody defines parameters for SendMessageCommand.
type SendMessageCommandApplicationWildcardPlusJSONBody = MessageCommand

// SendMessageCommandJSONBody defines parameters for SendMessageCommand.
type SendMessageCommandJSONBody = MessageCommand

// PlayParams defines parameters for Play.
type PlayParams struct {
	// PlayCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
	PlayCommand PlayCommand `form:"playCommand" json:"playCommand"`

	// ItemIds The ids of the items to play, comma delimited.
	ItemIds []openapi_types.UUID `form:"itemIds" json:"itemIds"`

	// StartPositionTicks The starting position of the first item.
	StartPositionTicks *int64 `form:"startPositionTicks,omitempty" json:"startPositionTicks,omitempty"`

	// MediaSourceId Optional. The media source id.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to play.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to play.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// StartIndex Optional. The start index.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`
}

// SendPlaystateCommandParams defines parameters for SendPlaystateCommand.
type SendPlaystateCommandParams struct {
	// SeekPositionTicks The optional position ticks.
	SeekPositionTicks *int64 `form:"seekPositionTicks,omitempty" json:"seekPositionTicks,omitempty"`

	// ControllingUserId The optional controlling user id.
	ControllingUserId *string `form:"controllingUserId,omitempty" json:"controllingUserId,omitempty"`
}

// DisplayContentParams defines parameters for DisplayContent.
type DisplayContentParams struct {
	// ItemType The type of item to browse to.
	ItemType BaseItemKind `form:"itemType" json:"itemType"`

	// ItemId The Id of the item.
	ItemId string `form:"itemId" json:"itemId"`

	// ItemName The name of the item.
	ItemName string `form:"itemName" json:"itemName"`
}

// GetNextUpParams defines parameters for GetNextUp.
type GetNextUpParams struct {
	// UserId The user id of the user to get the next up episodes for.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// SeriesId Optional. Filter by series id.
	SeriesId *string `form:"seriesId,omitempty" json:"seriesId,omitempty"`

	// ParentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// NextUpDateCutoff Optional. Starting date of shows to show in Next Up section.
	NextUpDateCutoff *time.Time `form:"nextUpDateCutoff,omitempty" json:"nextUpDateCutoff,omitempty"`

	// EnableTotalRecordCount Whether to enable the total records count. Defaults to true.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`

	// DisableFirstEpisode Whether to disable sending the first episode in a series as next up.
	DisableFirstEpisode *bool `form:"disableFirstEpisode,omitempty" json:"disableFirstEpisode,omitempty"`

	// EnableRewatching Whether to include watched episode in next up results.
	EnableRewatching *bool `form:"enableRewatching,omitempty" json:"enableRewatching,omitempty"`
}

// GetUpcomingEpisodesParams defines parameters for GetUpcomingEpisodes.
type GetUpcomingEpisodesParams struct {
	// UserId The user id of the user to get the upcoming episodes for.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ParentId Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`
}

// GetSimilarShowsParams defines parameters for GetSimilarShows.
type GetSimilarShowsParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetEpisodesParams defines parameters for GetEpisodes.
type GetEpisodesParams struct {
	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// Season Optional filter by season number.
	Season *int32 `form:"season,omitempty" json:"season,omitempty"`

	// SeasonId Optional. Filter by season id.
	SeasonId *openapi_types.UUID `form:"seasonId,omitempty" json:"seasonId,omitempty"`

	// IsMissing Optional. Filter by items that are missing episodes or not.
	IsMissing *bool `form:"isMissing,omitempty" json:"isMissing,omitempty"`

	// AdjacentTo Optional. Return items that are siblings of a supplied item.
	AdjacentTo *string `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`

	// StartItemId Optional. Skip through the list until a given item is found.
	StartItemId *openapi_types.UUID `form:"startItemId,omitempty" json:"startItemId,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`
}

// GetSeasonsParams defines parameters for GetSeasons.
type GetSeasonsParams struct {
	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// IsSpecialSeason Optional. Filter by special season.
	IsSpecialSeason *bool `form:"isSpecialSeason,omitempty" json:"isSpecialSeason,omitempty"`

	// IsMissing Optional. Filter by items that are missing episodes or not.
	IsMissing *bool `form:"isMissing,omitempty" json:"isMissing,omitempty"`

	// AdjacentTo Optional. Return items that are siblings of a supplied item.
	AdjacentTo *string `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`
}

// GetInstantMixFromSongParams defines parameters for GetInstantMixFromSong.
type GetInstantMixFromSongParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`
}

// UpdateInitialConfigurationApplicationWildcardPlusJSONBody defines parameters for UpdateInitialConfiguration.
type UpdateInitialConfigurationApplicationWildcardPlusJSONBody = StartupConfigurationDto

// UpdateInitialConfigurationJSONBody defines parameters for UpdateInitialConfiguration.
type UpdateInitialConfigurationJSONBody = StartupConfigurationDto

// SetRemoteAccessApplicationWildcardPlusJSONBody defines parameters for SetRemoteAccess.
type SetRemoteAccessApplicationWildcardPlusJSONBody = StartupRemoteAccessDto

// SetRemoteAccessJSONBody defines parameters for SetRemoteAccess.
type SetRemoteAccessJSONBody = StartupRemoteAccessDto

// UpdateStartupUserApplicationWildcardPlusJSONBody defines parameters for UpdateStartupUser.
type UpdateStartupUserApplicationWildcardPlusJSONBody = StartupUserDto

// UpdateStartupUserJSONBody defines parameters for UpdateStartupUser.
type UpdateStartupUserJSONBody = StartupUserDto

// GetStudiosParams defines parameters for GetStudios.
type GetStudiosParams struct {
	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm Optional. Search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// UserId User id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// EnableTotalRecordCount Total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetStudioParams defines parameters for GetStudio.
type GetStudioParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetStudioImageParams defines parameters for GetStudioImage.
type GetStudioImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadStudioImageParams defines parameters for HeadStudioImage.
type HeadStudioImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// GetStudioImageByIndexParams defines parameters for GetStudioImageByIndex.
type GetStudioImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadStudioImageByIndexParams defines parameters for HeadStudioImageByIndex.
type HeadStudioImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// SyncPlayBufferingApplicationWildcardPlusJSONBody defines parameters for SyncPlayBuffering.
type SyncPlayBufferingApplicationWildcardPlusJSONBody = BufferRequestDto

// SyncPlayBufferingJSONBody defines parameters for SyncPlayBuffering.
type SyncPlayBufferingJSONBody = BufferRequestDto

// SyncPlayJoinGroupApplicationWildcardPlusJSONBody defines parameters for SyncPlayJoinGroup.
type SyncPlayJoinGroupApplicationWildcardPlusJSONBody = JoinGroupRequestDto

// SyncPlayJoinGroupJSONBody defines parameters for SyncPlayJoinGroup.
type SyncPlayJoinGroupJSONBody = JoinGroupRequestDto

// SyncPlayMovePlaylistItemApplicationWildcardPlusJSONBody defines parameters for SyncPlayMovePlaylistItem.
type SyncPlayMovePlaylistItemApplicationWildcardPlusJSONBody = MovePlaylistItemRequestDto

// SyncPlayMovePlaylistItemJSONBody defines parameters for SyncPlayMovePlaylistItem.
type SyncPlayMovePlaylistItemJSONBody = MovePlaylistItemRequestDto

// SyncPlayCreateGroupApplicationWildcardPlusJSONBody defines parameters for SyncPlayCreateGroup.
type SyncPlayCreateGroupApplicationWildcardPlusJSONBody = NewGroupRequestDto

// SyncPlayCreateGroupJSONBody defines parameters for SyncPlayCreateGroup.
type SyncPlayCreateGroupJSONBody = NewGroupRequestDto

// SyncPlayNextItemApplicationWildcardPlusJSONBody defines parameters for SyncPlayNextItem.
type SyncPlayNextItemApplicationWildcardPlusJSONBody = NextItemRequestDto

// SyncPlayNextItemJSONBody defines parameters for SyncPlayNextItem.
type SyncPlayNextItemJSONBody = NextItemRequestDto

// SyncPlayPingApplicationWildcardPlusJSONBody defines parameters for SyncPlayPing.
type SyncPlayPingApplicationWildcardPlusJSONBody = PingRequestDto

// SyncPlayPingJSONBody defines parameters for SyncPlayPing.
type SyncPlayPingJSONBody = PingRequestDto

// SyncPlayPreviousItemApplicationWildcardPlusJSONBody defines parameters for SyncPlayPreviousItem.
type SyncPlayPreviousItemApplicationWildcardPlusJSONBody = PreviousItemRequestDto

// SyncPlayPreviousItemJSONBody defines parameters for SyncPlayPreviousItem.
type SyncPlayPreviousItemJSONBody = PreviousItemRequestDto

// SyncPlayQueueApplicationWildcardPlusJSONBody defines parameters for SyncPlayQueue.
type SyncPlayQueueApplicationWildcardPlusJSONBody = QueueRequestDto

// SyncPlayQueueJSONBody defines parameters for SyncPlayQueue.
type SyncPlayQueueJSONBody = QueueRequestDto

// SyncPlayReadyApplicationWildcardPlusJSONBody defines parameters for SyncPlayReady.
type SyncPlayReadyApplicationWildcardPlusJSONBody = ReadyRequestDto

// SyncPlayReadyJSONBody defines parameters for SyncPlayReady.
type SyncPlayReadyJSONBody = ReadyRequestDto

// SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONBody defines parameters for SyncPlayRemoveFromPlaylist.
type SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONBody = RemoveFromPlaylistRequestDto

// SyncPlayRemoveFromPlaylistJSONBody defines parameters for SyncPlayRemoveFromPlaylist.
type SyncPlayRemoveFromPlaylistJSONBody = RemoveFromPlaylistRequestDto

// SyncPlaySeekApplicationWildcardPlusJSONBody defines parameters for SyncPlaySeek.
type SyncPlaySeekApplicationWildcardPlusJSONBody = SeekRequestDto

// SyncPlaySeekJSONBody defines parameters for SyncPlaySeek.
type SyncPlaySeekJSONBody = SeekRequestDto

// SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONBody defines parameters for SyncPlaySetIgnoreWait.
type SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONBody = IgnoreWaitRequestDto

// SyncPlaySetIgnoreWaitJSONBody defines parameters for SyncPlaySetIgnoreWait.
type SyncPlaySetIgnoreWaitJSONBody = IgnoreWaitRequestDto

// SyncPlaySetNewQueueApplicationWildcardPlusJSONBody defines parameters for SyncPlaySetNewQueue.
type SyncPlaySetNewQueueApplicationWildcardPlusJSONBody = PlayRequestDto

// SyncPlaySetNewQueueJSONBody defines parameters for SyncPlaySetNewQueue.
type SyncPlaySetNewQueueJSONBody = PlayRequestDto

// SyncPlaySetPlaylistItemApplicationWildcardPlusJSONBody defines parameters for SyncPlaySetPlaylistItem.
type SyncPlaySetPlaylistItemApplicationWildcardPlusJSONBody = SetPlaylistItemRequestDto

// SyncPlaySetPlaylistItemJSONBody defines parameters for SyncPlaySetPlaylistItem.
type SyncPlaySetPlaylistItemJSONBody = SetPlaylistItemRequestDto

// SyncPlaySetRepeatModeApplicationWildcardPlusJSONBody defines parameters for SyncPlaySetRepeatMode.
type SyncPlaySetRepeatModeApplicationWildcardPlusJSONBody = SetRepeatModeRequestDto

// SyncPlaySetRepeatModeJSONBody defines parameters for SyncPlaySetRepeatMode.
type SyncPlaySetRepeatModeJSONBody = SetRepeatModeRequestDto

// SyncPlaySetShuffleModeApplicationWildcardPlusJSONBody defines parameters for SyncPlaySetShuffleMode.
type SyncPlaySetShuffleModeApplicationWildcardPlusJSONBody = SetShuffleModeRequestDto

// SyncPlaySetShuffleModeJSONBody defines parameters for SyncPlaySetShuffleMode.
type SyncPlaySetShuffleModeJSONBody = SetShuffleModeRequestDto

// GetLogEntriesParams defines parameters for GetLogEntries.
type GetLogEntriesParams struct {
	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// MinDate Optional. The minimum date. Format = ISO.
	MinDate *time.Time `form:"minDate,omitempty" json:"minDate,omitempty"`

	// HasUserId Optional. Filter log entries if it has user id, or not.
	HasUserId *bool `form:"hasUserId,omitempty" json:"hasUserId,omitempty"`
}

// UpdateConfigurationApplicationWildcardPlusJSONBody defines parameters for UpdateConfiguration.
type UpdateConfigurationApplicationWildcardPlusJSONBody = ServerConfiguration

// UpdateConfigurationJSONBody defines parameters for UpdateConfiguration.
type UpdateConfigurationJSONBody = ServerConfiguration

// UpdateNamedConfigurationApplicationWildcardPlusJSONBody defines parameters for UpdateNamedConfiguration.
type UpdateNamedConfigurationApplicationWildcardPlusJSONBody = interface{}

// UpdateNamedConfigurationJSONBody defines parameters for UpdateNamedConfiguration.
type UpdateNamedConfigurationJSONBody = interface{}

// GetLogFileParams defines parameters for GetLogFile.
type GetLogFileParams struct {
	// Name The name of the log file to get.
	Name string `form:"name" json:"name"`
}

// UpdateMediaEncoderPathApplicationWildcardPlusJSONBody defines parameters for UpdateMediaEncoderPath.
type UpdateMediaEncoderPathApplicationWildcardPlusJSONBody = MediaEncoderPathDto

// UpdateMediaEncoderPathJSONBody defines parameters for UpdateMediaEncoderPath.
type UpdateMediaEncoderPathJSONBody = MediaEncoderPathDto

// GetTrailersParams defines parameters for GetTrailers.
type GetTrailersParams struct {
	// UserId The user id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// MaxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
	MaxOfficialRating *string `form:"maxOfficialRating,omitempty" json:"maxOfficialRating,omitempty"`

	// HasThemeSong Optional filter by items with theme songs.
	HasThemeSong *bool `form:"hasThemeSong,omitempty" json:"hasThemeSong,omitempty"`

	// HasThemeVideo Optional filter by items with theme videos.
	HasThemeVideo *bool `form:"hasThemeVideo,omitempty" json:"hasThemeVideo,omitempty"`

	// HasSubtitles Optional filter by items with subtitles.
	HasSubtitles *bool `form:"hasSubtitles,omitempty" json:"hasSubtitles,omitempty"`

	// HasSpecialFeature Optional filter by items with special features.
	HasSpecialFeature *bool `form:"hasSpecialFeature,omitempty" json:"hasSpecialFeature,omitempty"`

	// HasTrailer Optional filter by items with trailers.
	HasTrailer *bool `form:"hasTrailer,omitempty" json:"hasTrailer,omitempty"`

	// AdjacentTo Optional. Return items that are siblings of a supplied item.
	AdjacentTo *string `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`

	// ParentIndexNumber Optional filter by parent index number.
	ParentIndexNumber *int32 `form:"parentIndexNumber,omitempty" json:"parentIndexNumber,omitempty"`

	// HasParentalRating Optional filter by items that have or do not have a parental rating.
	HasParentalRating *bool `form:"hasParentalRating,omitempty" json:"hasParentalRating,omitempty"`

	// IsHd Optional filter by items that are HD or not.
	IsHd *bool `form:"isHd,omitempty" json:"isHd,omitempty"`

	// Is4K Optional filter by items that are 4K or not.
	Is4K *bool `form:"is4K,omitempty" json:"is4K,omitempty"`

	// LocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
	LocationTypes *[]LocationType `form:"locationTypes,omitempty" json:"locationTypes,omitempty"`

	// ExcludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
	ExcludeLocationTypes *[]LocationType `form:"excludeLocationTypes,omitempty" json:"excludeLocationTypes,omitempty"`

	// IsMissing Optional filter by items that are missing episodes or not.
	IsMissing *bool `form:"isMissing,omitempty" json:"isMissing,omitempty"`

	// IsUnaired Optional filter by items that are unaired episodes or not.
	IsUnaired *bool `form:"isUnaired,omitempty" json:"isUnaired,omitempty"`

	// MinCommunityRating Optional filter by minimum community rating.
	MinCommunityRating *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`

	// MinCriticRating Optional filter by minimum critic rating.
	MinCriticRating *float64 `form:"minCriticRating,omitempty" json:"minCriticRating,omitempty"`

	// MinPremiereDate Optional. The minimum premiere date. Format = ISO.
	MinPremiereDate *time.Time `form:"minPremiereDate,omitempty" json:"minPremiereDate,omitempty"`

	// MinDateLastSaved Optional. The minimum last saved date. Format = ISO.
	MinDateLastSaved *time.Time `form:"minDateLastSaved,omitempty" json:"minDateLastSaved,omitempty"`

	// MinDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
	MinDateLastSavedForUser *time.Time `form:"minDateLastSavedForUser,omitempty" json:"minDateLastSavedForUser,omitempty"`

	// MaxPremiereDate Optional. The maximum premiere date. Format = ISO.
	MaxPremiereDate *time.Time `form:"maxPremiereDate,omitempty" json:"maxPremiereDate,omitempty"`

	// HasOverview Optional filter by items that have an overview or not.
	HasOverview *bool `form:"hasOverview,omitempty" json:"hasOverview,omitempty"`

	// HasImdbId Optional filter by items that have an imdb id or not.
	HasImdbId *bool `form:"hasImdbId,omitempty" json:"hasImdbId,omitempty"`

	// HasTmdbId Optional filter by items that have a tmdb id or not.
	HasTmdbId *bool `form:"hasTmdbId,omitempty" json:"hasTmdbId,omitempty"`

	// HasTvdbId Optional filter by items that have a tvdb id or not.
	HasTvdbId *bool `form:"hasTvdbId,omitempty" json:"hasTvdbId,omitempty"`

	// IsMovie Optional filter for live tv movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional filter for live tv series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional filter for live tv news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional filter for live tv kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional filter for live tv sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// ExcludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
	ExcludeItemIds *[]openapi_types.UUID `form:"excludeItemIds,omitempty" json:"excludeItemIds,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// SearchTerm Optional. Filter based on a search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// Filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// MediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// ImageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
	ImageTypes *[]ImageType `form:"imageTypes,omitempty" json:"imageTypes,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// IsPlayed Optional filter by items that are played, or not.
	IsPlayed *bool `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`

	// Genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// OfficialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
	OfficialRatings *[]string `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`

	// Tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
	Years *[]int32 `form:"years,omitempty" json:"years,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Person Optional. If specified, results will be filtered to include only those containing the specified person.
	Person *string `form:"person,omitempty" json:"person,omitempty"`

	// PersonIds Optional. If specified, results will be filtered to include only those containing the specified person id.
	PersonIds *[]openapi_types.UUID `form:"personIds,omitempty" json:"personIds,omitempty"`

	// PersonTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// Studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
	Studios *[]string `form:"studios,omitempty" json:"studios,omitempty"`

	// Artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
	Artists *[]string `form:"artists,omitempty" json:"artists,omitempty"`

	// ExcludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// ArtistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
	ArtistIds *[]openapi_types.UUID `form:"artistIds,omitempty" json:"artistIds,omitempty"`

	// AlbumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
	AlbumArtistIds *[]openapi_types.UUID `form:"albumArtistIds,omitempty" json:"albumArtistIds,omitempty"`

	// ContributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
	ContributingArtistIds *[]openapi_types.UUID `form:"contributingArtistIds,omitempty" json:"contributingArtistIds,omitempty"`

	// Albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
	Albums *[]string `form:"albums,omitempty" json:"albums,omitempty"`

	// AlbumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
	AlbumIds *[]openapi_types.UUID `form:"albumIds,omitempty" json:"albumIds,omitempty"`

	// Ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// VideoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
	VideoTypes *[]VideoType `form:"videoTypes,omitempty" json:"videoTypes,omitempty"`

	// MinOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
	MinOfficialRating *string `form:"minOfficialRating,omitempty" json:"minOfficialRating,omitempty"`

	// IsLocked Optional filter by items that are locked.
	IsLocked *bool `form:"isLocked,omitempty" json:"isLocked,omitempty"`

	// IsPlaceHolder Optional filter by items that are placeholders.
	IsPlaceHolder *bool `form:"isPlaceHolder,omitempty" json:"isPlaceHolder,omitempty"`

	// HasOfficialRating Optional filter by items that have official ratings.
	HasOfficialRating *bool `form:"hasOfficialRating,omitempty" json:"hasOfficialRating,omitempty"`

	// CollapseBoxSetItems Whether or not to hide items behind their boxsets.
	CollapseBoxSetItems *bool `form:"collapseBoxSetItems,omitempty" json:"collapseBoxSetItems,omitempty"`

	// MinWidth Optional. Filter by the minimum width of the item.
	MinWidth *int32 `form:"minWidth,omitempty" json:"minWidth,omitempty"`

	// MinHeight Optional. Filter by the minimum height of the item.
	MinHeight *int32 `form:"minHeight,omitempty" json:"minHeight,omitempty"`

	// MaxWidth Optional. Filter by the maximum width of the item.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. Filter by the maximum height of the item.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Is3D Optional filter by items that are 3D, or not.
	Is3D *bool `form:"is3D,omitempty" json:"is3D,omitempty"`

	// SeriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
	SeriesStatus *[]SeriesStatus `form:"seriesStatus,omitempty" json:"seriesStatus,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// StudioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
	StudioIds *[]openapi_types.UUID `form:"studioIds,omitempty" json:"studioIds,omitempty"`

	// GenreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// EnableTotalRecordCount Optional. Enable the total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetSimilarTrailersParams defines parameters for GetSimilarTrailers.
type GetSimilarTrailersParams struct {
	// ExcludeArtistIds Exclude artist ids.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// IsHidden Optional filter by IsHidden=true or false.
	IsHidden *bool `form:"isHidden,omitempty" json:"isHidden,omitempty"`

	// IsDisabled Optional filter by IsDisabled=true or false.
	IsDisabled *bool `form:"isDisabled,omitempty" json:"isDisabled,omitempty"`
}

// AuthenticateUserByNameApplicationWildcardPlusJSONBody defines parameters for AuthenticateUserByName.
type AuthenticateUserByNameApplicationWildcardPlusJSONBody = AuthenticateUserByName

// AuthenticateUserByNameJSONBody defines parameters for AuthenticateUserByName.
type AuthenticateUserByNameJSONBody = AuthenticateUserByName

// AuthenticateWithQuickConnectApplicationWildcardPlusJSONBody defines parameters for AuthenticateWithQuickConnect.
type AuthenticateWithQuickConnectApplicationWildcardPlusJSONBody = QuickConnectDto

// AuthenticateWithQuickConnectJSONBody defines parameters for AuthenticateWithQuickConnect.
type AuthenticateWithQuickConnectJSONBody = QuickConnectDto

// ForgotPasswordApplicationWildcardPlusJSONBody defines parameters for ForgotPassword.
type ForgotPasswordApplicationWildcardPlusJSONBody = ForgotPasswordDto

// ForgotPasswordJSONBody defines parameters for ForgotPassword.
type ForgotPasswordJSONBody = ForgotPasswordDto

// ForgotPasswordPinApplicationWildcardPlusJSONBody defines parameters for ForgotPasswordPin.
type ForgotPasswordPinApplicationWildcardPlusJSONBody = ForgotPasswordPinDto

// ForgotPasswordPinJSONBody defines parameters for ForgotPasswordPin.
type ForgotPasswordPinJSONBody = ForgotPasswordPinDto

// CreateUserByNameApplicationWildcardPlusJSONBody defines parameters for CreateUserByName.
type CreateUserByNameApplicationWildcardPlusJSONBody = CreateUserByName

// CreateUserByNameJSONBody defines parameters for CreateUserByName.
type CreateUserByNameJSONBody = CreateUserByName

// UpdateUserApplicationWildcardPlusJSONBody defines parameters for UpdateUser.
type UpdateUserApplicationWildcardPlusJSONBody = UserDto

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody = UserDto

// AuthenticateUserParams defines parameters for AuthenticateUser.
type AuthenticateUserParams struct {
	// Pw The password as plain text.
	Pw string `form:"pw" json:"pw"`

	// Password The password sha1-hash.
	Password *string `form:"password,omitempty" json:"password,omitempty"`
}

// UpdateUserConfigurationApplicationWildcardPlusJSONBody defines parameters for UpdateUserConfiguration.
type UpdateUserConfigurationApplicationWildcardPlusJSONBody = UserConfiguration

// UpdateUserConfigurationJSONBody defines parameters for UpdateUserConfiguration.
type UpdateUserConfigurationJSONBody = UserConfiguration

// UpdateUserEasyPasswordApplicationWildcardPlusJSONBody defines parameters for UpdateUserEasyPassword.
type UpdateUserEasyPasswordApplicationWildcardPlusJSONBody = UpdateUserEasyPassword

// UpdateUserEasyPasswordJSONBody defines parameters for UpdateUserEasyPassword.
type UpdateUserEasyPasswordJSONBody = UpdateUserEasyPassword

// DeleteUserImageParams defines parameters for DeleteUserImage.
type DeleteUserImageParams struct {
	// Index (Unused) Image index.
	Index *int32 `form:"index,omitempty" json:"index,omitempty"`
}

// GetUserImageParams defines parameters for GetUserImage.
type GetUserImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// HeadUserImageParams defines parameters for HeadUserImage.
type HeadUserImageParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`

	// ImageIndex Image index.
	ImageIndex *int32 `form:"imageIndex,omitempty" json:"imageIndex,omitempty"`
}

// PostUserImageParams defines parameters for PostUserImage.
type PostUserImageParams struct {
	// Index (Unused) Image index.
	Index *int32 `form:"index,omitempty" json:"index,omitempty"`
}

// GetUserImageByIndexParams defines parameters for GetUserImageByIndex.
type GetUserImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// HeadUserImageByIndexParams defines parameters for HeadUserImageByIndex.
type HeadUserImageByIndexParams struct {
	// Tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// Format Determines the output format of the image - original,gif,jpg,png.
	Format *ImageFormat `form:"format,omitempty" json:"format,omitempty"`

	// MaxWidth The maximum image width to return.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight The maximum image height to return.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// PercentPlayed Optional. Percent to render for the percent played overlay.
	PercentPlayed *float64 `form:"percentPlayed,omitempty" json:"percentPlayed,omitempty"`

	// UnplayedCount Optional. Unplayed count overlay to render.
	UnplayedCount *int32 `form:"unplayedCount,omitempty" json:"unplayedCount,omitempty"`

	// Width The fixed image width to return.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height The fixed image height to return.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// Quality Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
	Quality *int32 `form:"quality,omitempty" json:"quality,omitempty"`

	// FillWidth Width of box to fill.
	FillWidth *int32 `form:"fillWidth,omitempty" json:"fillWidth,omitempty"`

	// FillHeight Height of box to fill.
	FillHeight *int32 `form:"fillHeight,omitempty" json:"fillHeight,omitempty"`

	// CropWhitespace Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
	CropWhitespace *bool `form:"cropWhitespace,omitempty" json:"cropWhitespace,omitempty"`

	// AddPlayedIndicator Optional. Add a played indicator.
	AddPlayedIndicator *bool `form:"addPlayedIndicator,omitempty" json:"addPlayedIndicator,omitempty"`

	// Blur Optional. Blur image.
	Blur *int32 `form:"blur,omitempty" json:"blur,omitempty"`

	// BackgroundColor Optional. Apply a background color for transparent images.
	BackgroundColor *string `form:"backgroundColor,omitempty" json:"backgroundColor,omitempty"`

	// ForegroundLayer Optional. Apply a foreground layer on top of the image.
	ForegroundLayer *string `form:"foregroundLayer,omitempty" json:"foregroundLayer,omitempty"`
}

// GetItemsByUserIdParams defines parameters for GetItemsByUserId.
type GetItemsByUserIdParams struct {
	// MaxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
	MaxOfficialRating *string `form:"maxOfficialRating,omitempty" json:"maxOfficialRating,omitempty"`

	// HasThemeSong Optional filter by items with theme songs.
	HasThemeSong *bool `form:"hasThemeSong,omitempty" json:"hasThemeSong,omitempty"`

	// HasThemeVideo Optional filter by items with theme videos.
	HasThemeVideo *bool `form:"hasThemeVideo,omitempty" json:"hasThemeVideo,omitempty"`

	// HasSubtitles Optional filter by items with subtitles.
	HasSubtitles *bool `form:"hasSubtitles,omitempty" json:"hasSubtitles,omitempty"`

	// HasSpecialFeature Optional filter by items with special features.
	HasSpecialFeature *bool `form:"hasSpecialFeature,omitempty" json:"hasSpecialFeature,omitempty"`

	// HasTrailer Optional filter by items with trailers.
	HasTrailer *bool `form:"hasTrailer,omitempty" json:"hasTrailer,omitempty"`

	// AdjacentTo Optional. Return items that are siblings of a supplied item.
	AdjacentTo *string `form:"adjacentTo,omitempty" json:"adjacentTo,omitempty"`

	// ParentIndexNumber Optional filter by parent index number.
	ParentIndexNumber *int32 `form:"parentIndexNumber,omitempty" json:"parentIndexNumber,omitempty"`

	// HasParentalRating Optional filter by items that have or do not have a parental rating.
	HasParentalRating *bool `form:"hasParentalRating,omitempty" json:"hasParentalRating,omitempty"`

	// IsHd Optional filter by items that are HD or not.
	IsHd *bool `form:"isHd,omitempty" json:"isHd,omitempty"`

	// Is4K Optional filter by items that are 4K or not.
	Is4K *bool `form:"is4K,omitempty" json:"is4K,omitempty"`

	// LocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
	LocationTypes *[]LocationType `form:"locationTypes,omitempty" json:"locationTypes,omitempty"`

	// ExcludeLocationTypes Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
	ExcludeLocationTypes *[]LocationType `form:"excludeLocationTypes,omitempty" json:"excludeLocationTypes,omitempty"`

	// IsMissing Optional filter by items that are missing episodes or not.
	IsMissing *bool `form:"isMissing,omitempty" json:"isMissing,omitempty"`

	// IsUnaired Optional filter by items that are unaired episodes or not.
	IsUnaired *bool `form:"isUnaired,omitempty" json:"isUnaired,omitempty"`

	// MinCommunityRating Optional filter by minimum community rating.
	MinCommunityRating *float64 `form:"minCommunityRating,omitempty" json:"minCommunityRating,omitempty"`

	// MinCriticRating Optional filter by minimum critic rating.
	MinCriticRating *float64 `form:"minCriticRating,omitempty" json:"minCriticRating,omitempty"`

	// MinPremiereDate Optional. The minimum premiere date. Format = ISO.
	MinPremiereDate *time.Time `form:"minPremiereDate,omitempty" json:"minPremiereDate,omitempty"`

	// MinDateLastSaved Optional. The minimum last saved date. Format = ISO.
	MinDateLastSaved *time.Time `form:"minDateLastSaved,omitempty" json:"minDateLastSaved,omitempty"`

	// MinDateLastSavedForUser Optional. The minimum last saved date for the current user. Format = ISO.
	MinDateLastSavedForUser *time.Time `form:"minDateLastSavedForUser,omitempty" json:"minDateLastSavedForUser,omitempty"`

	// MaxPremiereDate Optional. The maximum premiere date. Format = ISO.
	MaxPremiereDate *time.Time `form:"maxPremiereDate,omitempty" json:"maxPremiereDate,omitempty"`

	// HasOverview Optional filter by items that have an overview or not.
	HasOverview *bool `form:"hasOverview,omitempty" json:"hasOverview,omitempty"`

	// HasImdbId Optional filter by items that have an imdb id or not.
	HasImdbId *bool `form:"hasImdbId,omitempty" json:"hasImdbId,omitempty"`

	// HasTmdbId Optional filter by items that have a tmdb id or not.
	HasTmdbId *bool `form:"hasTmdbId,omitempty" json:"hasTmdbId,omitempty"`

	// HasTvdbId Optional filter by items that have a tvdb id or not.
	HasTvdbId *bool `form:"hasTvdbId,omitempty" json:"hasTvdbId,omitempty"`

	// IsMovie Optional filter for live tv movies.
	IsMovie *bool `form:"isMovie,omitempty" json:"isMovie,omitempty"`

	// IsSeries Optional filter for live tv series.
	IsSeries *bool `form:"isSeries,omitempty" json:"isSeries,omitempty"`

	// IsNews Optional filter for live tv news.
	IsNews *bool `form:"isNews,omitempty" json:"isNews,omitempty"`

	// IsKids Optional filter for live tv kids.
	IsKids *bool `form:"isKids,omitempty" json:"isKids,omitempty"`

	// IsSports Optional filter for live tv sports.
	IsSports *bool `form:"isSports,omitempty" json:"isSports,omitempty"`

	// ExcludeItemIds Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
	ExcludeItemIds *[]openapi_types.UUID `form:"excludeItemIds,omitempty" json:"excludeItemIds,omitempty"`

	// StartIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Recursive When searching within folders, this determines whether or not the search will be recursive. true/false.
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// SearchTerm Optional. Filter based on a search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// Filters Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
	Filters *[]ItemFilter `form:"filters,omitempty" json:"filters,omitempty"`

	// IsFavorite Optional filter by items that are marked as favorite, or not.
	IsFavorite *bool `form:"isFavorite,omitempty" json:"isFavorite,omitempty"`

	// MediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// ImageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
	ImageTypes *[]ImageType `form:"imageTypes,omitempty" json:"imageTypes,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// IsPlayed Optional filter by items that are played, or not.
	IsPlayed *bool `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`

	// Genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
	Genres *[]string `form:"genres,omitempty" json:"genres,omitempty"`

	// OfficialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
	OfficialRatings *[]string `form:"officialRatings,omitempty" json:"officialRatings,omitempty"`

	// Tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
	Years *[]int32 `form:"years,omitempty" json:"years,omitempty"`

	// EnableUserData Optional, include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional, the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// Person Optional. If specified, results will be filtered to include only those containing the specified person.
	Person *string `form:"person,omitempty" json:"person,omitempty"`

	// PersonIds Optional. If specified, results will be filtered to include only those containing the specified person id.
	PersonIds *[]openapi_types.UUID `form:"personIds,omitempty" json:"personIds,omitempty"`

	// PersonTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
	PersonTypes *[]string `form:"personTypes,omitempty" json:"personTypes,omitempty"`

	// Studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
	Studios *[]string `form:"studios,omitempty" json:"studios,omitempty"`

	// Artists Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
	Artists *[]string `form:"artists,omitempty" json:"artists,omitempty"`

	// ExcludeArtistIds Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
	ExcludeArtistIds *[]openapi_types.UUID `form:"excludeArtistIds,omitempty" json:"excludeArtistIds,omitempty"`

	// ArtistIds Optional. If specified, results will be filtered to include only those containing the specified artist id.
	ArtistIds *[]openapi_types.UUID `form:"artistIds,omitempty" json:"artistIds,omitempty"`

	// AlbumArtistIds Optional. If specified, results will be filtered to include only those containing the specified album artist id.
	AlbumArtistIds *[]openapi_types.UUID `form:"albumArtistIds,omitempty" json:"albumArtistIds,omitempty"`

	// ContributingArtistIds Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
	ContributingArtistIds *[]openapi_types.UUID `form:"contributingArtistIds,omitempty" json:"contributingArtistIds,omitempty"`

	// Albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
	Albums *[]string `form:"albums,omitempty" json:"albums,omitempty"`

	// AlbumIds Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
	AlbumIds *[]openapi_types.UUID `form:"albumIds,omitempty" json:"albumIds,omitempty"`

	// Ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
	Ids *[]openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// VideoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
	VideoTypes *[]VideoType `form:"videoTypes,omitempty" json:"videoTypes,omitempty"`

	// MinOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
	MinOfficialRating *string `form:"minOfficialRating,omitempty" json:"minOfficialRating,omitempty"`

	// IsLocked Optional filter by items that are locked.
	IsLocked *bool `form:"isLocked,omitempty" json:"isLocked,omitempty"`

	// IsPlaceHolder Optional filter by items that are placeholders.
	IsPlaceHolder *bool `form:"isPlaceHolder,omitempty" json:"isPlaceHolder,omitempty"`

	// HasOfficialRating Optional filter by items that have official ratings.
	HasOfficialRating *bool `form:"hasOfficialRating,omitempty" json:"hasOfficialRating,omitempty"`

	// CollapseBoxSetItems Whether or not to hide items behind their boxsets.
	CollapseBoxSetItems *bool `form:"collapseBoxSetItems,omitempty" json:"collapseBoxSetItems,omitempty"`

	// MinWidth Optional. Filter by the minimum width of the item.
	MinWidth *int32 `form:"minWidth,omitempty" json:"minWidth,omitempty"`

	// MinHeight Optional. Filter by the minimum height of the item.
	MinHeight *int32 `form:"minHeight,omitempty" json:"minHeight,omitempty"`

	// MaxWidth Optional. Filter by the maximum width of the item.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. Filter by the maximum height of the item.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// Is3D Optional filter by items that are 3D, or not.
	Is3D *bool `form:"is3D,omitempty" json:"is3D,omitempty"`

	// SeriesStatus Optional filter by Series Status. Allows multiple, comma delimited.
	SeriesStatus *[]SeriesStatus `form:"seriesStatus,omitempty" json:"seriesStatus,omitempty"`

	// NameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
	NameStartsWithOrGreater *string `form:"nameStartsWithOrGreater,omitempty" json:"nameStartsWithOrGreater,omitempty"`

	// NameStartsWith Optional filter by items whose name is sorted equally than a given input string.
	NameStartsWith *string `form:"nameStartsWith,omitempty" json:"nameStartsWith,omitempty"`

	// NameLessThan Optional filter by items whose name is equally or lesser than a given input string.
	NameLessThan *string `form:"nameLessThan,omitempty" json:"nameLessThan,omitempty"`

	// StudioIds Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
	StudioIds *[]openapi_types.UUID `form:"studioIds,omitempty" json:"studioIds,omitempty"`

	// GenreIds Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
	GenreIds *[]openapi_types.UUID `form:"genreIds,omitempty" json:"genreIds,omitempty"`

	// EnableTotalRecordCount Optional. Enable the total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`

	// EnableImages Optional, include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetLatestMediaParams defines parameters for GetLatestMedia.
type GetLatestMediaParams struct {
	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// IsPlayed Filter by items that are played, or not.
	IsPlayed *bool `form:"isPlayed,omitempty" json:"isPlayed,omitempty"`

	// EnableImages Optional. include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ImageTypeLimit Optional. the max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// EnableUserData Optional. include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// Limit Return item limit.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// GroupItems Whether or not to group items into a parent container.
	GroupItems *bool `form:"groupItems,omitempty" json:"groupItems,omitempty"`
}

// GetResumeItemsParams defines parameters for GetResumeItems.
type GetResumeItemsParams struct {
	// StartIndex The start index.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit The item limit.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SearchTerm The search term.
	SearchTerm *string `form:"searchTerm,omitempty" json:"searchTerm,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// MediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// EnableTotalRecordCount Optional. Enable the total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`

	// ExcludeActiveSessions Optional. Whether to exclude the currently active sessions.
	ExcludeActiveSessions *bool `form:"excludeActiveSessions,omitempty" json:"excludeActiveSessions,omitempty"`
}

// UpdateUserItemRatingParams defines parameters for UpdateUserItemRating.
type UpdateUserItemRatingParams struct {
	// Likes Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
	Likes *bool `form:"likes,omitempty" json:"likes,omitempty"`
}

// UpdateUserPasswordApplicationWildcardPlusJSONBody defines parameters for UpdateUserPassword.
type UpdateUserPasswordApplicationWildcardPlusJSONBody = UpdateUserPassword

// UpdateUserPasswordJSONBody defines parameters for UpdateUserPassword.
type UpdateUserPasswordJSONBody = UpdateUserPassword

// MarkPlayedItemParams defines parameters for MarkPlayedItem.
type MarkPlayedItemParams struct {
	// DatePlayed Optional. The date the item was played.
	DatePlayed *time.Time `form:"datePlayed,omitempty" json:"datePlayed,omitempty"`
}

// OnPlaybackStoppedParams defines parameters for OnPlaybackStopped.
type OnPlaybackStoppedParams struct {
	// MediaSourceId The id of the MediaSource.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// NextMediaType The next media type that will play.
	NextMediaType *string `form:"nextMediaType,omitempty" json:"nextMediaType,omitempty"`

	// PositionTicks Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
	PositionTicks *int64 `form:"positionTicks,omitempty" json:"positionTicks,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`
}

// OnPlaybackStartParams defines parameters for OnPlaybackStart.
type OnPlaybackStartParams struct {
	// MediaSourceId The id of the MediaSource.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// AudioStreamIndex The audio stream index.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// SubtitleStreamIndex The subtitle stream index.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// PlayMethod The play method.
	PlayMethod *PlayMethod `form:"playMethod,omitempty" json:"playMethod,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// CanSeek Indicates if the client can seek.
	CanSeek *bool `form:"canSeek,omitempty" json:"canSeek,omitempty"`
}

// OnPlaybackProgressParams defines parameters for OnPlaybackProgress.
type OnPlaybackProgressParams struct {
	// MediaSourceId The id of the MediaSource.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// PositionTicks Optional. The current position, in ticks. 1 tick = 10000 ms.
	PositionTicks *int64 `form:"positionTicks,omitempty" json:"positionTicks,omitempty"`

	// AudioStreamIndex The audio stream index.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// SubtitleStreamIndex The subtitle stream index.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// VolumeLevel Scale of 0-100.
	VolumeLevel *int32 `form:"volumeLevel,omitempty" json:"volumeLevel,omitempty"`

	// PlayMethod The play method.
	PlayMethod *PlayMethod `form:"playMethod,omitempty" json:"playMethod,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// RepeatMode The repeat mode.
	RepeatMode *RepeatMode `form:"repeatMode,omitempty" json:"repeatMode,omitempty"`

	// IsPaused Indicates if the player is paused.
	IsPaused *bool `form:"isPaused,omitempty" json:"isPaused,omitempty"`

	// IsMuted Indicates if the player is muted.
	IsMuted *bool `form:"isMuted,omitempty" json:"isMuted,omitempty"`
}

// UpdateUserPolicyApplicationWildcardPlusJSONBody defines parameters for UpdateUserPolicy.
type UpdateUserPolicyApplicationWildcardPlusJSONBody = UserPolicy

// UpdateUserPolicyJSONBody defines parameters for UpdateUserPolicy.
type UpdateUserPolicyJSONBody = UserPolicy

// GetSuggestionsParams defines parameters for GetSuggestions.
type GetSuggestionsParams struct {
	// MediaType The media types.
	MediaType *[]string `form:"mediaType,omitempty" json:"mediaType,omitempty"`

	// Type The type.
	Type *[]BaseItemKind `form:"type,omitempty" json:"type,omitempty"`

	// StartIndex Optional. The start index.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The limit.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// EnableTotalRecordCount Whether to enable the total record count.
	EnableTotalRecordCount *bool `form:"enableTotalRecordCount,omitempty" json:"enableTotalRecordCount,omitempty"`
}

// GetUserViewsParams defines parameters for GetUserViews.
type GetUserViewsParams struct {
	// IncludeExternalContent Whether or not to include external views such as channels or live tv.
	IncludeExternalContent *bool `form:"includeExternalContent,omitempty" json:"includeExternalContent,omitempty"`

	// PresetViews Preset views.
	PresetViews *[]string `form:"presetViews,omitempty" json:"presetViews,omitempty"`

	// IncludeHidden Whether or not to include hidden content.
	IncludeHidden *bool `form:"includeHidden,omitempty" json:"includeHidden,omitempty"`
}

// StopEncodingProcessParams defines parameters for StopEncodingProcess.
type StopEncodingProcessParams struct {
	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId string `form:"deviceId" json:"deviceId"`

	// PlaySessionId The play session id.
	PlaySessionId string `form:"playSessionId" json:"playSessionId"`
}

// MergeVersionsParams defines parameters for MergeVersions.
type MergeVersionsParams struct {
	// Ids Item id list. This allows multiple, comma delimited.
	Ids []openapi_types.UUID `form:"ids" json:"ids"`
}

// GetAdditionalPartParams defines parameters for GetAdditionalPart.
type GetAdditionalPartParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// UploadSubtitleApplicationWildcardPlusJSONBody defines parameters for UploadSubtitle.
type UploadSubtitleApplicationWildcardPlusJSONBody = UploadSubtitleDto

// UploadSubtitleJSONBody defines parameters for UploadSubtitle.
type UploadSubtitleJSONBody = UploadSubtitleDto

// GetHlsVideoSegmentParams defines parameters for GetHlsVideoSegment.
type GetHlsVideoSegmentParams struct {
	// RuntimeTicks The position of the requested segment in ticks.
	RuntimeTicks int64 `form:"runtimeTicks" json:"runtimeTicks"`

	// ActualSegmentLengthTicks The length of the requested segment in ticks.
	ActualSegmentLengthTicks int64 `form:"actualSegmentLengthTicks" json:"actualSegmentLengthTicks"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The desired segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetLiveHlsStreamParams defines parameters for GetLiveHlsStream.
type GetLiveHlsStreamParams struct {
	// Container The audio container.
	Container *string `form:"container,omitempty" json:"container,omitempty"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment lenght.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`

	// MaxWidth Optional. The max width.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The max height.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// EnableSubtitlesInManifest Optional. Whether to enable subtitles in the manifest.
	EnableSubtitlesInManifest *bool `form:"enableSubtitlesInManifest,omitempty" json:"enableSubtitlesInManifest,omitempty"`
}

// GetVariantHlsVideoPlaylistParams defines parameters for GetVariantHlsVideoPlaylist.
type GetVariantHlsVideoPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetMasterHlsVideoPlaylistParams defines parameters for GetMasterHlsVideoPlaylist.
type GetMasterHlsVideoPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId string `form:"mediaSourceId" json:"mediaSourceId"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`

	// EnableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
	EnableAdaptiveBitrateStreaming *bool `form:"enableAdaptiveBitrateStreaming,omitempty" json:"enableAdaptiveBitrateStreaming,omitempty"`
}

// HeadMasterHlsVideoPlaylistParams defines parameters for HeadMasterHlsVideoPlaylist.
type HeadMasterHlsVideoPlaylistParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId string `form:"mediaSourceId" json:"mediaSourceId"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`

	// EnableAdaptiveBitrateStreaming Enable adaptive bitrate streaming.
	EnableAdaptiveBitrateStreaming *bool `form:"enableAdaptiveBitrateStreaming,omitempty" json:"enableAdaptiveBitrateStreaming,omitempty"`
}

// GetVideoStreamParams defines parameters for GetVideoStream.
type GetVideoStreamParams struct {
	// Container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
	Container *string `form:"container,omitempty" json:"container,omitempty"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// HeadVideoStreamParams defines parameters for HeadVideoStream.
type HeadVideoStreamParams struct {
	// Container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
	Container *string `form:"container,omitempty" json:"container,omitempty"`

	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetVideoStreamByContainerParams defines parameters for GetVideoStreamByContainer.
type GetVideoStreamByContainerParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// HeadVideoStreamByContainerParams defines parameters for HeadVideoStreamByContainer.
type HeadVideoStreamByContainerParams struct {
	// Static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
	Static *bool `form:"static,omitempty" json:"static,omitempty"`

	// Params The streaming parameters.
	Params *string `form:"params,omitempty" json:"params,omitempty"`

	// Tag The tag.
	Tag *string `form:"tag,omitempty" json:"tag,omitempty"`

	// DeviceProfileId Optional. The dlna device profile id to utilize.
	DeviceProfileId *string `form:"deviceProfileId,omitempty" json:"deviceProfileId,omitempty"`

	// PlaySessionId The play session id.
	PlaySessionId *string `form:"playSessionId,omitempty" json:"playSessionId,omitempty"`

	// SegmentContainer The segment container.
	SegmentContainer *string `form:"segmentContainer,omitempty" json:"segmentContainer,omitempty"`

	// SegmentLength The segment length.
	SegmentLength *int32 `form:"segmentLength,omitempty" json:"segmentLength,omitempty"`

	// MinSegments The minimum number of segments.
	MinSegments *int32 `form:"minSegments,omitempty" json:"minSegments,omitempty"`

	// MediaSourceId The media version id, if playing an alternate version.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// DeviceId The device id of the client requesting. Used to stop encoding processes when needed.
	DeviceId *string `form:"deviceId,omitempty" json:"deviceId,omitempty"`

	// AudioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
	AudioCodec *string `form:"audioCodec,omitempty" json:"audioCodec,omitempty"`

	// EnableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
	EnableAutoStreamCopy *bool `form:"enableAutoStreamCopy,omitempty" json:"enableAutoStreamCopy,omitempty"`

	// AllowVideoStreamCopy Whether or not to allow copying of the video stream url.
	AllowVideoStreamCopy *bool `form:"allowVideoStreamCopy,omitempty" json:"allowVideoStreamCopy,omitempty"`

	// AllowAudioStreamCopy Whether or not to allow copying of the audio stream url.
	AllowAudioStreamCopy *bool `form:"allowAudioStreamCopy,omitempty" json:"allowAudioStreamCopy,omitempty"`

	// BreakOnNonKeyFrames Optional. Whether to break on non key frames.
	BreakOnNonKeyFrames *bool `form:"breakOnNonKeyFrames,omitempty" json:"breakOnNonKeyFrames,omitempty"`

	// AudioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100.
	AudioSampleRate *int32 `form:"audioSampleRate,omitempty" json:"audioSampleRate,omitempty"`

	// MaxAudioBitDepth Optional. The maximum audio bit depth.
	MaxAudioBitDepth *int32 `form:"maxAudioBitDepth,omitempty" json:"maxAudioBitDepth,omitempty"`

	// AudioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
	AudioBitRate *int32 `form:"audioBitRate,omitempty" json:"audioBitRate,omitempty"`

	// AudioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2.
	AudioChannels *int32 `form:"audioChannels,omitempty" json:"audioChannels,omitempty"`

	// MaxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
	MaxAudioChannels *int32 `form:"maxAudioChannels,omitempty" json:"maxAudioChannels,omitempty"`

	// Profile Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
	Profile *string `form:"profile,omitempty" json:"profile,omitempty"`

	// Level Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
	Level *string `form:"level,omitempty" json:"level,omitempty"`

	// Framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	Framerate *float32 `form:"framerate,omitempty" json:"framerate,omitempty"`

	// MaxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
	MaxFramerate *float32 `form:"maxFramerate,omitempty" json:"maxFramerate,omitempty"`

	// CopyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// StartTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
	StartTimeTicks *int64 `form:"startTimeTicks,omitempty" json:"startTimeTicks,omitempty"`

	// Width Optional. The fixed horizontal resolution of the encoded video.
	Width *int32 `form:"width,omitempty" json:"width,omitempty"`

	// Height Optional. The fixed vertical resolution of the encoded video.
	Height *int32 `form:"height,omitempty" json:"height,omitempty"`

	// MaxWidth Optional. The maximum horizontal resolution of the encoded video.
	MaxWidth *int32 `form:"maxWidth,omitempty" json:"maxWidth,omitempty"`

	// MaxHeight Optional. The maximum vertical resolution of the encoded video.
	MaxHeight *int32 `form:"maxHeight,omitempty" json:"maxHeight,omitempty"`

	// VideoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
	VideoBitRate *int32 `form:"videoBitRate,omitempty" json:"videoBitRate,omitempty"`

	// SubtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
	SubtitleStreamIndex *int32 `form:"subtitleStreamIndex,omitempty" json:"subtitleStreamIndex,omitempty"`

	// SubtitleMethod Optional. Specify the subtitle delivery method.
	SubtitleMethod *SubtitleDeliveryMethod `form:"subtitleMethod,omitempty" json:"subtitleMethod,omitempty"`

	// MaxRefFrames Optional.
	MaxRefFrames *int32 `form:"maxRefFrames,omitempty" json:"maxRefFrames,omitempty"`

	// MaxVideoBitDepth Optional. The maximum video bit depth.
	MaxVideoBitDepth *int32 `form:"maxVideoBitDepth,omitempty" json:"maxVideoBitDepth,omitempty"`

	// RequireAvc Optional. Whether to require avc.
	RequireAvc *bool `form:"requireAvc,omitempty" json:"requireAvc,omitempty"`

	// DeInterlace Optional. Whether to deinterlace the video.
	DeInterlace *bool `form:"deInterlace,omitempty" json:"deInterlace,omitempty"`

	// RequireNonAnamorphic Optional. Whether to require a non anamorphic stream.
	RequireNonAnamorphic *bool `form:"requireNonAnamorphic,omitempty" json:"requireNonAnamorphic,omitempty"`

	// TranscodingMaxAudioChannels Optional. The maximum number of audio channels to transcode.
	TranscodingMaxAudioChannels *int32 `form:"transcodingMaxAudioChannels,omitempty" json:"transcodingMaxAudioChannels,omitempty"`

	// CpuCoreLimit Optional. The limit of how many cpu cores to use.
	CpuCoreLimit *int32 `form:"cpuCoreLimit,omitempty" json:"cpuCoreLimit,omitempty"`

	// LiveStreamId The live stream id.
	LiveStreamId *string `form:"liveStreamId,omitempty" json:"liveStreamId,omitempty"`

	// EnableMpegtsM2TsMode Optional. Whether to enable the MpegtsM2Ts mode.
	EnableMpegtsM2TsMode *bool `form:"enableMpegtsM2TsMode,omitempty" json:"enableMpegtsM2TsMode,omitempty"`

	// VideoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv.
	VideoCodec *string `form:"videoCodec,omitempty" json:"videoCodec,omitempty"`

	// SubtitleCodec Optional. Specify a subtitle codec to encode to.
	SubtitleCodec *string `form:"subtitleCodec,omitempty" json:"subtitleCodec,omitempty"`

	// TranscodeReasons Optional. The transcoding reason.
	TranscodeReasons *string `form:"transcodeReasons,omitempty" json:"transcodeReasons,omitempty"`

	// AudioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
	AudioStreamIndex *int32 `form:"audioStreamIndex,omitempty" json:"audioStreamIndex,omitempty"`

	// VideoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
	VideoStreamIndex *int32 `form:"videoStreamIndex,omitempty" json:"videoStreamIndex,omitempty"`

	// Context Optional. The MediaBrowser.Model.Dlna.EncodingContext.
	Context *EncodingContext `form:"context,omitempty" json:"context,omitempty"`

	// StreamOptions Optional. The streaming options.
	StreamOptions *map[string]*string `form:"streamOptions,omitempty" json:"streamOptions,omitempty"`
}

// GetSubtitlePlaylistParams defines parameters for GetSubtitlePlaylist.
type GetSubtitlePlaylistParams struct {
	// SegmentLength The subtitle segment length.
	SegmentLength int32 `form:"segmentLength" json:"segmentLength"`
}

// GetSubtitleParams defines parameters for GetSubtitle.
type GetSubtitleParams struct {
	// ItemId The item id.
	ItemId *openapi_types.UUID `form:"itemId,omitempty" json:"itemId,omitempty"`

	// MediaSourceId The media source id.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// Index The subtitle stream index.
	Index *int32 `form:"index,omitempty" json:"index,omitempty"`

	// Format The format of the returned subtitle.
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// EndPositionTicks Optional. The end position of the subtitle in ticks.
	EndPositionTicks *int64 `form:"endPositionTicks,omitempty" json:"endPositionTicks,omitempty"`

	// CopyTimestamps Optional. Whether to copy the timestamps.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// AddVttTimeMap Optional. Whether to add a VTT time map.
	AddVttTimeMap *bool `form:"addVttTimeMap,omitempty" json:"addVttTimeMap,omitempty"`

	// StartPositionTicks The start position of the subtitle in ticks.
	StartPositionTicks *int64 `form:"startPositionTicks,omitempty" json:"startPositionTicks,omitempty"`
}

// GetSubtitleWithTicksParams defines parameters for GetSubtitleWithTicks.
type GetSubtitleWithTicksParams struct {
	// ItemId The item id.
	ItemId *openapi_types.UUID `form:"itemId,omitempty" json:"itemId,omitempty"`

	// MediaSourceId The media source id.
	MediaSourceId *string `form:"mediaSourceId,omitempty" json:"mediaSourceId,omitempty"`

	// Index The subtitle stream index.
	Index *int32 `form:"index,omitempty" json:"index,omitempty"`

	// StartPositionTicks The start position of the subtitle in ticks.
	StartPositionTicks *int64 `form:"startPositionTicks,omitempty" json:"startPositionTicks,omitempty"`

	// Format The format of the returned subtitle.
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// EndPositionTicks Optional. The end position of the subtitle in ticks.
	EndPositionTicks *int64 `form:"endPositionTicks,omitempty" json:"endPositionTicks,omitempty"`

	// CopyTimestamps Optional. Whether to copy the timestamps.
	CopyTimestamps *bool `form:"copyTimestamps,omitempty" json:"copyTimestamps,omitempty"`

	// AddVttTimeMap Optional. Whether to add a VTT time map.
	AddVttTimeMap *bool `form:"addVttTimeMap,omitempty" json:"addVttTimeMap,omitempty"`
}

// GetYearsParams defines parameters for GetYears.
type GetYearsParams struct {
	// StartIndex Skips over a given number of items within the results. Use for paging.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Limit Optional. The maximum number of records to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// SortOrder Sort Order - Ascending,Descending.
	SortOrder *[]SortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`

	// ParentId Specify this to localize the search to a specific item or folder. Omit to use the root.
	ParentId *openapi_types.UUID `form:"parentId,omitempty" json:"parentId,omitempty"`

	// Fields Optional. Specify additional fields of information to return in the output.
	Fields *[]ItemFields `form:"fields,omitempty" json:"fields,omitempty"`

	// ExcludeItemTypes Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
	ExcludeItemTypes *[]BaseItemKind `form:"excludeItemTypes,omitempty" json:"excludeItemTypes,omitempty"`

	// IncludeItemTypes Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
	IncludeItemTypes *[]BaseItemKind `form:"includeItemTypes,omitempty" json:"includeItemTypes,omitempty"`

	// MediaTypes Optional. Filter by MediaType. Allows multiple, comma delimited.
	MediaTypes *[]string `form:"mediaTypes,omitempty" json:"mediaTypes,omitempty"`

	// SortBy Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
	SortBy *[]string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// EnableUserData Optional. Include user data.
	EnableUserData *bool `form:"enableUserData,omitempty" json:"enableUserData,omitempty"`

	// ImageTypeLimit Optional. The max number of images to return, per image type.
	ImageTypeLimit *int32 `form:"imageTypeLimit,omitempty" json:"imageTypeLimit,omitempty"`

	// EnableImageTypes Optional. The image types to include in the output.
	EnableImageTypes *[]ImageType `form:"enableImageTypes,omitempty" json:"enableImageTypes,omitempty"`

	// UserId User Id.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`

	// Recursive Search recursively.
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// EnableImages Optional. Include image information in output.
	EnableImages *bool `form:"enableImages,omitempty" json:"enableImages,omitempty"`
}

// GetYearParams defines parameters for GetYear.
type GetYearParams struct {
	// UserId Optional. Filter by user id, and attach user data.
	UserId *openapi_types.UUID `form:"userId,omitempty" json:"userId,omitempty"`
}

// GetDurationHistogramReportParams defines parameters for GetDurationHistogramReport.
type GetDurationHistogramReportParams struct {
	Days    *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	Filter  *string    `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetTvShowsReportParams defines parameters for GetTvShowsReport.
type GetTvShowsReportParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// GetHourlyReportParams defines parameters for GetHourlyReport.
type GetHourlyReportParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	Filter         *string    `form:"filter,omitempty" json:"filter,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// GetMovieReportParams defines parameters for GetMovieReport.
type GetMovieReportParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// GetUsageStatsParams defines parameters for GetUsageStats.
type GetUsageStatsParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	Filter         *string    `form:"filter,omitempty" json:"filter,omitempty"`
	DataType       *string    `form:"dataType,omitempty" json:"dataType,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// LoadBackupParams defines parameters for LoadBackup.
type LoadBackupParams struct {
	BackupFilePath *string `form:"backupFilePath,omitempty" json:"backupFilePath,omitempty"`
}

// CustomQueryApplicationWildcardPlusJSONBody defines parameters for CustomQuery.
type CustomQueryApplicationWildcardPlusJSONBody = CustomQueryData

// CustomQueryJSONBody defines parameters for CustomQuery.
type CustomQueryJSONBody = CustomQueryData

// GetUserReportParams defines parameters for GetUserReport.
type GetUserReportParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// IgnoreListAddParams defines parameters for IgnoreListAdd.
type IgnoreListAddParams struct {
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// IgnoreListRemoveParams defines parameters for IgnoreListRemove.
type IgnoreListRemoveParams struct {
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// GetBreakdownReportParams defines parameters for GetBreakdownReport.
type GetBreakdownReportParams struct {
	Days           *int32     `form:"days,omitempty" json:"days,omitempty"`
	EndDate        *time.Time `form:"endDate,omitempty" json:"endDate,omitempty"`
	TimezoneOffset *float32   `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// GetUserReportDataParams defines parameters for GetUserReportData.
type GetUserReportDataParams struct {
	Filter         *string  `form:"filter,omitempty" json:"filter,omitempty"`
	TimezoneOffset *float32 `form:"timezoneOffset,omitempty" json:"timezoneOffset,omitempty"`
}

// GetDashboardConfigurationPageParams defines parameters for GetDashboardConfigurationPage.
type GetDashboardConfigurationPageParams struct {
	// Name The name of the page.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetConfigurationPagesParams defines parameters for GetConfigurationPages.
type GetConfigurationPagesParams struct {
	// EnableInMainMenu Whether to enable in the main menu.
	EnableInMainMenu *bool `form:"enableInMainMenu,omitempty" json:"enableInMainMenu,omitempty"`
}

// LogFileTextRequestBody defines body for LogFile for text/plain ContentType.
type LogFileTextRequestBody = LogFileTextBody

// UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody defines body for UpdateDeviceOptions for application/*+json ContentType.
type UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody = UpdateDeviceOptionsApplicationWildcardPlusJSONBody

// UpdateDeviceOptionsJSONRequestBody defines body for UpdateDeviceOptions for application/json ContentType.
type UpdateDeviceOptionsJSONRequestBody = UpdateDeviceOptionsJSONBody

// UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody defines body for UpdateDisplayPreferences for application/*+json ContentType.
type UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody = UpdateDisplayPreferencesApplicationWildcardPlusJSONBody

// UpdateDisplayPreferencesJSONRequestBody defines body for UpdateDisplayPreferences for application/json ContentType.
type UpdateDisplayPreferencesJSONRequestBody = UpdateDisplayPreferencesJSONBody

// CreateProfileApplicationWildcardPlusJSONRequestBody defines body for CreateProfile for application/*+json ContentType.
type CreateProfileApplicationWildcardPlusJSONRequestBody = CreateProfileApplicationWildcardPlusJSONBody

// CreateProfileJSONRequestBody defines body for CreateProfile for application/json ContentType.
type CreateProfileJSONRequestBody = CreateProfileJSONBody

// UpdateProfileApplicationWildcardPlusJSONRequestBody defines body for UpdateProfile for application/*+json ContentType.
type UpdateProfileApplicationWildcardPlusJSONRequestBody = UpdateProfileApplicationWildcardPlusJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody = UpdateProfileJSONBody

// ValidatePathApplicationWildcardPlusJSONRequestBody defines body for ValidatePath for application/*+json ContentType.
type ValidatePathApplicationWildcardPlusJSONRequestBody = ValidatePathApplicationWildcardPlusJSONBody

// ValidatePathJSONRequestBody defines body for ValidatePath for application/json ContentType.
type ValidatePathJSONRequestBody = ValidatePathJSONBody

// ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody defines body for ApplySearchCriteria for application/*+json ContentType.
type ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody = ApplySearchCriteriaApplicationWildcardPlusJSONBody

// ApplySearchCriteriaJSONRequestBody defines body for ApplySearchCriteria for application/json ContentType.
type ApplySearchCriteriaJSONRequestBody = ApplySearchCriteriaJSONBody

// GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetBookRemoteSearchResults for application/*+json ContentType.
type GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetBookRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetBookRemoteSearchResultsJSONRequestBody defines body for GetBookRemoteSearchResults for application/json ContentType.
type GetBookRemoteSearchResultsJSONRequestBody = GetBookRemoteSearchResultsJSONBody

// GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetBoxSetRemoteSearchResults for application/*+json ContentType.
type GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetBoxSetRemoteSearchResultsJSONRequestBody defines body for GetBoxSetRemoteSearchResults for application/json ContentType.
type GetBoxSetRemoteSearchResultsJSONRequestBody = GetBoxSetRemoteSearchResultsJSONBody

// GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetMovieRemoteSearchResults for application/*+json ContentType.
type GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetMovieRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetMovieRemoteSearchResultsJSONRequestBody defines body for GetMovieRemoteSearchResults for application/json ContentType.
type GetMovieRemoteSearchResultsJSONRequestBody = GetMovieRemoteSearchResultsJSONBody

// GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetMusicAlbumRemoteSearchResults for application/*+json ContentType.
type GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetMusicAlbumRemoteSearchResultsJSONRequestBody defines body for GetMusicAlbumRemoteSearchResults for application/json ContentType.
type GetMusicAlbumRemoteSearchResultsJSONRequestBody = GetMusicAlbumRemoteSearchResultsJSONBody

// GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetMusicArtistRemoteSearchResults for application/*+json ContentType.
type GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetMusicArtistRemoteSearchResultsJSONRequestBody defines body for GetMusicArtistRemoteSearchResults for application/json ContentType.
type GetMusicArtistRemoteSearchResultsJSONRequestBody = GetMusicArtistRemoteSearchResultsJSONBody

// GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetMusicVideoRemoteSearchResults for application/*+json ContentType.
type GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetMusicVideoRemoteSearchResultsJSONRequestBody defines body for GetMusicVideoRemoteSearchResults for application/json ContentType.
type GetMusicVideoRemoteSearchResultsJSONRequestBody = GetMusicVideoRemoteSearchResultsJSONBody

// GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetPersonRemoteSearchResults for application/*+json ContentType.
type GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetPersonRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetPersonRemoteSearchResultsJSONRequestBody defines body for GetPersonRemoteSearchResults for application/json ContentType.
type GetPersonRemoteSearchResultsJSONRequestBody = GetPersonRemoteSearchResultsJSONBody

// GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetSeriesRemoteSearchResults for application/*+json ContentType.
type GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetSeriesRemoteSearchResultsJSONRequestBody defines body for GetSeriesRemoteSearchResults for application/json ContentType.
type GetSeriesRemoteSearchResultsJSONRequestBody = GetSeriesRemoteSearchResultsJSONBody

// GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody defines body for GetTrailerRemoteSearchResults for application/*+json ContentType.
type GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody = GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONBody

// GetTrailerRemoteSearchResultsJSONRequestBody defines body for GetTrailerRemoteSearchResults for application/json ContentType.
type GetTrailerRemoteSearchResultsJSONRequestBody = GetTrailerRemoteSearchResultsJSONBody

// UpdateItemApplicationWildcardPlusJSONRequestBody defines body for UpdateItem for application/*+json ContentType.
type UpdateItemApplicationWildcardPlusJSONRequestBody = UpdateItemApplicationWildcardPlusJSONBody

// UpdateItemJSONRequestBody defines body for UpdateItem for application/json ContentType.
type UpdateItemJSONRequestBody = UpdateItemJSONBody

// GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody defines body for GetPostedPlaybackInfo for application/*+json ContentType.
type GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody = GetPostedPlaybackInfoApplicationWildcardPlusJSONBody

// GetPostedPlaybackInfoJSONRequestBody defines body for GetPostedPlaybackInfo for application/json ContentType.
type GetPostedPlaybackInfoJSONRequestBody = GetPostedPlaybackInfoJSONBody

// ValidateLoginInfoApplicationWildcardPlusJSONRequestBody defines body for ValidateLoginInfo for application/*+json ContentType.
type ValidateLoginInfoApplicationWildcardPlusJSONRequestBody = ValidateLoginInfoApplicationWildcardPlusJSONBody

// ValidateLoginInfoJSONRequestBody defines body for ValidateLoginInfo for application/json ContentType.
type ValidateLoginInfoJSONRequestBody = ValidateLoginInfoJSONBody

// PostUpdatedMediaApplicationWildcardPlusJSONRequestBody defines body for PostUpdatedMedia for application/*+json ContentType.
type PostUpdatedMediaApplicationWildcardPlusJSONRequestBody = PostUpdatedMediaApplicationWildcardPlusJSONBody

// PostUpdatedMediaJSONRequestBody defines body for PostUpdatedMedia for application/json ContentType.
type PostUpdatedMediaJSONRequestBody = PostUpdatedMediaJSONBody

// AddVirtualFolderApplicationWildcardPlusJSONRequestBody defines body for AddVirtualFolder for application/*+json ContentType.
type AddVirtualFolderApplicationWildcardPlusJSONRequestBody = AddVirtualFolderApplicationWildcardPlusJSONBody

// AddVirtualFolderJSONRequestBody defines body for AddVirtualFolder for application/json ContentType.
type AddVirtualFolderJSONRequestBody = AddVirtualFolderJSONBody

// UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody defines body for UpdateLibraryOptions for application/*+json ContentType.
type UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody = UpdateLibraryOptionsApplicationWildcardPlusJSONBody

// UpdateLibraryOptionsJSONRequestBody defines body for UpdateLibraryOptions for application/json ContentType.
type UpdateLibraryOptionsJSONRequestBody = UpdateLibraryOptionsJSONBody

// AddMediaPathApplicationWildcardPlusJSONRequestBody defines body for AddMediaPath for application/*+json ContentType.
type AddMediaPathApplicationWildcardPlusJSONRequestBody = AddMediaPathApplicationWildcardPlusJSONBody

// AddMediaPathJSONRequestBody defines body for AddMediaPath for application/json ContentType.
type AddMediaPathJSONRequestBody = AddMediaPathJSONBody

// UpdateMediaPathApplicationWildcardPlusJSONRequestBody defines body for UpdateMediaPath for application/*+json ContentType.
type UpdateMediaPathApplicationWildcardPlusJSONRequestBody = UpdateMediaPathApplicationWildcardPlusJSONBody

// UpdateMediaPathJSONRequestBody defines body for UpdateMediaPath for application/json ContentType.
type UpdateMediaPathJSONRequestBody = UpdateMediaPathJSONBody

// OpenLiveStreamApplicationWildcardPlusJSONRequestBody defines body for OpenLiveStream for application/*+json ContentType.
type OpenLiveStreamApplicationWildcardPlusJSONRequestBody = OpenLiveStreamApplicationWildcardPlusJSONBody

// OpenLiveStreamJSONRequestBody defines body for OpenLiveStream for application/json ContentType.
type OpenLiveStreamJSONRequestBody = OpenLiveStreamJSONBody

// SetChannelMappingApplicationWildcardPlusJSONRequestBody defines body for SetChannelMapping for application/*+json ContentType.
type SetChannelMappingApplicationWildcardPlusJSONRequestBody = SetChannelMappingApplicationWildcardPlusJSONBody

// SetChannelMappingJSONRequestBody defines body for SetChannelMapping for application/json ContentType.
type SetChannelMappingJSONRequestBody = SetChannelMappingJSONBody

// AddListingProviderApplicationWildcardPlusJSONRequestBody defines body for AddListingProvider for application/*+json ContentType.
type AddListingProviderApplicationWildcardPlusJSONRequestBody = AddListingProviderApplicationWildcardPlusJSONBody

// AddListingProviderJSONRequestBody defines body for AddListingProvider for application/json ContentType.
type AddListingProviderJSONRequestBody = AddListingProviderJSONBody

// GetProgramsApplicationWildcardPlusJSONRequestBody defines body for GetPrograms for application/*+json ContentType.
type GetProgramsApplicationWildcardPlusJSONRequestBody = GetProgramsApplicationWildcardPlusJSONBody

// GetProgramsJSONRequestBody defines body for GetPrograms for application/json ContentType.
type GetProgramsJSONRequestBody = GetProgramsJSONBody

// CreateSeriesTimerApplicationWildcardPlusJSONRequestBody defines body for CreateSeriesTimer for application/*+json ContentType.
type CreateSeriesTimerApplicationWildcardPlusJSONRequestBody = CreateSeriesTimerApplicationWildcardPlusJSONBody

// CreateSeriesTimerJSONRequestBody defines body for CreateSeriesTimer for application/json ContentType.
type CreateSeriesTimerJSONRequestBody = CreateSeriesTimerJSONBody

// UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody defines body for UpdateSeriesTimer for application/*+json ContentType.
type UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody = UpdateSeriesTimerApplicationWildcardPlusJSONBody

// UpdateSeriesTimerJSONRequestBody defines body for UpdateSeriesTimer for application/json ContentType.
type UpdateSeriesTimerJSONRequestBody = UpdateSeriesTimerJSONBody

// CreateTimerApplicationWildcardPlusJSONRequestBody defines body for CreateTimer for application/*+json ContentType.
type CreateTimerApplicationWildcardPlusJSONRequestBody = CreateTimerApplicationWildcardPlusJSONBody

// CreateTimerJSONRequestBody defines body for CreateTimer for application/json ContentType.
type CreateTimerJSONRequestBody = CreateTimerJSONBody

// UpdateTimerApplicationWildcardPlusJSONRequestBody defines body for UpdateTimer for application/*+json ContentType.
type UpdateTimerApplicationWildcardPlusJSONRequestBody = UpdateTimerApplicationWildcardPlusJSONBody

// UpdateTimerJSONRequestBody defines body for UpdateTimer for application/json ContentType.
type UpdateTimerJSONRequestBody = UpdateTimerJSONBody

// AddTunerHostApplicationWildcardPlusJSONRequestBody defines body for AddTunerHost for application/*+json ContentType.
type AddTunerHostApplicationWildcardPlusJSONRequestBody = AddTunerHostApplicationWildcardPlusJSONBody

// AddTunerHostJSONRequestBody defines body for AddTunerHost for application/json ContentType.
type AddTunerHostJSONRequestBody = AddTunerHostJSONBody

// CreateAdminNotificationApplicationWildcardPlusJSONRequestBody defines body for CreateAdminNotification for application/*+json ContentType.
type CreateAdminNotificationApplicationWildcardPlusJSONRequestBody = CreateAdminNotificationApplicationWildcardPlusJSONBody

// CreateAdminNotificationJSONRequestBody defines body for CreateAdminNotification for application/json ContentType.
type CreateAdminNotificationJSONRequestBody = CreateAdminNotificationJSONBody

// CreatePlaylistApplicationWildcardPlusJSONRequestBody defines body for CreatePlaylist for application/*+json ContentType.
type CreatePlaylistApplicationWildcardPlusJSONRequestBody = CreatePlaylistApplicationWildcardPlusJSONBody

// CreatePlaylistJSONRequestBody defines body for CreatePlaylist for application/json ContentType.
type CreatePlaylistJSONRequestBody = CreatePlaylistJSONBody

// SetRepositoriesApplicationWildcardPlusJSONRequestBody defines body for SetRepositories for application/*+json ContentType.
type SetRepositoriesApplicationWildcardPlusJSONRequestBody = SetRepositoriesApplicationWildcardPlusJSONBody

// SetRepositoriesJSONRequestBody defines body for SetRepositories for application/json ContentType.
type SetRepositoriesJSONRequestBody = SetRepositoriesJSONBody

// UpdateTaskApplicationWildcardPlusJSONRequestBody defines body for UpdateTask for application/*+json ContentType.
type UpdateTaskApplicationWildcardPlusJSONRequestBody = UpdateTaskApplicationWildcardPlusJSONBody

// UpdateTaskJSONRequestBody defines body for UpdateTask for application/json ContentType.
type UpdateTaskJSONRequestBody = UpdateTaskJSONBody

// PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody defines body for PostFullCapabilities for application/*+json ContentType.
type PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody = PostFullCapabilitiesApplicationWildcardPlusJSONBody

// PostFullCapabilitiesJSONRequestBody defines body for PostFullCapabilities for application/json ContentType.
type PostFullCapabilitiesJSONRequestBody = PostFullCapabilitiesJSONBody

// ReportPlaybackStartApplicationWildcardPlusJSONRequestBody defines body for ReportPlaybackStart for application/*+json ContentType.
type ReportPlaybackStartApplicationWildcardPlusJSONRequestBody = ReportPlaybackStartApplicationWildcardPlusJSONBody

// ReportPlaybackStartJSONRequestBody defines body for ReportPlaybackStart for application/json ContentType.
type ReportPlaybackStartJSONRequestBody = ReportPlaybackStartJSONBody

// ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody defines body for ReportPlaybackProgress for application/*+json ContentType.
type ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody = ReportPlaybackProgressApplicationWildcardPlusJSONBody

// ReportPlaybackProgressJSONRequestBody defines body for ReportPlaybackProgress for application/json ContentType.
type ReportPlaybackProgressJSONRequestBody = ReportPlaybackProgressJSONBody

// ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody defines body for ReportPlaybackStopped for application/*+json ContentType.
type ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody = ReportPlaybackStoppedApplicationWildcardPlusJSONBody

// ReportPlaybackStoppedJSONRequestBody defines body for ReportPlaybackStopped for application/json ContentType.
type ReportPlaybackStoppedJSONRequestBody = ReportPlaybackStoppedJSONBody

// SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody defines body for SendFullGeneralCommand for application/*+json ContentType.
type SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody = SendFullGeneralCommandApplicationWildcardPlusJSONBody

// SendFullGeneralCommandJSONRequestBody defines body for SendFullGeneralCommand for application/json ContentType.
type SendFullGeneralCommandJSONRequestBody = SendFullGeneralCommandJSONBody

// SendMessageCommandApplicationWildcardPlusJSONRequestBody defines body for SendMessageCommand for application/*+json ContentType.
type SendMessageCommandApplicationWildcardPlusJSONRequestBody = SendMessageCommandApplicationWildcardPlusJSONBody

// SendMessageCommandJSONRequestBody defines body for SendMessageCommand for application/json ContentType.
type SendMessageCommandJSONRequestBody = SendMessageCommandJSONBody

// UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody defines body for UpdateInitialConfiguration for application/*+json ContentType.
type UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody = UpdateInitialConfigurationApplicationWildcardPlusJSONBody

// UpdateInitialConfigurationJSONRequestBody defines body for UpdateInitialConfiguration for application/json ContentType.
type UpdateInitialConfigurationJSONRequestBody = UpdateInitialConfigurationJSONBody

// SetRemoteAccessApplicationWildcardPlusJSONRequestBody defines body for SetRemoteAccess for application/*+json ContentType.
type SetRemoteAccessApplicationWildcardPlusJSONRequestBody = SetRemoteAccessApplicationWildcardPlusJSONBody

// SetRemoteAccessJSONRequestBody defines body for SetRemoteAccess for application/json ContentType.
type SetRemoteAccessJSONRequestBody = SetRemoteAccessJSONBody

// UpdateStartupUserApplicationWildcardPlusJSONRequestBody defines body for UpdateStartupUser for application/*+json ContentType.
type UpdateStartupUserApplicationWildcardPlusJSONRequestBody = UpdateStartupUserApplicationWildcardPlusJSONBody

// UpdateStartupUserJSONRequestBody defines body for UpdateStartupUser for application/json ContentType.
type UpdateStartupUserJSONRequestBody = UpdateStartupUserJSONBody

// SyncPlayBufferingApplicationWildcardPlusJSONRequestBody defines body for SyncPlayBuffering for application/*+json ContentType.
type SyncPlayBufferingApplicationWildcardPlusJSONRequestBody = SyncPlayBufferingApplicationWildcardPlusJSONBody

// SyncPlayBufferingJSONRequestBody defines body for SyncPlayBuffering for application/json ContentType.
type SyncPlayBufferingJSONRequestBody = SyncPlayBufferingJSONBody

// SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody defines body for SyncPlayJoinGroup for application/*+json ContentType.
type SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody = SyncPlayJoinGroupApplicationWildcardPlusJSONBody

// SyncPlayJoinGroupJSONRequestBody defines body for SyncPlayJoinGroup for application/json ContentType.
type SyncPlayJoinGroupJSONRequestBody = SyncPlayJoinGroupJSONBody

// SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody defines body for SyncPlayMovePlaylistItem for application/*+json ContentType.
type SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody = SyncPlayMovePlaylistItemApplicationWildcardPlusJSONBody

// SyncPlayMovePlaylistItemJSONRequestBody defines body for SyncPlayMovePlaylistItem for application/json ContentType.
type SyncPlayMovePlaylistItemJSONRequestBody = SyncPlayMovePlaylistItemJSONBody

// SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody defines body for SyncPlayCreateGroup for application/*+json ContentType.
type SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody = SyncPlayCreateGroupApplicationWildcardPlusJSONBody

// SyncPlayCreateGroupJSONRequestBody defines body for SyncPlayCreateGroup for application/json ContentType.
type SyncPlayCreateGroupJSONRequestBody = SyncPlayCreateGroupJSONBody

// SyncPlayNextItemApplicationWildcardPlusJSONRequestBody defines body for SyncPlayNextItem for application/*+json ContentType.
type SyncPlayNextItemApplicationWildcardPlusJSONRequestBody = SyncPlayNextItemApplicationWildcardPlusJSONBody

// SyncPlayNextItemJSONRequestBody defines body for SyncPlayNextItem for application/json ContentType.
type SyncPlayNextItemJSONRequestBody = SyncPlayNextItemJSONBody

// SyncPlayPingApplicationWildcardPlusJSONRequestBody defines body for SyncPlayPing for application/*+json ContentType.
type SyncPlayPingApplicationWildcardPlusJSONRequestBody = SyncPlayPingApplicationWildcardPlusJSONBody

// SyncPlayPingJSONRequestBody defines body for SyncPlayPing for application/json ContentType.
type SyncPlayPingJSONRequestBody = SyncPlayPingJSONBody

// SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody defines body for SyncPlayPreviousItem for application/*+json ContentType.
type SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody = SyncPlayPreviousItemApplicationWildcardPlusJSONBody

// SyncPlayPreviousItemJSONRequestBody defines body for SyncPlayPreviousItem for application/json ContentType.
type SyncPlayPreviousItemJSONRequestBody = SyncPlayPreviousItemJSONBody

// SyncPlayQueueApplicationWildcardPlusJSONRequestBody defines body for SyncPlayQueue for application/*+json ContentType.
type SyncPlayQueueApplicationWildcardPlusJSONRequestBody = SyncPlayQueueApplicationWildcardPlusJSONBody

// SyncPlayQueueJSONRequestBody defines body for SyncPlayQueue for application/json ContentType.
type SyncPlayQueueJSONRequestBody = SyncPlayQueueJSONBody

// SyncPlayReadyApplicationWildcardPlusJSONRequestBody defines body for SyncPlayReady for application/*+json ContentType.
type SyncPlayReadyApplicationWildcardPlusJSONRequestBody = SyncPlayReadyApplicationWildcardPlusJSONBody

// SyncPlayReadyJSONRequestBody defines body for SyncPlayReady for application/json ContentType.
type SyncPlayReadyJSONRequestBody = SyncPlayReadyJSONBody

// SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody defines body for SyncPlayRemoveFromPlaylist for application/*+json ContentType.
type SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody = SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONBody

// SyncPlayRemoveFromPlaylistJSONRequestBody defines body for SyncPlayRemoveFromPlaylist for application/json ContentType.
type SyncPlayRemoveFromPlaylistJSONRequestBody = SyncPlayRemoveFromPlaylistJSONBody

// SyncPlaySeekApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySeek for application/*+json ContentType.
type SyncPlaySeekApplicationWildcardPlusJSONRequestBody = SyncPlaySeekApplicationWildcardPlusJSONBody

// SyncPlaySeekJSONRequestBody defines body for SyncPlaySeek for application/json ContentType.
type SyncPlaySeekJSONRequestBody = SyncPlaySeekJSONBody

// SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySetIgnoreWait for application/*+json ContentType.
type SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody = SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONBody

// SyncPlaySetIgnoreWaitJSONRequestBody defines body for SyncPlaySetIgnoreWait for application/json ContentType.
type SyncPlaySetIgnoreWaitJSONRequestBody = SyncPlaySetIgnoreWaitJSONBody

// SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySetNewQueue for application/*+json ContentType.
type SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody = SyncPlaySetNewQueueApplicationWildcardPlusJSONBody

// SyncPlaySetNewQueueJSONRequestBody defines body for SyncPlaySetNewQueue for application/json ContentType.
type SyncPlaySetNewQueueJSONRequestBody = SyncPlaySetNewQueueJSONBody

// SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySetPlaylistItem for application/*+json ContentType.
type SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody = SyncPlaySetPlaylistItemApplicationWildcardPlusJSONBody

// SyncPlaySetPlaylistItemJSONRequestBody defines body for SyncPlaySetPlaylistItem for application/json ContentType.
type SyncPlaySetPlaylistItemJSONRequestBody = SyncPlaySetPlaylistItemJSONBody

// SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySetRepeatMode for application/*+json ContentType.
type SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody = SyncPlaySetRepeatModeApplicationWildcardPlusJSONBody

// SyncPlaySetRepeatModeJSONRequestBody defines body for SyncPlaySetRepeatMode for application/json ContentType.
type SyncPlaySetRepeatModeJSONRequestBody = SyncPlaySetRepeatModeJSONBody

// SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody defines body for SyncPlaySetShuffleMode for application/*+json ContentType.
type SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody = SyncPlaySetShuffleModeApplicationWildcardPlusJSONBody

// SyncPlaySetShuffleModeJSONRequestBody defines body for SyncPlaySetShuffleMode for application/json ContentType.
type SyncPlaySetShuffleModeJSONRequestBody = SyncPlaySetShuffleModeJSONBody

// UpdateConfigurationApplicationWildcardPlusJSONRequestBody defines body for UpdateConfiguration for application/*+json ContentType.
type UpdateConfigurationApplicationWildcardPlusJSONRequestBody = UpdateConfigurationApplicationWildcardPlusJSONBody

// UpdateConfigurationJSONRequestBody defines body for UpdateConfiguration for application/json ContentType.
type UpdateConfigurationJSONRequestBody = UpdateConfigurationJSONBody

// UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody defines body for UpdateNamedConfiguration for application/*+json ContentType.
type UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody = UpdateNamedConfigurationApplicationWildcardPlusJSONBody

// UpdateNamedConfigurationJSONRequestBody defines body for UpdateNamedConfiguration for application/json ContentType.
type UpdateNamedConfigurationJSONRequestBody = UpdateNamedConfigurationJSONBody

// UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody defines body for UpdateMediaEncoderPath for application/*+json ContentType.
type UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody = UpdateMediaEncoderPathApplicationWildcardPlusJSONBody

// UpdateMediaEncoderPathJSONRequestBody defines body for UpdateMediaEncoderPath for application/json ContentType.
type UpdateMediaEncoderPathJSONRequestBody = UpdateMediaEncoderPathJSONBody

// AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody defines body for AuthenticateUserByName for application/*+json ContentType.
type AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody = AuthenticateUserByNameApplicationWildcardPlusJSONBody

// AuthenticateUserByNameJSONRequestBody defines body for AuthenticateUserByName for application/json ContentType.
type AuthenticateUserByNameJSONRequestBody = AuthenticateUserByNameJSONBody

// AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody defines body for AuthenticateWithQuickConnect for application/*+json ContentType.
type AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody = AuthenticateWithQuickConnectApplicationWildcardPlusJSONBody

// AuthenticateWithQuickConnectJSONRequestBody defines body for AuthenticateWithQuickConnect for application/json ContentType.
type AuthenticateWithQuickConnectJSONRequestBody = AuthenticateWithQuickConnectJSONBody

// ForgotPasswordApplicationWildcardPlusJSONRequestBody defines body for ForgotPassword for application/*+json ContentType.
type ForgotPasswordApplicationWildcardPlusJSONRequestBody = ForgotPasswordApplicationWildcardPlusJSONBody

// ForgotPasswordJSONRequestBody defines body for ForgotPassword for application/json ContentType.
type ForgotPasswordJSONRequestBody = ForgotPasswordJSONBody

// ForgotPasswordPinApplicationWildcardPlusJSONRequestBody defines body for ForgotPasswordPin for application/*+json ContentType.
type ForgotPasswordPinApplicationWildcardPlusJSONRequestBody = ForgotPasswordPinApplicationWildcardPlusJSONBody

// ForgotPasswordPinJSONRequestBody defines body for ForgotPasswordPin for application/json ContentType.
type ForgotPasswordPinJSONRequestBody = ForgotPasswordPinJSONBody

// CreateUserByNameApplicationWildcardPlusJSONRequestBody defines body for CreateUserByName for application/*+json ContentType.
type CreateUserByNameApplicationWildcardPlusJSONRequestBody = CreateUserByNameApplicationWildcardPlusJSONBody

// CreateUserByNameJSONRequestBody defines body for CreateUserByName for application/json ContentType.
type CreateUserByNameJSONRequestBody = CreateUserByNameJSONBody

// UpdateUserApplicationWildcardPlusJSONRequestBody defines body for UpdateUser for application/*+json ContentType.
type UpdateUserApplicationWildcardPlusJSONRequestBody = UpdateUserApplicationWildcardPlusJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserJSONBody

// UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody defines body for UpdateUserConfiguration for application/*+json ContentType.
type UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody = UpdateUserConfigurationApplicationWildcardPlusJSONBody

// UpdateUserConfigurationJSONRequestBody defines body for UpdateUserConfiguration for application/json ContentType.
type UpdateUserConfigurationJSONRequestBody = UpdateUserConfigurationJSONBody

// UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody defines body for UpdateUserEasyPassword for application/*+json ContentType.
type UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody = UpdateUserEasyPasswordApplicationWildcardPlusJSONBody

// UpdateUserEasyPasswordJSONRequestBody defines body for UpdateUserEasyPassword for application/json ContentType.
type UpdateUserEasyPasswordJSONRequestBody = UpdateUserEasyPasswordJSONBody

// UpdateUserPasswordApplicationWildcardPlusJSONRequestBody defines body for UpdateUserPassword for application/*+json ContentType.
type UpdateUserPasswordApplicationWildcardPlusJSONRequestBody = UpdateUserPasswordApplicationWildcardPlusJSONBody

// UpdateUserPasswordJSONRequestBody defines body for UpdateUserPassword for application/json ContentType.
type UpdateUserPasswordJSONRequestBody = UpdateUserPasswordJSONBody

// UpdateUserPolicyApplicationWildcardPlusJSONRequestBody defines body for UpdateUserPolicy for application/*+json ContentType.
type UpdateUserPolicyApplicationWildcardPlusJSONRequestBody = UpdateUserPolicyApplicationWildcardPlusJSONBody

// UpdateUserPolicyJSONRequestBody defines body for UpdateUserPolicy for application/json ContentType.
type UpdateUserPolicyJSONRequestBody = UpdateUserPolicyJSONBody

// UploadSubtitleApplicationWildcardPlusJSONRequestBody defines body for UploadSubtitle for application/*+json ContentType.
type UploadSubtitleApplicationWildcardPlusJSONRequestBody = UploadSubtitleApplicationWildcardPlusJSONBody

// UploadSubtitleJSONRequestBody defines body for UploadSubtitle for application/json ContentType.
type UploadSubtitleJSONRequestBody = UploadSubtitleJSONBody

// CustomQueryApplicationWildcardPlusJSONRequestBody defines body for CustomQuery for application/*+json ContentType.
type CustomQueryApplicationWildcardPlusJSONRequestBody = CustomQueryApplicationWildcardPlusJSONBody

// CustomQueryJSONRequestBody defines body for CustomQuery for application/json ContentType.
type CustomQueryJSONRequestBody = CustomQueryJSONBody

// Getter for additional properties for ProblemDetails. Returns the specified
// element and whether it was found
func (a ProblemDetails) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProblemDetails
func (a *ProblemDetails) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a *ProblemDetails) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a ProblemDetails) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Detail != nil {
		object["detail"], err = json.Marshal(a.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if a.Instance != nil {
		object["instance"], err = json.Marshal(a.Instance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'instance': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetInstantMixFromAlbum request
	GetInstantMixFromAlbum(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromAlbumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarAlbums request
	GetSimilarAlbums(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtists request
	GetArtists(ctx context.Context, params *GetArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlbumArtists request
	GetAlbumArtists(ctx context.Context, params *GetAlbumArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromArtists2 request
	GetInstantMixFromArtists2(ctx context.Context, params *GetInstantMixFromArtists2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromArtists request
	GetInstantMixFromArtists(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarArtists request
	GetSimilarArtists(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtistByName request
	GetArtistByName(ctx context.Context, name string, params *GetArtistByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtistImage request
	GetArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetArtistImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadArtistImage request
	HeadArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadArtistImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsAudioSegmentLegacyAac request
	GetHlsAudioSegmentLegacyAac(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsAudioSegmentLegacyMp3 request
	GetHlsAudioSegmentLegacyMp3(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsAudioSegment request
	GetHlsAudioSegment(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsAudioSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariantHlsAudioPlaylist request
	GetVariantHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterHlsAudioPlaylist request
	GetMasterHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadMasterHlsAudioPlaylist request
	HeadMasterHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioStream request
	GetAudioStream(ctx context.Context, itemId openapi_types.UUID, params *GetAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadAudioStream request
	HeadAudioStream(ctx context.Context, itemId openapi_types.UUID, params *HeadAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioStreamByContainer request
	GetAudioStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *GetAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadAudioStreamByContainer request
	HeadAudioStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUniversalAudioStream request
	GetUniversalAudioStream(ctx context.Context, itemId openapi_types.UUID, params *GetUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadUniversalAudioStream request
	HeadUniversalAudioStream(ctx context.Context, itemId openapi_types.UUID, params *HeadUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateKey request
	CreateKey(ctx context.Context, params *CreateKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeKey request
	RevokeKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPasswordResetProviders request
	GetPasswordResetProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthProviders request
	GetAuthProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrandingOptions request
	GetBrandingOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrandingCss request
	GetBrandingCss(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBrandingCss2 request
	GetBrandingCss2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomSplashscreen request
	DeleteCustomSplashscreen(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSplashscreen request
	GetSplashscreen(ctx context.Context, params *GetSplashscreenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCustomSplashscreenWithBody request with any body
	UploadCustomSplashscreenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannels request
	GetChannels(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllChannelFeatures request
	GetAllChannelFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestChannelItems request
	GetLatestChannelItems(ctx context.Context, params *GetLatestChannelItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelFeatures request
	GetChannelFeatures(ctx context.Context, channelId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelItems request
	GetChannelItems(ctx context.Context, channelId openapi_types.UUID, params *GetChannelItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogFileWithBody request with any body
	LogFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LogFileWithTextBody(ctx context.Context, body LogFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollection request
	CreateCollection(ctx context.Context, params *CreateCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveFromCollection request
	RemoveFromCollection(ctx context.Context, collectionId openapi_types.UUID, params *RemoveFromCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddToCollection request
	AddToCollection(ctx context.Context, collectionId openapi_types.UUID, params *AddToCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevices request
	GetDevices(ctx context.Context, params *GetDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeviceInfo request
	GetDeviceInfo(ctx context.Context, params *GetDeviceInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeviceOptions request
	GetDeviceOptions(ctx context.Context, params *GetDeviceOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDeviceOptionsWithBody request with any body
	UpdateDeviceOptionsWithBody(ctx context.Context, params *UpdateDeviceOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeviceOptionsWithApplicationWildcardPlusJSONBody(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDeviceOptions(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDisplayPreferences request
	GetDisplayPreferences(ctx context.Context, displayPreferencesId string, params *GetDisplayPreferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDisplayPreferencesWithBody request with any body
	UpdateDisplayPreferencesWithBody(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDisplayPreferencesWithApplicationWildcardPlusJSONBody(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDisplayPreferences(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfileInfos request
	GetProfileInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProfileWithBody request with any body
	CreateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProfileWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProfile(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultProfile request
	GetDefaultProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProfile request
	DeleteProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfile request
	GetProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfileWithApplicationWildcardPlusJSONBody(ctx context.Context, profileId string, body UpdateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIcon request
	GetIcon(ctx context.Context, fileName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionManager request
	GetConnectionManager(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionManager2 request
	GetConnectionManager2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionManager3 request
	GetConnectionManager3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessConnectionManagerControlRequest request
	ProcessConnectionManagerControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentDirectory request
	GetContentDirectory(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentDirectory2 request
	GetContentDirectory2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentDirectory3 request
	GetContentDirectory3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessContentDirectoryControlRequest request
	ProcessContentDirectoryControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaReceiverRegistrar request
	GetMediaReceiverRegistrar(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessMediaReceiverRegistrarControlRequest request
	ProcessMediaReceiverRegistrarControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaReceiverRegistrar2 request
	GetMediaReceiverRegistrar2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaReceiverRegistrar3 request
	GetMediaReceiverRegistrar3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDescriptionXml request
	GetDescriptionXml(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDescriptionXml2 request
	GetDescriptionXml2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIconId request
	GetIconId(ctx context.Context, serverId string, fileName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultDirectoryBrowser request
	GetDefaultDirectoryBrowser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDirectoryContents request
	GetDirectoryContents(ctx context.Context, params *GetDirectoryContentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDrives request
	GetDrives(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkShares request
	GetNetworkShares(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParentPath request
	GetParentPath(ctx context.Context, params *GetParentPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidatePathWithBody request with any body
	ValidatePathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidatePathWithApplicationWildcardPlusJSONBody(ctx context.Context, body ValidatePathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidatePath(ctx context.Context, body ValidatePathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFallbackFontList request
	GetFallbackFontList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFallbackFont request
	GetFallbackFont(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenres request
	GetGenres(ctx context.Context, params *GetGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenre request
	GetGenre(ctx context.Context, genreName string, params *GetGenreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenreImage request
	GetGenreImage(ctx context.Context, name string, imageType ImageType, params *GetGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadGenreImage request
	HeadGenreImage(ctx context.Context, name string, imageType ImageType, params *HeadGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenreImageByIndex request
	GetGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadGenreImageByIndex request
	HeadGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUtcTime request
	GetUtcTime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGeneralImages request
	GetGeneralImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGeneralImage request
	GetGeneralImage(ctx context.Context, name string, pType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaInfoImages request
	GetMediaInfoImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaInfoImage request
	GetMediaInfoImage(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRatingImages request
	GetRatingImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRatingImage request
	GetRatingImage(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItems request
	DeleteItems(ctx context.Context, params *DeleteItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItems request
	GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemCounts request
	GetItemCounts(ctx context.Context, params *GetItemCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueryFiltersLegacy request
	GetQueryFiltersLegacy(ctx context.Context, params *GetQueryFiltersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueryFilters request
	GetQueryFilters(ctx context.Context, params *GetQueryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApplySearchCriteriaWithBody request with any body
	ApplySearchCriteriaWithBody(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplySearchCriteriaWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplySearchCriteria(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBookRemoteSearchResultsWithBody request with any body
	GetBookRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBookRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBookRemoteSearchResults(ctx context.Context, body GetBookRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBoxSetRemoteSearchResultsWithBody request with any body
	GetBoxSetRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBoxSetRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBoxSetRemoteSearchResults(ctx context.Context, body GetBoxSetRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieRemoteSearchResultsWithBody request with any body
	GetMovieRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMovieRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMovieRemoteSearchResults(ctx context.Context, body GetMovieRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicAlbumRemoteSearchResultsWithBody request with any body
	GetMusicAlbumRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicAlbumRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicAlbumRemoteSearchResults(ctx context.Context, body GetMusicAlbumRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicArtistRemoteSearchResultsWithBody request with any body
	GetMusicArtistRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicArtistRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicArtistRemoteSearchResults(ctx context.Context, body GetMusicArtistRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicVideoRemoteSearchResultsWithBody request with any body
	GetMusicVideoRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicVideoRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetMusicVideoRemoteSearchResults(ctx context.Context, body GetMusicVideoRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonRemoteSearchResultsWithBody request with any body
	GetPersonRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPersonRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPersonRemoteSearchResults(ctx context.Context, body GetPersonRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesRemoteSearchResultsWithBody request with any body
	GetSeriesRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSeriesRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSeriesRemoteSearchResults(ctx context.Context, body GetSeriesRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrailerRemoteSearchResultsWithBody request with any body
	GetTrailerRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTrailerRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTrailerRemoteSearchResults(ctx context.Context, body GetTrailerRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromItem request
	GetInstantMixFromItem(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItem request
	DeleteItem(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemWithBody request with any body
	UpdateItemWithBody(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateItemWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, body UpdateItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateItem(ctx context.Context, itemId openapi_types.UUID, body UpdateItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAncestors request
	GetAncestors(ctx context.Context, itemId openapi_types.UUID, params *GetAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemContentType request
	UpdateItemContentType(ctx context.Context, itemId openapi_types.UUID, params *UpdateItemContentTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCriticReviews request
	GetCriticReviews(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDownload request
	GetDownload(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalIdInfos request
	GetExternalIdInfos(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemImageInfos request
	GetItemImageInfos(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItemImage request
	DeleteItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *DeleteItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemImage request
	GetItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *GetItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadItemImage request
	HeadItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *HeadItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetItemImageWithBody request with any body
	SetItemImageWithBody(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItemImageByIndex request
	DeleteItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemImageByIndex request
	GetItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetItemImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadItemImageByIndex request
	HeadItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadItemImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetItemImageByIndexWithBody request with any body
	SetItemImageByIndexWithBody(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemImageIndex request
	UpdateItemImageIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *UpdateItemImageIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemImage2 request
	GetItemImage2(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *GetItemImage2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadItemImage2 request
	HeadItemImage2(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *HeadItemImage2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetadataEditorInfo request
	GetMetadataEditorInfo(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaybackInfo request
	GetPlaybackInfo(ctx context.Context, itemId openapi_types.UUID, params *GetPlaybackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPostedPlaybackInfoWithBody request with any body
	GetPostedPlaybackInfoWithBody(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPostedPlaybackInfoWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPostedPlaybackInfo(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshItem request
	RefreshItem(ctx context.Context, itemId openapi_types.UUID, params *RefreshItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteImages request
	GetRemoteImages(ctx context.Context, itemId openapi_types.UUID, params *GetRemoteImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadRemoteImage request
	DownloadRemoteImage(ctx context.Context, itemId openapi_types.UUID, params *DownloadRemoteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteImageProviders request
	GetRemoteImageProviders(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRemoteSubtitles request
	SearchRemoteSubtitles(ctx context.Context, itemId openapi_types.UUID, language string, params *SearchRemoteSubtitlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadRemoteSubtitles request
	DownloadRemoteSubtitles(ctx context.Context, itemId openapi_types.UUID, subtitleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarItems request
	GetSimilarItems(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThemeMedia request
	GetThemeMedia(ctx context.Context, itemId openapi_types.UUID, params *GetThemeMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThemeSongs request
	GetThemeSongs(ctx context.Context, itemId openapi_types.UUID, params *GetThemeSongsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThemeVideos request
	GetThemeVideos(ctx context.Context, itemId openapi_types.UUID, params *GetThemeVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateLoginInfoWithBody request with any body
	ValidateLoginInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateLoginInfoWithApplicationWildcardPlusJSONBody(ctx context.Context, body ValidateLoginInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateLoginInfo(ctx context.Context, body ValidateLoginInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLibraryOptionsInfo request
	GetLibraryOptionsInfo(ctx context.Context, params *GetLibraryOptionsInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUpdatedMediaWithBody request with any body
	PostUpdatedMediaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUpdatedMediaWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostUpdatedMediaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUpdatedMedia(ctx context.Context, body PostUpdatedMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMediaFolders request
	GetMediaFolders(ctx context.Context, params *GetMediaFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAddedMovies request
	PostAddedMovies(ctx context.Context, params *PostAddedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUpdatedMovies request
	PostUpdatedMovies(ctx context.Context, params *PostUpdatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalPaths request
	GetPhysicalPaths(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshLibrary request
	RefreshLibrary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAddedSeries request
	PostAddedSeries(ctx context.Context, params *PostAddedSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUpdatedSeries request
	PostUpdatedSeries(ctx context.Context, params *PostUpdatedSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveVirtualFolder request
	RemoveVirtualFolder(ctx context.Context, params *RemoveVirtualFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualFolders request
	GetVirtualFolders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualFolderWithBody request with any body
	AddVirtualFolderWithBody(ctx context.Context, params *AddVirtualFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualFolderWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualFolder(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLibraryOptionsWithBody request with any body
	UpdateLibraryOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLibraryOptionsWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLibraryOptions(ctx context.Context, body UpdateLibraryOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenameVirtualFolder request
	RenameVirtualFolder(ctx context.Context, params *RenameVirtualFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMediaPath request
	RemoveMediaPath(ctx context.Context, params *RemoveMediaPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMediaPathWithBody request with any body
	AddMediaPathWithBody(ctx context.Context, params *AddMediaPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMediaPathWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddMediaPathParams, body AddMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMediaPath(ctx context.Context, params *AddMediaPathParams, body AddMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMediaPathWithBody request with any body
	UpdateMediaPathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMediaPathWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMediaPath(ctx context.Context, body UpdateMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseLiveStream request
	CloseLiveStream(ctx context.Context, params *CloseLiveStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenLiveStreamWithBody request with any body
	OpenLiveStreamWithBody(ctx context.Context, params *OpenLiveStreamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OpenLiveStreamWithApplicationWildcardPlusJSONBody(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	OpenLiveStream(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelMappingOptions request
	GetChannelMappingOptions(ctx context.Context, params *GetChannelMappingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetChannelMappingWithBody request with any body
	SetChannelMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetChannelMappingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetChannelMappingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetChannelMapping(ctx context.Context, body SetChannelMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveTvChannels request
	GetLiveTvChannels(ctx context.Context, params *GetLiveTvChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannel request
	GetChannel(ctx context.Context, channelId openapi_types.UUID, params *GetChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGuideInfo request
	GetGuideInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveTvInfo request
	GetLiveTvInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListingProvider request
	DeleteListingProvider(ctx context.Context, params *DeleteListingProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddListingProviderWithBody request with any body
	AddListingProviderWithBody(ctx context.Context, params *AddListingProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddListingProviderWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddListingProviderParams, body AddListingProviderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddListingProvider(ctx context.Context, params *AddListingProviderParams, body AddListingProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultListingProvider request
	GetDefaultListingProvider(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineups request
	GetLineups(ctx context.Context, params *GetLineupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesDirectCountries request
	GetSchedulesDirectCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveRecordingFile request
	GetLiveRecordingFile(ctx context.Context, recordingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveStreamFile request
	GetLiveStreamFile(ctx context.Context, streamId string, container string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveTvPrograms request
	GetLiveTvPrograms(ctx context.Context, params *GetLiveTvProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramsWithBody request with any body
	GetProgramsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetProgramsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetProgramsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPrograms(ctx context.Context, body GetProgramsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecommendedPrograms request
	GetRecommendedPrograms(ctx context.Context, params *GetRecommendedProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, programId string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordings request
	GetRecordings(ctx context.Context, params *GetRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordingFolders request
	GetRecordingFolders(ctx context.Context, params *GetRecordingFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordingGroups request
	GetRecordingGroups(ctx context.Context, params *GetRecordingGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordingGroup request
	GetRecordingGroup(ctx context.Context, groupId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordingsSeries request
	GetRecordingsSeries(ctx context.Context, params *GetRecordingsSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecording request
	DeleteRecording(ctx context.Context, recordingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecording request
	GetRecording(ctx context.Context, recordingId openapi_types.UUID, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesTimers request
	GetSeriesTimers(ctx context.Context, params *GetSeriesTimersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSeriesTimerWithBody request with any body
	CreateSeriesTimerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSeriesTimer(ctx context.Context, body CreateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSeriesTimer request
	CancelSeriesTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeriesTimer request
	GetSeriesTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSeriesTimerWithBody request with any body
	UpdateSeriesTimerWithBody(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, timerId string, body UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSeriesTimer(ctx context.Context, timerId string, body UpdateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimers request
	GetTimers(ctx context.Context, params *GetTimersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTimerWithBody request with any body
	CreateTimerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTimer(ctx context.Context, body CreateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultTimer request
	GetDefaultTimer(ctx context.Context, params *GetDefaultTimerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelTimer request
	CancelTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimer request
	GetTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTimerWithBody request with any body
	UpdateTimerWithBody(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, timerId string, body UpdateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTimer(ctx context.Context, timerId string, body UpdateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTunerHost request
	DeleteTunerHost(ctx context.Context, params *DeleteTunerHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTunerHostWithBody request with any body
	AddTunerHostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTunerHostWithApplicationWildcardPlusJSONBody(ctx context.Context, body AddTunerHostApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTunerHost(ctx context.Context, body AddTunerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTunerHostTypes request
	GetTunerHostTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscoverTuners request
	DiscoverTuners(ctx context.Context, params *DiscoverTunersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiscvoverTuners request
	DiscvoverTuners(ctx context.Context, params *DiscvoverTunersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetTuner request
	ResetTuner(ctx context.Context, tunerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCountries request
	GetCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCultures request
	GetCultures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocalizationOptions request
	GetLocalizationOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParentalRatings request
	GetParentalRatings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieRecommendations request
	GetMovieRecommendations(ctx context.Context, params *GetMovieRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarMovies request
	GetSimilarMovies(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicGenres request
	GetMusicGenres(ctx context.Context, params *GetMusicGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromMusicGenreById request
	GetInstantMixFromMusicGenreById(ctx context.Context, params *GetInstantMixFromMusicGenreByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicGenre request
	GetMusicGenre(ctx context.Context, genreName string, params *GetMusicGenreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicGenreImage request
	GetMusicGenreImage(ctx context.Context, name string, imageType ImageType, params *GetMusicGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadMusicGenreImage request
	HeadMusicGenreImage(ctx context.Context, name string, imageType ImageType, params *HeadMusicGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMusicGenreImageByIndex request
	GetMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadMusicGenreImageByIndex request
	HeadMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromMusicGenreByName request
	GetInstantMixFromMusicGenreByName(ctx context.Context, name string, params *GetInstantMixFromMusicGenreByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdminNotificationWithBody request with any body
	CreateAdminNotificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminNotificationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateAdminNotificationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdminNotification(ctx context.Context, body CreateAdminNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationServices request
	GetNotificationServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationTypes request
	GetNotificationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotifications request
	GetNotifications(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRead request
	SetRead(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationsSummary request
	GetNotificationsSummary(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetUnread request
	SetUnread(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackages request
	GetPackages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackage request
	InstallPackage(ctx context.Context, name string, params *InstallPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPackageInstallation request
	CancelPackageInstallation(ctx context.Context, packageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageInfo request
	GetPackageInfo(ctx context.Context, name string, params *GetPackageInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersons request
	GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPerson request
	GetPerson(ctx context.Context, name string, params *GetPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonImage request
	GetPersonImage(ctx context.Context, name string, imageType ImageType, params *GetPersonImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadPersonImage request
	HeadPersonImage(ctx context.Context, name string, imageType ImageType, params *HeadPersonImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonImageByIndex request
	GetPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadPersonImageByIndex request
	HeadPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitrateTestBytes request
	GetBitrateTestBytes(ctx context.Context, params *GetBitrateTestBytesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaylistWithBody request with any body
	CreatePlaylistWithBody(ctx context.Context, params *CreatePlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaylistWithApplicationWildcardPlusJSONBody(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaylist(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromPlaylist request
	GetInstantMixFromPlaylist(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveFromPlaylist request
	RemoveFromPlaylist(ctx context.Context, playlistId string, params *RemoveFromPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistItems request
	GetPlaylistItems(ctx context.Context, playlistId openapi_types.UUID, params *GetPlaylistItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddToPlaylist request
	AddToPlaylist(ctx context.Context, playlistId openapi_types.UUID, params *AddToPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveItem request
	MoveItem(ctx context.Context, playlistId string, itemId string, newIndex int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugins request
	GetPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallPlugin request
	UninstallPlugin(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginConfiguration request
	GetPluginConfiguration(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginConfiguration request
	UpdatePluginConfiguration(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginManifest request
	GetPluginManifest(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallPluginByVersion request
	UninstallPluginByVersion(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisablePlugin request
	DisablePlugin(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnablePlugin request
	EnablePlugin(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginImage request
	GetPluginImage(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRemoteSubtitles request
	GetRemoteSubtitles(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Connect request
	Connect(ctx context.Context, params *ConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnabled request
	GetEnabled(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Initiate request
	Initiate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityLogs request
	GetActivityLogs(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportHeaders request
	GetReportHeaders(ctx context.Context, params *GetReportHeadersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemReport request
	GetItemReport(ctx context.Context, params *GetItemReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportDownload request
	GetReportDownload(ctx context.Context, params *GetReportDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositories request
	GetRepositories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoriesWithBody request with any body
	SetRepositoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoriesWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetRepositoriesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositories(ctx context.Context, body SetRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTasks request
	GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopTask request
	StopTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTask request
	StartTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTask request
	GetTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTaskWithBody request with any body
	UpdateTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTaskWithApplicationWildcardPlusJSONBody(ctx context.Context, taskId string, body UpdateTaskApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTask(ctx context.Context, taskId string, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	Get(ctx context.Context, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessions request
	GetSessions(ctx context.Context, params *GetSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCapabilities request
	PostCapabilities(ctx context.Context, params *PostCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFullCapabilitiesWithBody request with any body
	PostFullCapabilitiesWithBody(ctx context.Context, params *PostFullCapabilitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFullCapabilitiesWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFullCapabilities(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportSessionEnded request
	ReportSessionEnded(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportPlaybackStartWithBody request with any body
	ReportPlaybackStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackStartWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackStartApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackStart(ctx context.Context, body ReportPlaybackStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PingPlaybackSession request
	PingPlaybackSession(ctx context.Context, params *PingPlaybackSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportPlaybackProgressWithBody request with any body
	ReportPlaybackProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackProgressWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackProgress(ctx context.Context, body ReportPlaybackProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportPlaybackStoppedWithBody request with any body
	ReportPlaybackStoppedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackStoppedWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportPlaybackStopped(ctx context.Context, body ReportPlaybackStoppedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportViewing request
	ReportViewing(ctx context.Context, params *ReportViewingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendFullGeneralCommandWithBody request with any body
	SendFullGeneralCommandWithBody(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendFullGeneralCommandWithApplicationWildcardPlusJSONBody(ctx context.Context, sessionId string, body SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendFullGeneralCommand(ctx context.Context, sessionId string, body SendFullGeneralCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendGeneralCommand request
	SendGeneralCommand(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendMessageCommandWithBody request with any body
	SendMessageCommandWithBody(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessageCommandWithApplicationWildcardPlusJSONBody(ctx context.Context, sessionId string, body SendMessageCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendMessageCommand(ctx context.Context, sessionId string, body SendMessageCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Play request
	Play(ctx context.Context, sessionId string, params *PlayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPlaystateCommand request
	SendPlaystateCommand(ctx context.Context, sessionId string, command PlaystateCommand, params *SendPlaystateCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendSystemCommand request
	SendSystemCommand(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromSession request
	RemoveUserFromSession(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToSession request
	AddUserToSession(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisplayContent request
	DisplayContent(ctx context.Context, sessionId string, params *DisplayContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNextUp request
	GetNextUp(ctx context.Context, params *GetNextUpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpcomingEpisodes request
	GetUpcomingEpisodes(ctx context.Context, params *GetUpcomingEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarShows request
	GetSimilarShows(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodes request
	GetEpisodes(ctx context.Context, seriesId openapi_types.UUID, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasons request
	GetSeasons(ctx context.Context, seriesId openapi_types.UUID, params *GetSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstantMixFromSong request
	GetInstantMixFromSong(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromSongParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteWizard request
	CompleteWizard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStartupConfiguration request
	GetStartupConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInitialConfigurationWithBody request with any body
	UpdateInitialConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInitialConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInitialConfiguration(ctx context.Context, body UpdateInitialConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFirstUser2 request
	GetFirstUser2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRemoteAccessWithBody request with any body
	SetRemoteAccessWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRemoteAccessWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetRemoteAccessApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRemoteAccess(ctx context.Context, body SetRemoteAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFirstUser request
	GetFirstUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStartupUserWithBody request with any body
	UpdateStartupUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStartupUserWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateStartupUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStartupUser(ctx context.Context, body UpdateStartupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudios request
	GetStudios(ctx context.Context, params *GetStudiosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudio request
	GetStudio(ctx context.Context, name string, params *GetStudioParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudioImage request
	GetStudioImage(ctx context.Context, name string, imageType ImageType, params *GetStudioImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadStudioImage request
	HeadStudioImage(ctx context.Context, name string, imageType ImageType, params *HeadStudioImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStudioImageByIndex request
	GetStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadStudioImageByIndex request
	HeadStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayBufferingWithBody request with any body
	SyncPlayBufferingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayBufferingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayBufferingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayBuffering(ctx context.Context, body SyncPlayBufferingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayJoinGroupWithBody request with any body
	SyncPlayJoinGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayJoinGroupWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayJoinGroup(ctx context.Context, body SyncPlayJoinGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayLeaveGroup request
	SyncPlayLeaveGroup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayGetGroups request
	SyncPlayGetGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayMovePlaylistItemWithBody request with any body
	SyncPlayMovePlaylistItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayMovePlaylistItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayMovePlaylistItem(ctx context.Context, body SyncPlayMovePlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayCreateGroupWithBody request with any body
	SyncPlayCreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayCreateGroupWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayCreateGroup(ctx context.Context, body SyncPlayCreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayNextItemWithBody request with any body
	SyncPlayNextItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayNextItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayNextItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayNextItem(ctx context.Context, body SyncPlayNextItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayPause request
	SyncPlayPause(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayPingWithBody request with any body
	SyncPlayPingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayPingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayPingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayPing(ctx context.Context, body SyncPlayPingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayPreviousItemWithBody request with any body
	SyncPlayPreviousItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayPreviousItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayPreviousItem(ctx context.Context, body SyncPlayPreviousItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayQueueWithBody request with any body
	SyncPlayQueueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayQueueWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayQueue(ctx context.Context, body SyncPlayQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayReadyWithBody request with any body
	SyncPlayReadyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayReadyWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayReadyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayReady(ctx context.Context, body SyncPlayReadyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayRemoveFromPlaylistWithBody request with any body
	SyncPlayRemoveFromPlaylistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayRemoveFromPlaylistWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlayRemoveFromPlaylist(ctx context.Context, body SyncPlayRemoveFromPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySeekWithBody request with any body
	SyncPlaySeekWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySeekWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySeekApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySeek(ctx context.Context, body SyncPlaySeekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySetIgnoreWaitWithBody request with any body
	SyncPlaySetIgnoreWaitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetIgnoreWaitWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetIgnoreWait(ctx context.Context, body SyncPlaySetIgnoreWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySetNewQueueWithBody request with any body
	SyncPlaySetNewQueueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetNewQueueWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetNewQueue(ctx context.Context, body SyncPlaySetNewQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySetPlaylistItemWithBody request with any body
	SyncPlaySetPlaylistItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetPlaylistItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetPlaylistItem(ctx context.Context, body SyncPlaySetPlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySetRepeatModeWithBody request with any body
	SyncPlaySetRepeatModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetRepeatModeWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetRepeatMode(ctx context.Context, body SyncPlaySetRepeatModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlaySetShuffleModeWithBody request with any body
	SyncPlaySetShuffleModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetShuffleModeWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncPlaySetShuffleMode(ctx context.Context, body SyncPlaySetShuffleModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayStop request
	SyncPlayStop(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncPlayUnpause request
	SyncPlayUnpause(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogEntries request
	GetLogEntries(ctx context.Context, params *GetLogEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfiguration request
	GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigurationWithBody request with any body
	UpdateConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfiguration(ctx context.Context, body UpdateConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultMetadataOptions request
	GetDefaultMetadataOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNamedConfiguration request
	GetNamedConfiguration(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNamedConfigurationWithBody request with any body
	UpdateNamedConfigurationWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNamedConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, key string, body UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNamedConfiguration(ctx context.Context, key string, body UpdateNamedConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndpointInfo request
	GetEndpointInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInfo request
	GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicSystemInfo request
	GetPublicSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerLogs request
	GetServerLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogFile request
	GetLogFile(ctx context.Context, params *GetLogFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMediaEncoderPathWithBody request with any body
	UpdateMediaEncoderPathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMediaEncoderPathWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMediaEncoderPath(ctx context.Context, body UpdateMediaEncoderPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPingSystem request
	GetPingSystem(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPingSystem request
	PostPingSystem(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartApplication request
	RestartApplication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShutdownApplication request
	ShutdownApplication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWakeOnLanInfo request
	GetWakeOnLanInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TmdbClientConfiguration request
	TmdbClientConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrailers request
	GetTrailers(ctx context.Context, params *GetTrailersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimilarTrailers request
	GetSimilarTrailers(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarTrailersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateUserByNameWithBody request with any body
	AuthenticateUserByNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateUserByNameWithApplicationWildcardPlusJSONBody(ctx context.Context, body AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateUserByName(ctx context.Context, body AuthenticateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateWithQuickConnectWithBody request with any body
	AuthenticateWithQuickConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateWithQuickConnectWithApplicationWildcardPlusJSONBody(ctx context.Context, body AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateWithQuickConnect(ctx context.Context, body AuthenticateWithQuickConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForgotPasswordWithBody request with any body
	ForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForgotPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, body ForgotPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForgotPassword(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForgotPasswordPinWithBody request with any body
	ForgotPasswordPinWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForgotPasswordPinWithApplicationWildcardPlusJSONBody(ctx context.Context, body ForgotPasswordPinApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForgotPasswordPin(ctx context.Context, body ForgotPasswordPinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserByNameWithBody request with any body
	CreateUserByNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserByNameWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserByName(ctx context.Context, body CreateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicUsers request
	GetPublicUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserById request
	GetUserById(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId openapi_types.UUID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateUser request
	AuthenticateUser(ctx context.Context, userId openapi_types.UUID, params *AuthenticateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserConfigurationWithBody request with any body
	UpdateUserConfigurationWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserConfiguration(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserEasyPasswordWithBody request with any body
	UpdateUserEasyPasswordWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserEasyPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserEasyPassword(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnmarkFavoriteItem request
	UnmarkFavoriteItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkFavoriteItem request
	MarkFavoriteItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupingOptions request
	GetGroupingOptions(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserImage request
	DeleteUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *DeleteUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserImage request
	GetUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *GetUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadUserImage request
	HeadUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *HeadUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserImageWithBody request with any body
	PostUserImageWithBody(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *PostUserImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserImageByIndex request
	GetUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetUserImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadUserImageByIndex request
	HeadUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadUserImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserImageByIndex request
	DeleteUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserImageByIndexWithBody request with any body
	PostUserImageByIndexWithBody(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemsByUserId request
	GetItemsByUserId(ctx context.Context, userId openapi_types.UUID, params *GetItemsByUserIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestMedia request
	GetLatestMedia(ctx context.Context, userId openapi_types.UUID, params *GetLatestMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResumeItems request
	GetResumeItems(ctx context.Context, userId openapi_types.UUID, params *GetResumeItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRootFolder request
	GetRootFolder(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItem request
	GetItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntros request
	GetIntros(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocalTrailers request
	GetLocalTrailers(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserItemRating request
	DeleteUserItemRating(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserItemRating request
	UpdateUserItemRating(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *UpdateUserItemRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpecialFeatures request
	GetSpecialFeatures(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPasswordWithBody request with any body
	UpdateUserPasswordWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkUnplayedItem request
	MarkUnplayedItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkPlayedItem request
	MarkPlayedItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *MarkPlayedItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OnPlaybackStopped request
	OnPlaybackStopped(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStoppedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OnPlaybackStart request
	OnPlaybackStart(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OnPlaybackProgress request
	OnPlaybackProgress(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackProgressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPolicyWithBody request with any body
	UpdateUserPolicyWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPolicyWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPolicy(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSuggestions request
	GetSuggestions(ctx context.Context, userId openapi_types.UUID, params *GetSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserViews request
	GetUserViews(ctx context.Context, userId openapi_types.UUID, params *GetUserViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopEncodingProcess request
	StopEncodingProcess(ctx context.Context, params *StopEncodingProcessParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeVersions request
	MergeVersions(ctx context.Context, params *MergeVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdditionalPart request
	GetAdditionalPart(ctx context.Context, itemId openapi_types.UUID, params *GetAdditionalPartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlternateSources request
	DeleteAlternateSources(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSubtitleWithBody request with any body
	UploadSubtitleWithBody(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadSubtitleWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadSubtitle(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubtitle request
	DeleteSubtitle(ctx context.Context, itemId openapi_types.UUID, index int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsPlaylistLegacy request
	GetHlsPlaylistLegacy(ctx context.Context, itemId string, playlistId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsVideoSegmentLegacy request
	GetHlsVideoSegmentLegacy(ctx context.Context, itemId string, playlistId string, segmentId string, segmentContainer string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHlsVideoSegment request
	GetHlsVideoSegment(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsVideoSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLiveHlsStream request
	GetLiveHlsStream(ctx context.Context, itemId openapi_types.UUID, params *GetLiveHlsStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariantHlsVideoPlaylist request
	GetVariantHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMasterHlsVideoPlaylist request
	GetMasterHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadMasterHlsVideoPlaylist request
	HeadMasterHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideoStream request
	GetVideoStream(ctx context.Context, itemId openapi_types.UUID, params *GetVideoStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadVideoStream request
	HeadVideoStream(ctx context.Context, itemId openapi_types.UUID, params *HeadVideoStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideoStreamByContainer request
	GetVideoStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *GetVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadVideoStreamByContainer request
	HeadVideoStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubtitlePlaylist request
	GetSubtitlePlaylist(ctx context.Context, itemId openapi_types.UUID, mediaSourceId string, index int32, params *GetSubtitlePlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubtitle request
	GetSubtitle(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeFormat string, params *GetSubtitleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubtitleWithTicks request
	GetSubtitleWithTicks(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeStartPositionTicks int64, routeFormat string, params *GetSubtitleWithTicksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachment request
	GetAttachment(ctx context.Context, videoId openapi_types.UUID, mediaSourceId string, index int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetYears request
	GetYears(ctx context.Context, params *GetYearsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetYear request
	GetYear(ctx context.Context, year int32, params *GetYearParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDurationHistogramReport request
	GetDurationHistogramReport(ctx context.Context, params *GetDurationHistogramReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTvShowsReport request
	GetTvShowsReport(ctx context.Context, params *GetTvShowsReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHourlyReport request
	GetHourlyReport(ctx context.Context, params *GetHourlyReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMovieReport request
	GetMovieReport(ctx context.Context, params *GetMovieReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageStats request
	GetUsageStats(ctx context.Context, params *GetUsageStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadBackup request
	LoadBackup(ctx context.Context, params *LoadBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveBackup request
	SaveBackup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomQueryWithBody request with any body
	CustomQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomQueryWithApplicationWildcardPlusJSONBody(ctx context.Context, body CustomQueryApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CustomQuery(ctx context.Context, body CustomQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTypeFilterList request
	GetTypeFilterList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserReport request
	GetUserReport(ctx context.Context, params *GetUserReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJellyfinUsers request
	GetJellyfinUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IgnoreListAdd request
	IgnoreListAdd(ctx context.Context, params *IgnoreListAddParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PruneUnknownUsers request
	PruneUnknownUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IgnoreListRemove request
	IgnoreListRemove(ctx context.Context, params *IgnoreListRemoveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBreakdownReport request
	GetBreakdownReport(ctx context.Context, breakdownType string, params *GetBreakdownReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserReportData request
	GetUserReportData(ctx context.Context, userId string, date string, params *GetUserReportDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDashboardConfigurationPage request
	GetDashboardConfigurationPage(ctx context.Context, params *GetDashboardConfigurationPageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationPages request
	GetConfigurationPages(ctx context.Context, params *GetConfigurationPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetInstantMixFromAlbum(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromAlbumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromAlbumRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarAlbums(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarAlbumsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarAlbumsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtists(ctx context.Context, params *GetArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlbumArtists(ctx context.Context, params *GetAlbumArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlbumArtistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromArtists2(ctx context.Context, params *GetInstantMixFromArtists2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromArtists2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromArtists(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromArtistsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarArtists(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarArtistsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtistByName(ctx context.Context, name string, params *GetArtistByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtistByNameRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetArtistImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtistImageRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadArtistImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadArtistImageRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsAudioSegmentLegacyAac(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsAudioSegmentLegacyAacRequest(c.Server, itemId, segmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsAudioSegmentLegacyMp3(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsAudioSegmentLegacyMp3Request(c.Server, itemId, segmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsAudioSegment(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsAudioSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsAudioSegmentRequest(c.Server, itemId, playlistId, segmentId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariantHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariantHlsAudioPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterHlsAudioPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadMasterHlsAudioPlaylist(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadMasterHlsAudioPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioStream(ctx context.Context, itemId openapi_types.UUID, params *GetAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadAudioStream(ctx context.Context, itemId openapi_types.UUID, params *HeadAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadAudioStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *GetAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioStreamByContainerRequest(c.Server, itemId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadAudioStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadAudioStreamByContainerRequest(c.Server, itemId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUniversalAudioStream(ctx context.Context, itemId openapi_types.UUID, params *GetUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUniversalAudioStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadUniversalAudioStream(ctx context.Context, itemId openapi_types.UUID, params *HeadUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadUniversalAudioStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateKey(ctx context.Context, params *CreateKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeKey(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeKeyRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPasswordResetProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPasswordResetProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrandingOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrandingOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrandingCss(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrandingCssRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBrandingCss2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBrandingCss2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomSplashscreen(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomSplashscreenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSplashscreen(ctx context.Context, params *GetSplashscreenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSplashscreenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCustomSplashscreenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCustomSplashscreenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannels(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllChannelFeatures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllChannelFeaturesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestChannelItems(ctx context.Context, params *GetLatestChannelItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestChannelItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelFeatures(ctx context.Context, channelId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelFeaturesRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelItems(ctx context.Context, channelId openapi_types.UUID, params *GetChannelItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelItemsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogFileWithTextBody(ctx context.Context, body LogFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogFileRequestWithTextBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, params *CreateCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveFromCollection(ctx context.Context, collectionId openapi_types.UUID, params *RemoveFromCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveFromCollectionRequest(c.Server, collectionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddToCollection(ctx context.Context, collectionId openapi_types.UUID, params *AddToCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToCollectionRequest(c.Server, collectionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevices(ctx context.Context, params *GetDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeviceInfo(ctx context.Context, params *GetDeviceInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeviceOptions(ctx context.Context, params *GetDeviceOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeviceOptionsWithBody(ctx context.Context, params *UpdateDeviceOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeviceOptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeviceOptionsWithApplicationWildcardPlusJSONBody(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeviceOptionsRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDeviceOptions(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDeviceOptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDisplayPreferences(ctx context.Context, displayPreferencesId string, params *GetDisplayPreferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDisplayPreferencesRequest(c.Server, displayPreferencesId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDisplayPreferencesWithBody(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDisplayPreferencesRequestWithBody(c.Server, displayPreferencesId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDisplayPreferencesWithApplicationWildcardPlusJSONBody(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDisplayPreferencesRequestWithApplicationWildcardPlusJSONBody(c.Server, displayPreferencesId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDisplayPreferences(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDisplayPreferencesRequest(c.Server, displayPreferencesId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfileInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileInfosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProfileWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProfileRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProfile(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProfileRequest(c.Server, profileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfile(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileRequest(c.Server, profileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithBody(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, profileId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithApplicationWildcardPlusJSONBody(ctx context.Context, profileId string, body UpdateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithApplicationWildcardPlusJSONBody(c.Server, profileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, profileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIcon(ctx context.Context, fileName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIconRequest(c.Server, fileName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionManager(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionManagerRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionManager2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionManager2Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionManager3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionManager3Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessConnectionManagerControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessConnectionManagerControlRequestRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentDirectory(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentDirectoryRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentDirectory2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentDirectory2Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentDirectory3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentDirectory3Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessContentDirectoryControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessContentDirectoryControlRequestRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaReceiverRegistrar(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaReceiverRegistrarRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessMediaReceiverRegistrarControlRequest(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessMediaReceiverRegistrarControlRequestRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaReceiverRegistrar2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaReceiverRegistrar2Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaReceiverRegistrar3(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaReceiverRegistrar3Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDescriptionXml(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDescriptionXmlRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDescriptionXml2(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDescriptionXml2Request(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIconId(ctx context.Context, serverId string, fileName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIconIdRequest(c.Server, serverId, fileName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultDirectoryBrowser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultDirectoryBrowserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDirectoryContents(ctx context.Context, params *GetDirectoryContentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDirectoryContentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDrives(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDrivesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkShares(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkSharesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParentPath(ctx context.Context, params *GetParentPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParentPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePathRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePathWithApplicationWildcardPlusJSONBody(ctx context.Context, body ValidatePathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePathRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePath(ctx context.Context, body ValidatePathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePathRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFallbackFontList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFallbackFontListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFallbackFont(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFallbackFontRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenres(ctx context.Context, params *GetGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenre(ctx context.Context, genreName string, params *GetGenreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenreRequest(c.Server, genreName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenreImage(ctx context.Context, name string, imageType ImageType, params *GetGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenreImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadGenreImage(ctx context.Context, name string, imageType ImageType, params *HeadGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadGenreImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenreImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadGenreImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUtcTime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUtcTimeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGeneralImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGeneralImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGeneralImage(ctx context.Context, name string, pType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGeneralImageRequest(c.Server, name, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaInfoImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaInfoImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaInfoImage(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaInfoImageRequest(c.Server, theme, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRatingImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRatingImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRatingImage(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRatingImageRequest(c.Server, theme, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItems(ctx context.Context, params *DeleteItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemCounts(ctx context.Context, params *GetItemCountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemCountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueryFiltersLegacy(ctx context.Context, params *GetQueryFiltersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueryFiltersLegacyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQueryFilters(ctx context.Context, params *GetQueryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueryFiltersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplySearchCriteriaWithBody(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplySearchCriteriaRequestWithBody(c.Server, itemId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplySearchCriteriaWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplySearchCriteriaRequestWithApplicationWildcardPlusJSONBody(c.Server, itemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplySearchCriteria(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplySearchCriteriaRequest(c.Server, itemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBookRemoteSearchResults(ctx context.Context, body GetBookRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBoxSetRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBoxSetRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBoxSetRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBoxSetRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBoxSetRemoteSearchResults(ctx context.Context, body GetBoxSetRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBoxSetRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieRemoteSearchResults(ctx context.Context, body GetMovieRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicAlbumRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicAlbumRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicAlbumRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicAlbumRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicAlbumRemoteSearchResults(ctx context.Context, body GetMusicAlbumRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicAlbumRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicArtistRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicArtistRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicArtistRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicArtistRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicArtistRemoteSearchResults(ctx context.Context, body GetMusicArtistRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicArtistRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicVideoRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicVideoRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicVideoRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicVideoRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicVideoRemoteSearchResults(ctx context.Context, body GetMusicVideoRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicVideoRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonRemoteSearchResults(ctx context.Context, body GetPersonRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesRemoteSearchResults(ctx context.Context, body GetSeriesRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrailerRemoteSearchResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrailerRemoteSearchResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrailerRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrailerRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrailerRemoteSearchResults(ctx context.Context, body GetTrailerRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrailerRemoteSearchResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromItem(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromItemRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItem(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemWithBody(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, body UpdateItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemRequestWithApplicationWildcardPlusJSONBody(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItem(ctx context.Context, itemId openapi_types.UUID, body UpdateItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAncestors(ctx context.Context, itemId openapi_types.UUID, params *GetAncestorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAncestorsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemContentType(ctx context.Context, itemId openapi_types.UUID, params *UpdateItemContentTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemContentTypeRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCriticReviews(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCriticReviewsRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDownload(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDownloadRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalIdInfos(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalIdInfosRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemImageInfos(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemImageInfosRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *DeleteItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemImageRequest(c.Server, itemId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *GetItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemImageRequest(c.Server, itemId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadItemImage(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *HeadItemImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadItemImageRequest(c.Server, itemId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetItemImageWithBody(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetItemImageRequestWithBody(c.Server, itemId, imageType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemImageByIndexRequest(c.Server, itemId, imageType, imageIndex)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetItemImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemImageByIndexRequest(c.Server, itemId, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadItemImageByIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadItemImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadItemImageByIndexRequest(c.Server, itemId, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetItemImageByIndexWithBody(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetItemImageByIndexRequestWithBody(c.Server, itemId, imageType, imageIndex, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemImageIndex(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *UpdateItemImageIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemImageIndexRequest(c.Server, itemId, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemImage2(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *GetItemImage2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemImage2Request(c.Server, itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadItemImage2(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *HeadItemImage2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadItemImage2Request(c.Server, itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetadataEditorInfo(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetadataEditorInfoRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaybackInfo(ctx context.Context, itemId openapi_types.UUID, params *GetPlaybackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaybackInfoRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostedPlaybackInfoWithBody(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostedPlaybackInfoRequestWithBody(c.Server, itemId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostedPlaybackInfoWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostedPlaybackInfoRequestWithApplicationWildcardPlusJSONBody(c.Server, itemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPostedPlaybackInfo(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostedPlaybackInfoRequest(c.Server, itemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshItem(ctx context.Context, itemId openapi_types.UUID, params *RefreshItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshItemRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteImages(ctx context.Context, itemId openapi_types.UUID, params *GetRemoteImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteImagesRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadRemoteImage(ctx context.Context, itemId openapi_types.UUID, params *DownloadRemoteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRemoteImageRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteImageProviders(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteImageProvidersRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRemoteSubtitles(ctx context.Context, itemId openapi_types.UUID, language string, params *SearchRemoteSubtitlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRemoteSubtitlesRequest(c.Server, itemId, language, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadRemoteSubtitles(ctx context.Context, itemId openapi_types.UUID, subtitleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRemoteSubtitlesRequest(c.Server, itemId, subtitleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarItems(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarItemsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThemeMedia(ctx context.Context, itemId openapi_types.UUID, params *GetThemeMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThemeMediaRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThemeSongs(ctx context.Context, itemId openapi_types.UUID, params *GetThemeSongsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThemeSongsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThemeVideos(ctx context.Context, itemId openapi_types.UUID, params *GetThemeVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThemeVideosRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateLoginInfoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateLoginInfoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateLoginInfoWithApplicationWildcardPlusJSONBody(ctx context.Context, body ValidateLoginInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateLoginInfoRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateLoginInfo(ctx context.Context, body ValidateLoginInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateLoginInfoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLibraryOptionsInfo(ctx context.Context, params *GetLibraryOptionsInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLibraryOptionsInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUpdatedMediaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUpdatedMediaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUpdatedMediaWithApplicationWildcardPlusJSONBody(ctx context.Context, body PostUpdatedMediaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUpdatedMediaRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUpdatedMedia(ctx context.Context, body PostUpdatedMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUpdatedMediaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMediaFolders(ctx context.Context, params *GetMediaFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMediaFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAddedMovies(ctx context.Context, params *PostAddedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAddedMoviesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUpdatedMovies(ctx context.Context, params *PostUpdatedMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUpdatedMoviesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalPaths(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalPathsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshLibrary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshLibraryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAddedSeries(ctx context.Context, params *PostAddedSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAddedSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUpdatedSeries(ctx context.Context, params *PostUpdatedSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUpdatedSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveVirtualFolder(ctx context.Context, params *RemoveVirtualFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveVirtualFolderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualFolders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualFoldersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualFolderWithBody(ctx context.Context, params *AddVirtualFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualFolderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualFolderWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualFolderRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualFolder(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualFolderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLibraryOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLibraryOptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLibraryOptionsWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLibraryOptionsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLibraryOptions(ctx context.Context, body UpdateLibraryOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLibraryOptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenameVirtualFolder(ctx context.Context, params *RenameVirtualFolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameVirtualFolderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMediaPath(ctx context.Context, params *RemoveMediaPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMediaPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMediaPathWithBody(ctx context.Context, params *AddMediaPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMediaPathRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMediaPathWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddMediaPathParams, body AddMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMediaPathRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMediaPath(ctx context.Context, params *AddMediaPathParams, body AddMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMediaPathRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaPathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaPathRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaPathWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaPathRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaPath(ctx context.Context, body UpdateMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaPathRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseLiveStream(ctx context.Context, params *CloseLiveStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseLiveStreamRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenLiveStreamWithBody(ctx context.Context, params *OpenLiveStreamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenLiveStreamRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenLiveStreamWithApplicationWildcardPlusJSONBody(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenLiveStreamRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenLiveStream(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenLiveStreamRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelMappingOptions(ctx context.Context, params *GetChannelMappingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelMappingOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetChannelMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetChannelMappingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetChannelMappingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetChannelMappingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetChannelMappingRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetChannelMapping(ctx context.Context, body SetChannelMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetChannelMappingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveTvChannels(ctx context.Context, params *GetLiveTvChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveTvChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannel(ctx context.Context, channelId openapi_types.UUID, params *GetChannelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGuideInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGuideInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveTvInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveTvInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListingProvider(ctx context.Context, params *DeleteListingProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListingProviderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddListingProviderWithBody(ctx context.Context, params *AddListingProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddListingProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddListingProviderWithApplicationWildcardPlusJSONBody(ctx context.Context, params *AddListingProviderParams, body AddListingProviderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddListingProviderRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddListingProvider(ctx context.Context, params *AddListingProviderParams, body AddListingProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddListingProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultListingProvider(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultListingProviderRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineups(ctx context.Context, params *GetLineupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesDirectCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesDirectCountriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveRecordingFile(ctx context.Context, recordingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveRecordingFileRequest(c.Server, recordingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveStreamFile(ctx context.Context, streamId string, container string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveStreamFileRequest(c.Server, streamId, container)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveTvPrograms(ctx context.Context, params *GetLiveTvProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveTvProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramsWithApplicationWildcardPlusJSONBody(ctx context.Context, body GetProgramsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrograms(ctx context.Context, body GetProgramsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecommendedPrograms(ctx context.Context, params *GetRecommendedProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecommendedProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, programId string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordings(ctx context.Context, params *GetRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordingFolders(ctx context.Context, params *GetRecordingFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordingGroups(ctx context.Context, params *GetRecordingGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordingGroup(ctx context.Context, groupId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordingsSeries(ctx context.Context, params *GetRecordingsSeriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingsSeriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecording(ctx context.Context, recordingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordingRequest(c.Server, recordingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecording(ctx context.Context, recordingId openapi_types.UUID, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingRequest(c.Server, recordingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesTimers(ctx context.Context, params *GetSeriesTimersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesTimersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSeriesTimerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSeriesTimerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSeriesTimerRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSeriesTimer(ctx context.Context, body CreateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSeriesTimerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSeriesTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSeriesTimerRequest(c.Server, timerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeriesTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeriesTimerRequest(c.Server, timerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSeriesTimerWithBody(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSeriesTimerRequestWithBody(c.Server, timerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, timerId string, body UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSeriesTimerRequestWithApplicationWildcardPlusJSONBody(c.Server, timerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSeriesTimer(ctx context.Context, timerId string, body UpdateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSeriesTimerRequest(c.Server, timerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimers(ctx context.Context, params *GetTimersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTimerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimerRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTimer(ctx context.Context, body CreateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTimerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultTimer(ctx context.Context, params *GetDefaultTimerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultTimerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelTimerRequest(c.Server, timerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimer(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimerRequest(c.Server, timerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTimerWithBody(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimerRequestWithBody(c.Server, timerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTimerWithApplicationWildcardPlusJSONBody(ctx context.Context, timerId string, body UpdateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimerRequestWithApplicationWildcardPlusJSONBody(c.Server, timerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTimer(ctx context.Context, timerId string, body UpdateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTimerRequest(c.Server, timerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTunerHost(ctx context.Context, params *DeleteTunerHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTunerHostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTunerHostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTunerHostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTunerHostWithApplicationWildcardPlusJSONBody(ctx context.Context, body AddTunerHostApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTunerHostRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTunerHost(ctx context.Context, body AddTunerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTunerHostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTunerHostTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTunerHostTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscoverTuners(ctx context.Context, params *DiscoverTunersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscoverTunersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiscvoverTuners(ctx context.Context, params *DiscvoverTunersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiscvoverTunersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetTuner(ctx context.Context, tunerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetTunerRequest(c.Server, tunerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCountries(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCountriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCultures(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCulturesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocalizationOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalizationOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParentalRatings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParentalRatingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieRecommendations(ctx context.Context, params *GetMovieRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieRecommendationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarMovies(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarMoviesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarMoviesRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicGenres(ctx context.Context, params *GetMusicGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicGenresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromMusicGenreById(ctx context.Context, params *GetInstantMixFromMusicGenreByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromMusicGenreByIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicGenre(ctx context.Context, genreName string, params *GetMusicGenreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicGenreRequest(c.Server, genreName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicGenreImage(ctx context.Context, name string, imageType ImageType, params *GetMusicGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicGenreImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadMusicGenreImage(ctx context.Context, name string, imageType ImageType, params *HeadMusicGenreImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadMusicGenreImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMusicGenreImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadMusicGenreImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromMusicGenreByName(ctx context.Context, name string, params *GetInstantMixFromMusicGenreByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromMusicGenreByNameRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminNotificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminNotificationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminNotificationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateAdminNotificationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminNotificationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdminNotification(ctx context.Context, body CreateAdminNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdminNotificationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotifications(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRead(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetReadRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationsSummary(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsSummaryRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUnread(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUnreadRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackage(ctx context.Context, name string, params *InstallPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPackageInstallation(ctx context.Context, packageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPackageInstallationRequest(c.Server, packageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageInfo(ctx context.Context, name string, params *GetPackageInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageInfoRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersons(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPerson(ctx context.Context, name string, params *GetPersonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonImage(ctx context.Context, name string, imageType ImageType, params *GetPersonImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadPersonImage(ctx context.Context, name string, imageType ImageType, params *HeadPersonImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadPersonImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadPersonImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitrateTestBytes(ctx context.Context, params *GetBitrateTestBytesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitrateTestBytesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylistWithBody(ctx context.Context, params *CreatePlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylistWithApplicationWildcardPlusJSONBody(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylist(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromPlaylist(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromPlaylistRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveFromPlaylist(ctx context.Context, playlistId string, params *RemoveFromPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveFromPlaylistRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistItems(ctx context.Context, playlistId openapi_types.UUID, params *GetPlaylistItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistItemsRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddToPlaylist(ctx context.Context, playlistId openapi_types.UUID, params *AddToPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToPlaylistRequest(c.Server, playlistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveItem(ctx context.Context, playlistId string, itemId string, newIndex int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveItemRequest(c.Server, playlistId, itemId, newIndex)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallPlugin(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallPluginRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginConfiguration(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginConfigurationRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginConfiguration(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginConfigurationRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginManifest(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginManifestRequest(c.Server, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallPluginByVersion(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallPluginByVersionRequest(c.Server, pluginId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisablePlugin(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisablePluginRequest(c.Server, pluginId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnablePlugin(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnablePluginRequest(c.Server, pluginId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginImage(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginImageRequest(c.Server, pluginId, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRemoteSubtitles(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRemoteSubtitlesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Connect(ctx context.Context, params *ConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnabled(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnabledRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Initiate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityLogs(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportHeaders(ctx context.Context, params *GetReportHeadersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportHeadersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemReport(ctx context.Context, params *GetItemReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportDownload(ctx context.Context, params *GetReportDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoriesWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetRepositoriesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoriesRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositories(ctx context.Context, body SetRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTasks(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTaskWithBody(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequestWithBody(c.Server, taskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTaskWithApplicationWildcardPlusJSONBody(ctx context.Context, taskId string, body UpdateTaskApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequestWithApplicationWildcardPlusJSONBody(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTask(ctx context.Context, taskId string, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTaskRequest(c.Server, taskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get(ctx context.Context, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessions(ctx context.Context, params *GetSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCapabilities(ctx context.Context, params *PostCapabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCapabilitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFullCapabilitiesWithBody(ctx context.Context, params *PostFullCapabilitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFullCapabilitiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFullCapabilitiesWithApplicationWildcardPlusJSONBody(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFullCapabilitiesRequestWithApplicationWildcardPlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFullCapabilities(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFullCapabilitiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportSessionEnded(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportSessionEndedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStartWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackStartApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStartRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStart(ctx context.Context, body ReportPlaybackStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PingPlaybackSession(ctx context.Context, params *PingPlaybackSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingPlaybackSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackProgressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackProgressRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackProgressWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackProgressRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackProgress(ctx context.Context, body ReportPlaybackProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackProgressRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStoppedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStoppedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStoppedWithApplicationWildcardPlusJSONBody(ctx context.Context, body ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStoppedRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportPlaybackStopped(ctx context.Context, body ReportPlaybackStoppedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportPlaybackStoppedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportViewing(ctx context.Context, params *ReportViewingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportViewingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendFullGeneralCommandWithBody(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendFullGeneralCommandRequestWithBody(c.Server, sessionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendFullGeneralCommandWithApplicationWildcardPlusJSONBody(ctx context.Context, sessionId string, body SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendFullGeneralCommandRequestWithApplicationWildcardPlusJSONBody(c.Server, sessionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendFullGeneralCommand(ctx context.Context, sessionId string, body SendFullGeneralCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendFullGeneralCommandRequest(c.Server, sessionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendGeneralCommand(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendGeneralCommandRequest(c.Server, sessionId, command)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageCommandWithBody(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageCommandRequestWithBody(c.Server, sessionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageCommandWithApplicationWildcardPlusJSONBody(ctx context.Context, sessionId string, body SendMessageCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageCommandRequestWithApplicationWildcardPlusJSONBody(c.Server, sessionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendMessageCommand(ctx context.Context, sessionId string, body SendMessageCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendMessageCommandRequest(c.Server, sessionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Play(ctx context.Context, sessionId string, params *PlayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPlaystateCommand(ctx context.Context, sessionId string, command PlaystateCommand, params *SendPlaystateCommandParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPlaystateCommandRequest(c.Server, sessionId, command, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendSystemCommand(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendSystemCommandRequest(c.Server, sessionId, command)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromSession(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromSessionRequest(c.Server, sessionId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToSession(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToSessionRequest(c.Server, sessionId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisplayContent(ctx context.Context, sessionId string, params *DisplayContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisplayContentRequest(c.Server, sessionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNextUp(ctx context.Context, params *GetNextUpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNextUpRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpcomingEpisodes(ctx context.Context, params *GetUpcomingEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpcomingEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarShows(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarShowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarShowsRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodes(ctx context.Context, seriesId openapi_types.UUID, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodesRequest(c.Server, seriesId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasons(ctx context.Context, seriesId openapi_types.UUID, params *GetSeasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonsRequest(c.Server, seriesId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstantMixFromSong(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromSongParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstantMixFromSongRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteWizard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteWizardRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStartupConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStartupConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInitialConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInitialConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInitialConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInitialConfigurationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInitialConfiguration(ctx context.Context, body UpdateInitialConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInitialConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFirstUser2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFirstUser2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRemoteAccessWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRemoteAccessRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRemoteAccessWithApplicationWildcardPlusJSONBody(ctx context.Context, body SetRemoteAccessApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRemoteAccessRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRemoteAccess(ctx context.Context, body SetRemoteAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRemoteAccessRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFirstUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFirstUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStartupUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStartupUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStartupUserWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateStartupUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStartupUserRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStartupUser(ctx context.Context, body UpdateStartupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStartupUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudios(ctx context.Context, params *GetStudiosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudiosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudio(ctx context.Context, name string, params *GetStudioParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudioRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudioImage(ctx context.Context, name string, imageType ImageType, params *GetStudioImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudioImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadStudioImage(ctx context.Context, name string, imageType ImageType, params *HeadStudioImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadStudioImageRequest(c.Server, name, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStudioImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadStudioImageByIndexRequest(c.Server, name, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayBufferingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayBufferingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayBufferingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayBufferingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayBufferingRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayBuffering(ctx context.Context, body SyncPlayBufferingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayBufferingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayJoinGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayJoinGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayJoinGroupWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayJoinGroupRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayJoinGroup(ctx context.Context, body SyncPlayJoinGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayJoinGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayLeaveGroup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayLeaveGroupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayGetGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayGetGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayMovePlaylistItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayMovePlaylistItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayMovePlaylistItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayMovePlaylistItemRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayMovePlaylistItem(ctx context.Context, body SyncPlayMovePlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayMovePlaylistItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayCreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayCreateGroupWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayCreateGroupRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayCreateGroup(ctx context.Context, body SyncPlayCreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayNextItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayNextItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayNextItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayNextItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayNextItemRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayNextItem(ctx context.Context, body SyncPlayNextItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayNextItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPause(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPauseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPingWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayPingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPingRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPing(ctx context.Context, body SyncPlayPingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPreviousItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPreviousItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPreviousItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPreviousItemRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayPreviousItem(ctx context.Context, body SyncPlayPreviousItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayPreviousItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayQueueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayQueueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayQueueWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayQueueRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayQueue(ctx context.Context, body SyncPlayQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayQueueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayReadyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayReadyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayReadyWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayReadyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayReadyRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayReady(ctx context.Context, body SyncPlayReadyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayReadyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayRemoveFromPlaylistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayRemoveFromPlaylistRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayRemoveFromPlaylistWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayRemoveFromPlaylistRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayRemoveFromPlaylist(ctx context.Context, body SyncPlayRemoveFromPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayRemoveFromPlaylistRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySeekWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySeekRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySeekWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySeekApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySeekRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySeek(ctx context.Context, body SyncPlaySeekJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySeekRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetIgnoreWaitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetIgnoreWaitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetIgnoreWaitWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetIgnoreWaitRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetIgnoreWait(ctx context.Context, body SyncPlaySetIgnoreWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetIgnoreWaitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetNewQueueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetNewQueueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetNewQueueWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetNewQueueRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetNewQueue(ctx context.Context, body SyncPlaySetNewQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetNewQueueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetPlaylistItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetPlaylistItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetPlaylistItemWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetPlaylistItemRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetPlaylistItem(ctx context.Context, body SyncPlaySetPlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetPlaylistItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetRepeatModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetRepeatModeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetRepeatModeWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetRepeatModeRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetRepeatMode(ctx context.Context, body SyncPlaySetRepeatModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetRepeatModeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetShuffleModeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetShuffleModeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetShuffleModeWithApplicationWildcardPlusJSONBody(ctx context.Context, body SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetShuffleModeRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlaySetShuffleMode(ctx context.Context, body SyncPlaySetShuffleModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlaySetShuffleModeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayStop(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayStopRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncPlayUnpause(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncPlayUnpauseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogEntries(ctx context.Context, params *GetLogEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigurationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfiguration(ctx context.Context, body UpdateConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultMetadataOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultMetadataOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNamedConfiguration(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNamedConfigurationRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNamedConfigurationWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNamedConfigurationRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNamedConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, key string, body UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNamedConfigurationRequestWithApplicationWildcardPlusJSONBody(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNamedConfiguration(ctx context.Context, key string, body UpdateNamedConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNamedConfigurationRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEndpointInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndpointInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicSystemInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicSystemInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerLogs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerLogsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogFile(ctx context.Context, params *GetLogFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogFileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaEncoderPathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaEncoderPathRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaEncoderPathWithApplicationWildcardPlusJSONBody(ctx context.Context, body UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaEncoderPathRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMediaEncoderPath(ctx context.Context, body UpdateMediaEncoderPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMediaEncoderPathRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPingSystem(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPingSystemRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPingSystem(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPingSystemRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartApplication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartApplicationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShutdownApplication(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShutdownApplicationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWakeOnLanInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWakeOnLanInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TmdbClientConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTmdbClientConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrailers(ctx context.Context, params *GetTrailersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrailersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimilarTrailers(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarTrailersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimilarTrailersRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUserByNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserByNameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUserByNameWithApplicationWildcardPlusJSONBody(ctx context.Context, body AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserByNameRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUserByName(ctx context.Context, body AuthenticateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserByNameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithQuickConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateWithQuickConnectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithQuickConnectWithApplicationWildcardPlusJSONBody(ctx context.Context, body AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateWithQuickConnectRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithQuickConnect(ctx context.Context, body AuthenticateWithQuickConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateWithQuickConnectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, body ForgotPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPassword(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordPinWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordPinRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordPinWithApplicationWildcardPlusJSONBody(ctx context.Context, body ForgotPasswordPinApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordPinRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForgotPasswordPin(ctx context.Context, body ForgotPasswordPinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForgotPasswordPinRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserByNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserByNameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserByNameWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserByNameRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserByName(ctx context.Context, body CreateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserByNameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserById(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByIdRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithApplicationWildcardPlusJSONBody(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId openapi_types.UUID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateUser(ctx context.Context, userId openapi_types.UUID, params *AuthenticateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserConfigurationWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserConfigurationRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserConfigurationWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserConfigurationRequestWithApplicationWildcardPlusJSONBody(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserConfiguration(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserConfigurationRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserEasyPasswordWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserEasyPasswordRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserEasyPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserEasyPasswordRequestWithApplicationWildcardPlusJSONBody(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserEasyPassword(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserEasyPasswordRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnmarkFavoriteItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnmarkFavoriteItemRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkFavoriteItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkFavoriteItemRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupingOptions(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupingOptionsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *DeleteUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserImageRequest(c.Server, userId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *GetUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserImageRequest(c.Server, userId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadUserImage(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *HeadUserImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadUserImageRequest(c.Server, userId, imageType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserImageWithBody(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *PostUserImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserImageRequestWithBody(c.Server, userId, imageType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetUserImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserImageByIndexRequest(c.Server, userId, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadUserImageByIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadUserImageByIndexRequest(c.Server, userId, imageType, imageIndex, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserImageByIndex(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserImageByIndexRequest(c.Server, userId, imageType, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserImageByIndexWithBody(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserImageByIndexRequestWithBody(c.Server, userId, imageType, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemsByUserId(ctx context.Context, userId openapi_types.UUID, params *GetItemsByUserIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsByUserIdRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestMedia(ctx context.Context, userId openapi_types.UUID, params *GetLatestMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestMediaRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResumeItems(ctx context.Context, userId openapi_types.UUID, params *GetResumeItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResumeItemsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRootFolder(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootFolderRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntros(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntrosRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocalTrailers(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalTrailersRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserItemRating(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserItemRatingRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserItemRating(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *UpdateUserItemRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserItemRatingRequest(c.Server, userId, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpecialFeatures(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpecialFeaturesRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithApplicationWildcardPlusJSONBody(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkUnplayedItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkUnplayedItemRequest(c.Server, userId, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPlayedItem(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *MarkPlayedItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPlayedItemRequest(c.Server, userId, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OnPlaybackStopped(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStoppedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOnPlaybackStoppedRequest(c.Server, userId, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OnPlaybackStart(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOnPlaybackStartRequest(c.Server, userId, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OnPlaybackProgress(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackProgressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOnPlaybackProgressRequest(c.Server, userId, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPolicyWithBody(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPolicyRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPolicyWithApplicationWildcardPlusJSONBody(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPolicyRequestWithApplicationWildcardPlusJSONBody(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPolicy(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPolicyRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSuggestions(ctx context.Context, userId openapi_types.UUID, params *GetSuggestionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSuggestionsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserViews(ctx context.Context, userId openapi_types.UUID, params *GetUserViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserViewsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopEncodingProcess(ctx context.Context, params *StopEncodingProcessParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopEncodingProcessRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeVersions(ctx context.Context, params *MergeVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeVersionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdditionalPart(ctx context.Context, itemId openapi_types.UUID, params *GetAdditionalPartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdditionalPartRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlternateSources(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAlternateSourcesRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSubtitleWithBody(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSubtitleRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSubtitleWithApplicationWildcardPlusJSONBody(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSubtitleRequestWithApplicationWildcardPlusJSONBody(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSubtitle(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSubtitleRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubtitle(ctx context.Context, itemId openapi_types.UUID, index int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubtitleRequest(c.Server, itemId, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsPlaylistLegacy(ctx context.Context, itemId string, playlistId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsPlaylistLegacyRequest(c.Server, itemId, playlistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsVideoSegmentLegacy(ctx context.Context, itemId string, playlistId string, segmentId string, segmentContainer string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsVideoSegmentLegacyRequest(c.Server, itemId, playlistId, segmentId, segmentContainer)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHlsVideoSegment(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsVideoSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHlsVideoSegmentRequest(c.Server, itemId, playlistId, segmentId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLiveHlsStream(ctx context.Context, itemId openapi_types.UUID, params *GetLiveHlsStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveHlsStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariantHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariantHlsVideoPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMasterHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMasterHlsVideoPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadMasterHlsVideoPlaylist(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadMasterHlsVideoPlaylistRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideoStream(ctx context.Context, itemId openapi_types.UUID, params *GetVideoStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideoStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadVideoStream(ctx context.Context, itemId openapi_types.UUID, params *HeadVideoStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadVideoStreamRequest(c.Server, itemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideoStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *GetVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideoStreamByContainerRequest(c.Server, itemId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadVideoStreamByContainer(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadVideoStreamByContainerRequest(c.Server, itemId, container, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubtitlePlaylist(ctx context.Context, itemId openapi_types.UUID, mediaSourceId string, index int32, params *GetSubtitlePlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubtitlePlaylistRequest(c.Server, itemId, mediaSourceId, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubtitle(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeFormat string, params *GetSubtitleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubtitleRequest(c.Server, routeItemId, routeMediaSourceId, routeIndex, routeFormat, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubtitleWithTicks(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeStartPositionTicks int64, routeFormat string, params *GetSubtitleWithTicksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubtitleWithTicksRequest(c.Server, routeItemId, routeMediaSourceId, routeIndex, routeStartPositionTicks, routeFormat, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachment(ctx context.Context, videoId openapi_types.UUID, mediaSourceId string, index int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentRequest(c.Server, videoId, mediaSourceId, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetYears(ctx context.Context, params *GetYearsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetYearsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetYear(ctx context.Context, year int32, params *GetYearParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetYearRequest(c.Server, year, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDurationHistogramReport(ctx context.Context, params *GetDurationHistogramReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDurationHistogramReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTvShowsReport(ctx context.Context, params *GetTvShowsReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTvShowsReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHourlyReport(ctx context.Context, params *GetHourlyReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHourlyReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMovieReport(ctx context.Context, params *GetMovieReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMovieReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageStats(ctx context.Context, params *GetUsageStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBackup(ctx context.Context, params *LoadBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBackupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveBackup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveBackupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomQueryWithApplicationWildcardPlusJSONBody(ctx context.Context, body CustomQueryApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomQueryRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomQuery(ctx context.Context, body CustomQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTypeFilterList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypeFilterListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserReport(ctx context.Context, params *GetUserReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserReportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJellyfinUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJellyfinUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IgnoreListAdd(ctx context.Context, params *IgnoreListAddParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIgnoreListAddRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PruneUnknownUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPruneUnknownUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IgnoreListRemove(ctx context.Context, params *IgnoreListRemoveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIgnoreListRemoveRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBreakdownReport(ctx context.Context, breakdownType string, params *GetBreakdownReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBreakdownReportRequest(c.Server, breakdownType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserReportData(ctx context.Context, userId string, date string, params *GetUserReportDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserReportDataRequest(c.Server, userId, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDashboardConfigurationPage(ctx context.Context, params *GetDashboardConfigurationPageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDashboardConfigurationPageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationPages(ctx context.Context, params *GetConfigurationPagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationPagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetInstantMixFromAlbumRequest generates requests for GetInstantMixFromAlbum
func NewGetInstantMixFromAlbumRequest(server string, id openapi_types.UUID, params *GetInstantMixFromAlbumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Albums/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarAlbumsRequest generates requests for GetSimilarAlbums
func NewGetSimilarAlbumsRequest(server string, itemId openapi_types.UUID, params *GetSimilarAlbumsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Albums/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtistsRequest generates requests for GetArtists
func NewGetArtistsRequest(server string, params *GetArtistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlbumArtistsRequest generates requests for GetAlbumArtists
func NewGetAlbumArtistsRequest(server string, params *GetAlbumArtistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/AlbumArtists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantMixFromArtists2Request generates requests for GetInstantMixFromArtists2
func NewGetInstantMixFromArtists2Request(server string, params *GetInstantMixFromArtists2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/InstantMix")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantMixFromArtistsRequest generates requests for GetInstantMixFromArtists
func NewGetInstantMixFromArtistsRequest(server string, id openapi_types.UUID, params *GetInstantMixFromArtistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarArtistsRequest generates requests for GetSimilarArtists
func NewGetSimilarArtistsRequest(server string, itemId openapi_types.UUID, params *GetSimilarArtistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtistByNameRequest generates requests for GetArtistByName
func NewGetArtistByNameRequest(server string, name string, params *GetArtistByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtistImageRequest generates requests for GetArtistImage
func NewGetArtistImageRequest(server string, name string, imageType ImageType, imageIndex int32, params *GetArtistImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadArtistImageRequest generates requests for HeadArtistImage
func NewHeadArtistImageRequest(server string, name string, imageType ImageType, imageIndex int32, params *HeadArtistImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Artists/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsAudioSegmentLegacyAacRequest generates requests for GetHlsAudioSegmentLegacyAac
func NewGetHlsAudioSegmentLegacyAacRequest(server string, itemId string, segmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "segmentId", runtime.ParamLocationPath, segmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/hls/%s/stream.aac", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsAudioSegmentLegacyMp3Request generates requests for GetHlsAudioSegmentLegacyMp3
func NewGetHlsAudioSegmentLegacyMp3Request(server string, itemId string, segmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "segmentId", runtime.ParamLocationPath, segmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/hls/%s/stream.mp3", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsAudioSegmentRequest generates requests for GetHlsAudioSegment
func NewGetHlsAudioSegmentRequest(server string, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsAudioSegmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "segmentId", runtime.ParamLocationPath, segmentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/hls1/%s/%s.%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runtimeTicks", runtime.ParamLocationQuery, params.RuntimeTicks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actualSegmentLengthTicks", runtime.ParamLocationQuery, params.ActualSegmentLengthTicks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariantHlsAudioPlaylistRequest generates requests for GetVariantHlsAudioPlaylist
func NewGetVariantHlsAudioPlaylistRequest(server string, itemId openapi_types.UUID, params *GetVariantHlsAudioPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/main.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterHlsAudioPlaylistRequest generates requests for GetMasterHlsAudioPlaylist
func NewGetMasterHlsAudioPlaylistRequest(server string, itemId openapi_types.UUID, params *GetMasterHlsAudioPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/master.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, params.MediaSourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAdaptiveBitrateStreaming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAdaptiveBitrateStreaming", runtime.ParamLocationQuery, *params.EnableAdaptiveBitrateStreaming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadMasterHlsAudioPlaylistRequest generates requests for HeadMasterHlsAudioPlaylist
func NewHeadMasterHlsAudioPlaylistRequest(server string, itemId openapi_types.UUID, params *HeadMasterHlsAudioPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/master.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, params.MediaSourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAdaptiveBitrateStreaming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAdaptiveBitrateStreaming", runtime.ParamLocationQuery, *params.EnableAdaptiveBitrateStreaming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioStreamRequest generates requests for GetAudioStream
func NewGetAudioStreamRequest(server string, itemId openapi_types.UUID, params *GetAudioStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadAudioStreamRequest generates requests for HeadAudioStream
func NewHeadAudioStreamRequest(server string, itemId openapi_types.UUID, params *HeadAudioStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioStreamByContainerRequest generates requests for GetAudioStreamByContainer
func NewGetAudioStreamByContainerRequest(server string, itemId openapi_types.UUID, container string, params *GetAudioStreamByContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/stream.%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadAudioStreamByContainerRequest generates requests for HeadAudioStreamByContainer
func NewHeadAudioStreamByContainerRequest(server string, itemId openapi_types.UUID, container string, params *HeadAudioStreamByContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/stream.%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUniversalAudioStreamRequest generates requests for GetUniversalAudioStream
func NewGetUniversalAudioStreamRequest(server string, itemId openapi_types.UUID, params *GetUniversalAudioStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/universal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingAudioChannels", runtime.ParamLocationQuery, *params.TranscodingAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingContainer", runtime.ParamLocationQuery, *params.TranscodingContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingProtocol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingProtocol", runtime.ParamLocationQuery, *params.TranscodingProtocol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioSampleRate", runtime.ParamLocationQuery, *params.MaxAudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRemoteMedia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRemoteMedia", runtime.ParamLocationQuery, *params.EnableRemoteMedia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRedirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRedirection", runtime.ParamLocationQuery, *params.EnableRedirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadUniversalAudioStreamRequest generates requests for HeadUniversalAudioStream
func NewHeadUniversalAudioStreamRequest(server string, itemId openapi_types.UUID, params *HeadUniversalAudioStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Audio/%s/universal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingAudioChannels", runtime.ParamLocationQuery, *params.TranscodingAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingContainer", runtime.ParamLocationQuery, *params.TranscodingContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingProtocol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingProtocol", runtime.ParamLocationQuery, *params.TranscodingProtocol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioSampleRate", runtime.ParamLocationQuery, *params.MaxAudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRemoteMedia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRemoteMedia", runtime.ParamLocationQuery, *params.EnableRemoteMedia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRedirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRedirection", runtime.ParamLocationQuery, *params.EnableRedirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Auth/Keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateKeyRequest generates requests for CreateKey
func NewCreateKeyRequest(server string, params *CreateKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Auth/Keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app", runtime.ParamLocationQuery, params.App); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevokeKeyRequest generates requests for RevokeKey
func NewRevokeKeyRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Auth/Keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPasswordResetProvidersRequest generates requests for GetPasswordResetProviders
func NewGetPasswordResetProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Auth/PasswordResetProviders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthProvidersRequest generates requests for GetAuthProviders
func NewGetAuthProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Auth/Providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrandingOptionsRequest generates requests for GetBrandingOptions
func NewGetBrandingOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrandingCssRequest generates requests for GetBrandingCss
func NewGetBrandingCssRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Css")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBrandingCss2Request generates requests for GetBrandingCss2
func NewGetBrandingCss2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Css.css")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomSplashscreenRequest generates requests for DeleteCustomSplashscreen
func NewDeleteCustomSplashscreenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Splashscreen")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSplashscreenRequest generates requests for GetSplashscreen
func NewGetSplashscreenRequest(server string, params *GetSplashscreenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Splashscreen")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCustomSplashscreenRequestWithBody generates requests for UploadCustomSplashscreen with any type of body
func NewUploadCustomSplashscreenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Branding/Splashscreen")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelsRequest generates requests for GetChannels
func NewGetChannelsRequest(server string, params *GetChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportsLatestItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsLatestItems", runtime.ParamLocationQuery, *params.SupportsLatestItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportsMediaDeletion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsMediaDeletion", runtime.ParamLocationQuery, *params.SupportsMediaDeletion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllChannelFeaturesRequest generates requests for GetAllChannelFeatures
func NewGetAllChannelFeaturesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Channels/Features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestChannelItemsRequest generates requests for GetLatestChannelItems
func NewGetLatestChannelItemsRequest(server string, params *GetLatestChannelItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Channels/Items/Latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelIds", runtime.ParamLocationQuery, *params.ChannelIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelFeaturesRequest generates requests for GetChannelFeatures
func NewGetChannelFeaturesRequest(server string, channelId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Channels/%s/Features", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelItemsRequest generates requests for GetChannelItems
func NewGetChannelItemsRequest(server string, channelId openapi_types.UUID, params *GetChannelItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Channels/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogFileRequestWithTextBody calls the generic LogFile builder with text/plain body
func NewLogFileRequestWithTextBody(server string, body LogFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(fmt.Sprint(body))
	return NewLogFileRequestWithBody(server, "text/plain", bodyReader)
}

// NewLogFileRequestWithBody generates requests for LogFile with any type of body
func NewLogFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ClientLog/Document")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCollectionRequest generates requests for CreateCollection
func NewCreateCollectionRequest(server string, params *CreateCollectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveFromCollectionRequest generates requests for RemoveFromCollection
func NewRemoveFromCollectionRequest(server string, collectionId openapi_types.UUID, params *RemoveFromCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Collections/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddToCollectionRequest generates requests for AddToCollection
func NewAddToCollectionRequest(server string, collectionId openapi_types.UUID, params *AddToCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Collections/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, params *DeleteDeviceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDevicesRequest generates requests for GetDevices
func NewGetDevicesRequest(server string, params *GetDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SupportsSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsSync", runtime.ParamLocationQuery, *params.SupportsSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeviceInfoRequest generates requests for GetDeviceInfo
func NewGetDeviceInfoRequest(server string, params *GetDeviceInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Devices/Info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeviceOptionsRequest generates requests for GetDeviceOptions
func NewGetDeviceOptionsRequest(server string, params *GetDeviceOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Devices/Options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDeviceOptionsRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateDeviceOptions builder with application/*+json body
func NewUpdateDeviceOptionsRequestWithApplicationWildcardPlusJSONBody(server string, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeviceOptionsRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewUpdateDeviceOptionsRequest calls the generic UpdateDeviceOptions builder with application/json body
func NewUpdateDeviceOptionsRequest(server string, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDeviceOptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateDeviceOptionsRequestWithBody generates requests for UpdateDeviceOptions with any type of body
func NewUpdateDeviceOptionsRequestWithBody(server string, params *UpdateDeviceOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Devices/Options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDisplayPreferencesRequest generates requests for GetDisplayPreferences
func NewGetDisplayPreferencesRequest(server string, displayPreferencesId string, params *GetDisplayPreferencesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "displayPreferencesId", runtime.ParamLocationPath, displayPreferencesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/DisplayPreferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client", runtime.ParamLocationQuery, params.Client); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDisplayPreferencesRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateDisplayPreferences builder with application/*+json body
func NewUpdateDisplayPreferencesRequestWithApplicationWildcardPlusJSONBody(server string, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDisplayPreferencesRequestWithBody(server, displayPreferencesId, params, "application/*+json", bodyReader)
}

// NewUpdateDisplayPreferencesRequest calls the generic UpdateDisplayPreferences builder with application/json body
func NewUpdateDisplayPreferencesRequest(server string, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDisplayPreferencesRequestWithBody(server, displayPreferencesId, params, "application/json", bodyReader)
}

// NewUpdateDisplayPreferencesRequestWithBody generates requests for UpdateDisplayPreferences with any type of body
func NewUpdateDisplayPreferencesRequestWithBody(server string, displayPreferencesId string, params *UpdateDisplayPreferencesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "displayPreferencesId", runtime.ParamLocationPath, displayPreferencesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/DisplayPreferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client", runtime.ParamLocationQuery, params.Client); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProfileInfosRequest generates requests for GetProfileInfos
func NewGetProfileInfosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/ProfileInfos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProfileRequestWithApplicationWildcardPlusJSONBody calls the generic CreateProfile builder with application/*+json body
func NewCreateProfileRequestWithApplicationWildcardPlusJSONBody(server string, body CreateProfileApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProfileRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateProfileRequest calls the generic CreateProfile builder with application/json body
func NewCreateProfileRequest(server string, body CreateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProfileRequestWithBody generates requests for CreateProfile with any type of body
func NewCreateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/Profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultProfileRequest generates requests for GetDefaultProfile
func NewGetDefaultProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/Profiles/Default")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProfileRequest generates requests for DeleteProfile
func NewDeleteProfileRequest(server string, profileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/Profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileRequest generates requests for GetProfile
func NewGetProfileRequest(server string, profileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/Profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateProfile builder with application/*+json body
func NewUpdateProfileRequestWithApplicationWildcardPlusJSONBody(server string, profileId string, body UpdateProfileApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, profileId, "application/*+json", bodyReader)
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, profileId string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, profileId, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, profileId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileId", runtime.ParamLocationPath, profileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/Profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIconRequest generates requests for GetIcon
func NewGetIconRequest(server string, fileName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fileName", runtime.ParamLocationPath, fileName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/icons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionManagerRequest generates requests for GetConnectionManager
func NewGetConnectionManagerRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ConnectionManager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionManager2Request generates requests for GetConnectionManager2
func NewGetConnectionManager2Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ConnectionManager/ConnectionManager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectionManager3Request generates requests for GetConnectionManager3
func NewGetConnectionManager3Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ConnectionManager/ConnectionManager.xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessConnectionManagerControlRequestRequest generates requests for ProcessConnectionManagerControlRequest
func NewProcessConnectionManagerControlRequestRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ConnectionManager/Control", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentDirectoryRequest generates requests for GetContentDirectory
func NewGetContentDirectoryRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ContentDirectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentDirectory2Request generates requests for GetContentDirectory2
func NewGetContentDirectory2Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ContentDirectory/ContentDirectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentDirectory3Request generates requests for GetContentDirectory3
func NewGetContentDirectory3Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ContentDirectory/ContentDirectory.xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessContentDirectoryControlRequestRequest generates requests for ProcessContentDirectoryControlRequest
func NewProcessContentDirectoryControlRequestRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/ContentDirectory/Control", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaReceiverRegistrarRequest generates requests for GetMediaReceiverRegistrar
func NewGetMediaReceiverRegistrarRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/MediaReceiverRegistrar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessMediaReceiverRegistrarControlRequestRequest generates requests for ProcessMediaReceiverRegistrarControlRequest
func NewProcessMediaReceiverRegistrarControlRequestRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/MediaReceiverRegistrar/Control", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaReceiverRegistrar2Request generates requests for GetMediaReceiverRegistrar2
func NewGetMediaReceiverRegistrar2Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/MediaReceiverRegistrar/MediaReceiverRegistrar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaReceiverRegistrar3Request generates requests for GetMediaReceiverRegistrar3
func NewGetMediaReceiverRegistrar3Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/MediaReceiverRegistrar/MediaReceiverRegistrar.xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDescriptionXmlRequest generates requests for GetDescriptionXml
func NewGetDescriptionXmlRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/description", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDescriptionXml2Request generates requests for GetDescriptionXml2
func NewGetDescriptionXml2Request(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/description.xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIconIdRequest generates requests for GetIconId
func NewGetIconIdRequest(server string, serverId string, fileName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fileName", runtime.ParamLocationPath, fileName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Dlna/%s/icons/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultDirectoryBrowserRequest generates requests for GetDefaultDirectoryBrowser
func NewGetDefaultDirectoryBrowserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/DefaultDirectoryBrowser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDirectoryContentsRequest generates requests for GetDirectoryContents
func NewGetDirectoryContentsRequest(server string, params *GetDirectoryContentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/DirectoryContents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeFiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFiles", runtime.ParamLocationQuery, *params.IncludeFiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDirectories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDirectories", runtime.ParamLocationQuery, *params.IncludeDirectories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDrivesRequest generates requests for GetDrives
func NewGetDrivesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/Drives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkSharesRequest generates requests for GetNetworkShares
func NewGetNetworkSharesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/NetworkShares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParentPathRequest generates requests for GetParentPath
func NewGetParentPathRequest(server string, params *GetParentPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/ParentPath")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidatePathRequestWithApplicationWildcardPlusJSONBody calls the generic ValidatePath builder with application/*+json body
func NewValidatePathRequestWithApplicationWildcardPlusJSONBody(server string, body ValidatePathApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidatePathRequestWithBody(server, "application/*+json", bodyReader)
}

// NewValidatePathRequest calls the generic ValidatePath builder with application/json body
func NewValidatePathRequest(server string, body ValidatePathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidatePathRequestWithBody(server, "application/json", bodyReader)
}

// NewValidatePathRequestWithBody generates requests for ValidatePath with any type of body
func NewValidatePathRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Environment/ValidatePath")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFallbackFontListRequest generates requests for GetFallbackFontList
func NewGetFallbackFontListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/FallbackFont/Fonts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFallbackFontRequest generates requests for GetFallbackFont
func NewGetFallbackFontRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/FallbackFont/Fonts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenresRequest generates requests for GetGenres
func NewGetGenresRequest(server string, params *GetGenresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenreRequest generates requests for GetGenre
func NewGetGenreRequest(server string, genreName string, params *GetGenreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "genreName", runtime.ParamLocationPath, genreName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenreImageRequest generates requests for GetGenreImage
func NewGetGenreImageRequest(server string, name string, imageType ImageType, params *GetGenreImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadGenreImageRequest generates requests for HeadGenreImage
func NewHeadGenreImageRequest(server string, name string, imageType ImageType, params *HeadGenreImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenreImageByIndexRequest generates requests for GetGenreImageByIndex
func NewGetGenreImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *GetGenreImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadGenreImageByIndexRequest generates requests for HeadGenreImageByIndex
func NewHeadGenreImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *HeadGenreImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Genres/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUtcTimeRequest generates requests for GetUtcTime
func NewGetUtcTimeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/GetUtcTime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGeneralImagesRequest generates requests for GetGeneralImages
func NewGetGeneralImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/General")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGeneralImageRequest generates requests for GetGeneralImage
func NewGetGeneralImageRequest(server string, name string, pType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/General/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaInfoImagesRequest generates requests for GetMediaInfoImages
func NewGetMediaInfoImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/MediaInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMediaInfoImageRequest generates requests for GetMediaInfoImage
func NewGetMediaInfoImageRequest(server string, theme string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "theme", runtime.ParamLocationPath, theme)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/MediaInfo/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRatingImagesRequest generates requests for GetRatingImages
func NewGetRatingImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/Ratings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRatingImageRequest generates requests for GetRatingImage
func NewGetRatingImageRequest(server string, theme string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "theme", runtime.ParamLocationPath, theme)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Images/Ratings/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemsRequest generates requests for DeleteItems
func NewDeleteItemsRequest(server string, params *DeleteItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemsRequest generates requests for GetItems
func NewGetItemsRequest(server string, params *GetItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxOfficialRating", runtime.ParamLocationQuery, *params.MaxOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeSong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeSong", runtime.ParamLocationQuery, *params.HasThemeSong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeVideo", runtime.ParamLocationQuery, *params.HasThemeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSubtitles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSubtitles", runtime.ParamLocationQuery, *params.HasSubtitles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSpecialFeature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSpecialFeature", runtime.ParamLocationQuery, *params.HasSpecialFeature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTrailer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTrailer", runtime.ParamLocationQuery, *params.HasTrailer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentIndexNumber", runtime.ParamLocationQuery, *params.ParentIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasParentalRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasParentalRating", runtime.ParamLocationQuery, *params.HasParentalRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHd", runtime.ParamLocationQuery, *params.IsHd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is4K != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is4K", runtime.ParamLocationQuery, *params.Is4K); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationTypes", runtime.ParamLocationQuery, *params.LocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeLocationTypes", runtime.ParamLocationQuery, *params.ExcludeLocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsUnaired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isUnaired", runtime.ParamLocationQuery, *params.IsUnaired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCriticRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCriticRating", runtime.ParamLocationQuery, *params.MinCriticRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPremiereDate", runtime.ParamLocationQuery, *params.MinPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSaved", runtime.ParamLocationQuery, *params.MinDateLastSaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSavedForUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSavedForUser", runtime.ParamLocationQuery, *params.MinDateLastSavedForUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPremiereDate", runtime.ParamLocationQuery, *params.MaxPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOverview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOverview", runtime.ParamLocationQuery, *params.HasOverview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasImdbId", runtime.ParamLocationQuery, *params.HasImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTmdbId", runtime.ParamLocationQuery, *params.HasTmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTvdbId", runtime.ParamLocationQuery, *params.HasTvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemIds", runtime.ParamLocationQuery, *params.ExcludeItemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypes", runtime.ParamLocationQuery, *params.ImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artistIds", runtime.ParamLocationQuery, *params.ArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumArtistIds", runtime.ParamLocationQuery, *params.AlbumArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContributingArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contributingArtistIds", runtime.ParamLocationQuery, *params.ContributingArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Albums != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albums", runtime.ParamLocationQuery, *params.Albums); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumIds", runtime.ParamLocationQuery, *params.AlbumIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoTypes", runtime.ParamLocationQuery, *params.VideoTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOfficialRating", runtime.ParamLocationQuery, *params.MinOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlaceHolder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlaceHolder", runtime.ParamLocationQuery, *params.IsPlaceHolder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOfficialRating", runtime.ParamLocationQuery, *params.HasOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapseBoxSetItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapseBoxSetItems", runtime.ParamLocationQuery, *params.CollapseBoxSetItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minWidth", runtime.ParamLocationQuery, *params.MinWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHeight", runtime.ParamLocationQuery, *params.MinHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is3D != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is3D", runtime.ParamLocationQuery, *params.Is3D); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesStatus", runtime.ParamLocationQuery, *params.SeriesStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemCountsRequest generates requests for GetItemCounts
func NewGetItemCountsRequest(server string, params *GetItemCountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/Counts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueryFiltersLegacyRequest generates requests for GetQueryFiltersLegacy
func NewGetQueryFiltersLegacyRequest(server string, params *GetQueryFiltersLegacyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/Filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueryFiltersRequest generates requests for GetQueryFilters
func NewGetQueryFiltersRequest(server string, params *GetQueryFiltersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/Filters2")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsAiring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isAiring", runtime.ParamLocationQuery, *params.IsAiring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApplySearchCriteriaRequestWithApplicationWildcardPlusJSONBody calls the generic ApplySearchCriteria builder with application/*+json body
func NewApplySearchCriteriaRequestWithApplicationWildcardPlusJSONBody(server string, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplySearchCriteriaRequestWithBody(server, itemId, params, "application/*+json", bodyReader)
}

// NewApplySearchCriteriaRequest calls the generic ApplySearchCriteria builder with application/json body
func NewApplySearchCriteriaRequest(server string, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplySearchCriteriaRequestWithBody(server, itemId, params, "application/json", bodyReader)
}

// NewApplySearchCriteriaRequestWithBody generates requests for ApplySearchCriteria with any type of body
func NewApplySearchCriteriaRequestWithBody(server string, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Apply/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReplaceAllImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replaceAllImages", runtime.ParamLocationQuery, *params.ReplaceAllImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBookRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetBookRemoteSearchResults builder with application/*+json body
func NewGetBookRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBookRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetBookRemoteSearchResultsRequest calls the generic GetBookRemoteSearchResults builder with application/json body
func NewGetBookRemoteSearchResultsRequest(server string, body GetBookRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBookRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetBookRemoteSearchResultsRequestWithBody generates requests for GetBookRemoteSearchResults with any type of body
func NewGetBookRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Book")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBoxSetRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetBoxSetRemoteSearchResults builder with application/*+json body
func NewGetBoxSetRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBoxSetRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetBoxSetRemoteSearchResultsRequest calls the generic GetBoxSetRemoteSearchResults builder with application/json body
func NewGetBoxSetRemoteSearchResultsRequest(server string, body GetBoxSetRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBoxSetRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetBoxSetRemoteSearchResultsRequestWithBody generates requests for GetBoxSetRemoteSearchResults with any type of body
func NewGetBoxSetRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/BoxSet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMovieRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetMovieRemoteSearchResults builder with application/*+json body
func NewGetMovieRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMovieRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetMovieRemoteSearchResultsRequest calls the generic GetMovieRemoteSearchResults builder with application/json body
func NewGetMovieRemoteSearchResultsRequest(server string, body GetMovieRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMovieRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMovieRemoteSearchResultsRequestWithBody generates requests for GetMovieRemoteSearchResults with any type of body
func NewGetMovieRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Movie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMusicAlbumRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetMusicAlbumRemoteSearchResults builder with application/*+json body
func NewGetMusicAlbumRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicAlbumRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetMusicAlbumRemoteSearchResultsRequest calls the generic GetMusicAlbumRemoteSearchResults builder with application/json body
func NewGetMusicAlbumRemoteSearchResultsRequest(server string, body GetMusicAlbumRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicAlbumRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMusicAlbumRemoteSearchResultsRequestWithBody generates requests for GetMusicAlbumRemoteSearchResults with any type of body
func NewGetMusicAlbumRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/MusicAlbum")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMusicArtistRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetMusicArtistRemoteSearchResults builder with application/*+json body
func NewGetMusicArtistRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicArtistRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetMusicArtistRemoteSearchResultsRequest calls the generic GetMusicArtistRemoteSearchResults builder with application/json body
func NewGetMusicArtistRemoteSearchResultsRequest(server string, body GetMusicArtistRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicArtistRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMusicArtistRemoteSearchResultsRequestWithBody generates requests for GetMusicArtistRemoteSearchResults with any type of body
func NewGetMusicArtistRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/MusicArtist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMusicVideoRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetMusicVideoRemoteSearchResults builder with application/*+json body
func NewGetMusicVideoRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicVideoRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetMusicVideoRemoteSearchResultsRequest calls the generic GetMusicVideoRemoteSearchResults builder with application/json body
func NewGetMusicVideoRemoteSearchResultsRequest(server string, body GetMusicVideoRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMusicVideoRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMusicVideoRemoteSearchResultsRequestWithBody generates requests for GetMusicVideoRemoteSearchResults with any type of body
func NewGetMusicVideoRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/MusicVideo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetPersonRemoteSearchResults builder with application/*+json body
func NewGetPersonRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPersonRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetPersonRemoteSearchResultsRequest calls the generic GetPersonRemoteSearchResults builder with application/json body
func NewGetPersonRemoteSearchResultsRequest(server string, body GetPersonRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPersonRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetPersonRemoteSearchResultsRequestWithBody generates requests for GetPersonRemoteSearchResults with any type of body
func NewGetPersonRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSeriesRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetSeriesRemoteSearchResults builder with application/*+json body
func NewGetSeriesRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSeriesRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetSeriesRemoteSearchResultsRequest calls the generic GetSeriesRemoteSearchResults builder with application/json body
func NewGetSeriesRemoteSearchResultsRequest(server string, body GetSeriesRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSeriesRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSeriesRemoteSearchResultsRequestWithBody generates requests for GetSeriesRemoteSearchResults with any type of body
func NewGetSeriesRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTrailerRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody calls the generic GetTrailerRemoteSearchResults builder with application/*+json body
func NewGetTrailerRemoteSearchResultsRequestWithApplicationWildcardPlusJSONBody(server string, body GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTrailerRemoteSearchResultsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetTrailerRemoteSearchResultsRequest calls the generic GetTrailerRemoteSearchResults builder with application/json body
func NewGetTrailerRemoteSearchResultsRequest(server string, body GetTrailerRemoteSearchResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTrailerRemoteSearchResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetTrailerRemoteSearchResultsRequestWithBody generates requests for GetTrailerRemoteSearchResults with any type of body
func NewGetTrailerRemoteSearchResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/RemoteSearch/Trailer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstantMixFromItemRequest generates requests for GetInstantMixFromItem
func NewGetInstantMixFromItemRequest(server string, id openapi_types.UUID, params *GetInstantMixFromItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemRequest generates requests for DeleteItem
func NewDeleteItemRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateItem builder with application/*+json body
func NewUpdateItemRequestWithApplicationWildcardPlusJSONBody(server string, itemId openapi_types.UUID, body UpdateItemApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateItemRequestWithBody(server, itemId, "application/*+json", bodyReader)
}

// NewUpdateItemRequest calls the generic UpdateItem builder with application/json body
func NewUpdateItemRequest(server string, itemId openapi_types.UUID, body UpdateItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateItemRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUpdateItemRequestWithBody generates requests for UpdateItem with any type of body
func NewUpdateItemRequestWithBody(server string, itemId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAncestorsRequest generates requests for GetAncestors
func NewGetAncestorsRequest(server string, itemId openapi_types.UUID, params *GetAncestorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Ancestors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemContentTypeRequest generates requests for UpdateItemContentType
func NewUpdateItemContentTypeRequest(server string, itemId openapi_types.UUID, params *UpdateItemContentTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/ContentType", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentType", runtime.ParamLocationQuery, *params.ContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCriticReviewsRequest generates requests for GetCriticReviews
func NewGetCriticReviewsRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/CriticReviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDownloadRequest generates requests for GetDownload
func NewGetDownloadRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExternalIdInfosRequest generates requests for GetExternalIdInfos
func NewGetExternalIdInfosRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/ExternalIdInfos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/File", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemImageInfosRequest generates requests for GetItemImageInfos
func NewGetItemImageInfosRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemImageRequest generates requests for DeleteItemImage
func NewDeleteItemImageRequest(server string, itemId openapi_types.UUID, imageType ImageType, params *DeleteItemImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemImageRequest generates requests for GetItemImage
func NewGetItemImageRequest(server string, itemId openapi_types.UUID, imageType ImageType, params *GetItemImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadItemImageRequest generates requests for HeadItemImage
func NewHeadItemImageRequest(server string, itemId openapi_types.UUID, imageType ImageType, params *HeadItemImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetItemImageRequestWithBody generates requests for SetItemImage with any type of body
func NewSetItemImageRequestWithBody(server string, itemId openapi_types.UUID, imageType ImageType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteItemImageByIndexRequest generates requests for DeleteItemImageByIndex
func NewDeleteItemImageByIndexRequest(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemImageByIndexRequest generates requests for GetItemImageByIndex
func NewGetItemImageByIndexRequest(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetItemImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadItemImageByIndexRequest generates requests for HeadItemImageByIndex
func NewHeadItemImageByIndexRequest(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadItemImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetItemImageByIndexRequestWithBody generates requests for SetItemImageByIndex with any type of body
func NewSetItemImageByIndexRequestWithBody(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateItemImageIndexRequest generates requests for UpdateItemImageIndex
func NewUpdateItemImageIndexRequest(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *UpdateItemImageIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s/Index", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newIndex", runtime.ParamLocationQuery, params.NewIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemImage2Request generates requests for GetItemImage2
func NewGetItemImage2Request(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *GetItemImage2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "format", runtime.ParamLocationPath, format)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "maxWidth", runtime.ParamLocationPath, maxWidth)
	if err != nil {
		return nil, err
	}

	var pathParam6 string

	pathParam6, err = runtime.StyleParamWithLocation("simple", false, "maxHeight", runtime.ParamLocationPath, maxHeight)
	if err != nil {
		return nil, err
	}

	var pathParam7 string

	pathParam7, err = runtime.StyleParamWithLocation("simple", false, "percentPlayed", runtime.ParamLocationPath, percentPlayed)
	if err != nil {
		return nil, err
	}

	var pathParam8 string

	pathParam8, err = runtime.StyleParamWithLocation("simple", false, "unplayedCount", runtime.ParamLocationPath, unplayedCount)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s/%s/%s/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5, pathParam6, pathParam7, pathParam8)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadItemImage2Request generates requests for HeadItemImage2
func NewHeadItemImage2Request(server string, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *HeadItemImage2Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "format", runtime.ParamLocationPath, format)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "maxWidth", runtime.ParamLocationPath, maxWidth)
	if err != nil {
		return nil, err
	}

	var pathParam6 string

	pathParam6, err = runtime.StyleParamWithLocation("simple", false, "maxHeight", runtime.ParamLocationPath, maxHeight)
	if err != nil {
		return nil, err
	}

	var pathParam7 string

	pathParam7, err = runtime.StyleParamWithLocation("simple", false, "percentPlayed", runtime.ParamLocationPath, percentPlayed)
	if err != nil {
		return nil, err
	}

	var pathParam8 string

	pathParam8, err = runtime.StyleParamWithLocation("simple", false, "unplayedCount", runtime.ParamLocationPath, unplayedCount)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Images/%s/%s/%s/%s/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5, pathParam6, pathParam7, pathParam8)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetadataEditorInfoRequest generates requests for GetMetadataEditorInfo
func NewGetMetadataEditorInfoRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/MetadataEditor", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaybackInfoRequest generates requests for GetPlaybackInfo
func NewGetPlaybackInfoRequest(server string, itemId openapi_types.UUID, params *GetPlaybackInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/PlaybackInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostedPlaybackInfoRequestWithApplicationWildcardPlusJSONBody calls the generic GetPostedPlaybackInfo builder with application/*+json body
func NewGetPostedPlaybackInfoRequestWithApplicationWildcardPlusJSONBody(server string, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPostedPlaybackInfoRequestWithBody(server, itemId, params, "application/*+json", bodyReader)
}

// NewGetPostedPlaybackInfoRequest calls the generic GetPostedPlaybackInfo builder with application/json body
func NewGetPostedPlaybackInfoRequest(server string, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPostedPlaybackInfoRequestWithBody(server, itemId, params, "application/json", bodyReader)
}

// NewGetPostedPlaybackInfoRequestWithBody generates requests for GetPostedPlaybackInfo with any type of body
func NewGetPostedPlaybackInfoRequestWithBody(server string, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/PlaybackInfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutoOpenLiveStream != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "autoOpenLiveStream", runtime.ParamLocationQuery, *params.AutoOpenLiveStream); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableDirectPlay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableDirectPlay", runtime.ParamLocationQuery, *params.EnableDirectPlay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableDirectStream != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableDirectStream", runtime.ParamLocationQuery, *params.EnableDirectStream); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTranscoding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTranscoding", runtime.ParamLocationQuery, *params.EnableTranscoding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshItemRequest generates requests for RefreshItem
func NewRefreshItemRequest(server string, itemId openapi_types.UUID, params *RefreshItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MetadataRefreshMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadataRefreshMode", runtime.ParamLocationQuery, *params.MetadataRefreshMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageRefreshMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageRefreshMode", runtime.ParamLocationQuery, *params.ImageRefreshMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReplaceAllMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replaceAllMetadata", runtime.ParamLocationQuery, *params.ReplaceAllMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReplaceAllImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replaceAllImages", runtime.ParamLocationQuery, *params.ReplaceAllImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteImagesRequest generates requests for GetRemoteImages
func NewGetRemoteImagesRequest(server string, itemId openapi_types.UUID, params *GetRemoteImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/RemoteImages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProviderName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "providerName", runtime.ParamLocationQuery, *params.ProviderName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAllLanguages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeAllLanguages", runtime.ParamLocationQuery, *params.IncludeAllLanguages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadRemoteImageRequest generates requests for DownloadRemoteImage
func NewDownloadRemoteImageRequest(server string, itemId openapi_types.UUID, params *DownloadRemoteImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/RemoteImages/Download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ImageUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageUrl", runtime.ParamLocationQuery, *params.ImageUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteImageProvidersRequest generates requests for GetRemoteImageProviders
func NewGetRemoteImageProvidersRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/RemoteImages/Providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRemoteSubtitlesRequest generates requests for SearchRemoteSubtitles
func NewSearchRemoteSubtitlesRequest(server string, itemId openapi_types.UUID, language string, params *SearchRemoteSubtitlesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationPath, language)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/RemoteSearch/Subtitles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsPerfectMatch != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPerfectMatch", runtime.ParamLocationQuery, *params.IsPerfectMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadRemoteSubtitlesRequest generates requests for DownloadRemoteSubtitles
func NewDownloadRemoteSubtitlesRequest(server string, itemId openapi_types.UUID, subtitleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subtitleId", runtime.ParamLocationPath, subtitleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/RemoteSearch/Subtitles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarItemsRequest generates requests for GetSimilarItems
func NewGetSimilarItemsRequest(server string, itemId openapi_types.UUID, params *GetSimilarItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThemeMediaRequest generates requests for GetThemeMedia
func NewGetThemeMediaRequest(server string, itemId openapi_types.UUID, params *GetThemeMediaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/ThemeMedia", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InheritFromParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inheritFromParent", runtime.ParamLocationQuery, *params.InheritFromParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThemeSongsRequest generates requests for GetThemeSongs
func NewGetThemeSongsRequest(server string, itemId openapi_types.UUID, params *GetThemeSongsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/ThemeSongs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InheritFromParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inheritFromParent", runtime.ParamLocationQuery, *params.InheritFromParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThemeVideosRequest generates requests for GetThemeVideos
func NewGetThemeVideosRequest(server string, itemId openapi_types.UUID, params *GetThemeVideosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Items/%s/ThemeVideos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InheritFromParent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inheritFromParent", runtime.ParamLocationQuery, *params.InheritFromParent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateLoginInfoRequestWithApplicationWildcardPlusJSONBody calls the generic ValidateLoginInfo builder with application/*+json body
func NewValidateLoginInfoRequestWithApplicationWildcardPlusJSONBody(server string, body ValidateLoginInfoApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateLoginInfoRequestWithBody(server, "application/*+json", bodyReader)
}

// NewValidateLoginInfoRequest calls the generic ValidateLoginInfo builder with application/json body
func NewValidateLoginInfoRequest(server string, body ValidateLoginInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateLoginInfoRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateLoginInfoRequestWithBody generates requests for ValidateLoginInfo with any type of body
func NewValidateLoginInfoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Jellyfin.Plugin.OpenSubtitles/ValidateLoginInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLibraryOptionsInfoRequest generates requests for GetLibraryOptionsInfo
func NewGetLibraryOptionsInfoRequest(server string, params *GetLibraryOptionsInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Libraries/AvailableOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LibraryContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "libraryContentType", runtime.ParamLocationQuery, *params.LibraryContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNewLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNewLibrary", runtime.ParamLocationQuery, *params.IsNewLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUpdatedMediaRequestWithApplicationWildcardPlusJSONBody calls the generic PostUpdatedMedia builder with application/*+json body
func NewPostUpdatedMediaRequestWithApplicationWildcardPlusJSONBody(server string, body PostUpdatedMediaApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUpdatedMediaRequestWithBody(server, "application/*+json", bodyReader)
}

// NewPostUpdatedMediaRequest calls the generic PostUpdatedMedia builder with application/json body
func NewPostUpdatedMediaRequest(server string, body PostUpdatedMediaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUpdatedMediaRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUpdatedMediaRequestWithBody generates requests for PostUpdatedMedia with any type of body
func NewPostUpdatedMediaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Media/Updated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMediaFoldersRequest generates requests for GetMediaFolders
func NewGetMediaFoldersRequest(server string, params *GetMediaFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/MediaFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHidden", runtime.ParamLocationQuery, *params.IsHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAddedMoviesRequest generates requests for PostAddedMovies
func NewPostAddedMoviesRequest(server string, params *PostAddedMoviesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Movies/Added")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmdbId", runtime.ParamLocationQuery, *params.TmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imdbId", runtime.ParamLocationQuery, *params.ImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUpdatedMoviesRequest generates requests for PostUpdatedMovies
func NewPostUpdatedMoviesRequest(server string, params *PostUpdatedMoviesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Movies/Updated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tmdbId", runtime.ParamLocationQuery, *params.TmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imdbId", runtime.ParamLocationQuery, *params.ImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPhysicalPathsRequest generates requests for GetPhysicalPaths
func NewGetPhysicalPathsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/PhysicalPaths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshLibraryRequest generates requests for RefreshLibrary
func NewRefreshLibraryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAddedSeriesRequest generates requests for PostAddedSeries
func NewPostAddedSeriesRequest(server string, params *PostAddedSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Series/Added")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tvdbId", runtime.ParamLocationQuery, *params.TvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUpdatedSeriesRequest generates requests for PostUpdatedSeries
func NewPostUpdatedSeriesRequest(server string, params *PostUpdatedSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/Series/Updated")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tvdbId", runtime.ParamLocationQuery, *params.TvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveVirtualFolderRequest generates requests for RemoveVirtualFolder
func NewRemoveVirtualFolderRequest(server string, params *RemoveVirtualFolderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refreshLibrary", runtime.ParamLocationQuery, *params.RefreshLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualFoldersRequest generates requests for GetVirtualFolders
func NewGetVirtualFoldersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualFolderRequestWithApplicationWildcardPlusJSONBody calls the generic AddVirtualFolder builder with application/*+json body
func NewAddVirtualFolderRequestWithApplicationWildcardPlusJSONBody(server string, params *AddVirtualFolderParams, body AddVirtualFolderApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualFolderRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewAddVirtualFolderRequest calls the generic AddVirtualFolder builder with application/json body
func NewAddVirtualFolderRequest(server string, params *AddVirtualFolderParams, body AddVirtualFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualFolderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddVirtualFolderRequestWithBody generates requests for AddVirtualFolder with any type of body
func NewAddVirtualFolderRequestWithBody(server string, params *AddVirtualFolderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collectionType", runtime.ParamLocationQuery, *params.CollectionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refreshLibrary", runtime.ParamLocationQuery, *params.RefreshLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateLibraryOptionsRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateLibraryOptions builder with application/*+json body
func NewUpdateLibraryOptionsRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLibraryOptionsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateLibraryOptionsRequest calls the generic UpdateLibraryOptions builder with application/json body
func NewUpdateLibraryOptionsRequest(server string, body UpdateLibraryOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLibraryOptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateLibraryOptionsRequestWithBody generates requests for UpdateLibraryOptions with any type of body
func NewUpdateLibraryOptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders/LibraryOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRenameVirtualFolderRequest generates requests for RenameVirtualFolder
func NewRenameVirtualFolderRequest(server string, params *RenameVirtualFolderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders/Name")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NewName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newName", runtime.ParamLocationQuery, *params.NewName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refreshLibrary", runtime.ParamLocationQuery, *params.RefreshLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMediaPathRequest generates requests for RemoveMediaPath
func NewRemoveMediaPathRequest(server string, params *RemoveMediaPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders/Paths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RefreshLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refreshLibrary", runtime.ParamLocationQuery, *params.RefreshLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMediaPathRequestWithApplicationWildcardPlusJSONBody calls the generic AddMediaPath builder with application/*+json body
func NewAddMediaPathRequestWithApplicationWildcardPlusJSONBody(server string, params *AddMediaPathParams, body AddMediaPathApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMediaPathRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewAddMediaPathRequest calls the generic AddMediaPath builder with application/json body
func NewAddMediaPathRequest(server string, params *AddMediaPathParams, body AddMediaPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMediaPathRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddMediaPathRequestWithBody generates requests for AddMediaPath with any type of body
func NewAddMediaPathRequestWithBody(server string, params *AddMediaPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders/Paths")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RefreshLibrary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refreshLibrary", runtime.ParamLocationQuery, *params.RefreshLibrary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateMediaPathRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateMediaPath builder with application/*+json body
func NewUpdateMediaPathRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateMediaPathApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMediaPathRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateMediaPathRequest calls the generic UpdateMediaPath builder with application/json body
func NewUpdateMediaPathRequest(server string, body UpdateMediaPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMediaPathRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateMediaPathRequestWithBody generates requests for UpdateMediaPath with any type of body
func NewUpdateMediaPathRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Library/VirtualFolders/Paths/Update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloseLiveStreamRequest generates requests for CloseLiveStream
func NewCloseLiveStreamRequest(server string, params *CloseLiveStreamParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveStreams/Close")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, params.LiveStreamId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenLiveStreamRequestWithApplicationWildcardPlusJSONBody calls the generic OpenLiveStream builder with application/*+json body
func NewOpenLiveStreamRequestWithApplicationWildcardPlusJSONBody(server string, params *OpenLiveStreamParams, body OpenLiveStreamApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOpenLiveStreamRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewOpenLiveStreamRequest calls the generic OpenLiveStream builder with application/json body
func NewOpenLiveStreamRequest(server string, params *OpenLiveStreamParams, body OpenLiveStreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOpenLiveStreamRequestWithBody(server, params, "application/json", bodyReader)
}

// NewOpenLiveStreamRequestWithBody generates requests for OpenLiveStream with any type of body
func NewOpenLiveStreamRequestWithBody(server string, params *OpenLiveStreamParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveStreams/Open")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OpenToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "openToken", runtime.ParamLocationQuery, *params.OpenToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStreamingBitrate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStreamingBitrate", runtime.ParamLocationQuery, *params.MaxStreamingBitrate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemId", runtime.ParamLocationQuery, *params.ItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableDirectPlay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableDirectPlay", runtime.ParamLocationQuery, *params.EnableDirectPlay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableDirectStream != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableDirectStream", runtime.ParamLocationQuery, *params.EnableDirectStream); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelMappingOptionsRequest generates requests for GetChannelMappingOptions
func NewGetChannelMappingOptionsRequest(server string, params *GetChannelMappingOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ChannelMappingOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProviderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "providerId", runtime.ParamLocationQuery, *params.ProviderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetChannelMappingRequestWithApplicationWildcardPlusJSONBody calls the generic SetChannelMapping builder with application/*+json body
func NewSetChannelMappingRequestWithApplicationWildcardPlusJSONBody(server string, body SetChannelMappingApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetChannelMappingRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSetChannelMappingRequest calls the generic SetChannelMapping builder with application/json body
func NewSetChannelMappingRequest(server string, body SetChannelMappingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetChannelMappingRequestWithBody(server, "application/json", bodyReader)
}

// NewSetChannelMappingRequestWithBody generates requests for SetChannelMapping with any type of body
func NewSetChannelMappingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ChannelMappings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLiveTvChannelsRequest generates requests for GetLiveTvChannels
func NewGetLiveTvChannelsRequest(server string, params *GetLiveTvChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLiked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLiked", runtime.ParamLocationQuery, *params.IsLiked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDisliked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDisliked", runtime.ParamLocationQuery, *params.IsDisliked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableFavoriteSorting != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableFavoriteSorting", runtime.ParamLocationQuery, *params.EnableFavoriteSorting); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddCurrentProgram != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addCurrentProgram", runtime.ParamLocationQuery, *params.AddCurrentProgram); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelRequest generates requests for GetChannel
func NewGetChannelRequest(server string, channelId openapi_types.UUID, params *GetChannelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGuideInfoRequest generates requests for GetGuideInfo
func NewGetGuideInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/GuideInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveTvInfoRequest generates requests for GetLiveTvInfo
func NewGetLiveTvInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteListingProviderRequest generates requests for DeleteListingProvider
func NewDeleteListingProviderRequest(server string, params *DeleteListingProviderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ListingProviders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddListingProviderRequestWithApplicationWildcardPlusJSONBody calls the generic AddListingProvider builder with application/*+json body
func NewAddListingProviderRequestWithApplicationWildcardPlusJSONBody(server string, params *AddListingProviderParams, body AddListingProviderApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddListingProviderRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewAddListingProviderRequest calls the generic AddListingProvider builder with application/json body
func NewAddListingProviderRequest(server string, params *AddListingProviderParams, body AddListingProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddListingProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddListingProviderRequestWithBody generates requests for AddListingProvider with any type of body
func NewAddListingProviderRequestWithBody(server string, params *AddListingProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ListingProviders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pw", runtime.ParamLocationQuery, *params.Pw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ValidateListings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "validateListings", runtime.ParamLocationQuery, *params.ValidateListings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ValidateLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "validateLogin", runtime.ParamLocationQuery, *params.ValidateLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultListingProviderRequest generates requests for GetDefaultListingProvider
func NewGetDefaultListingProviderRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ListingProviders/Default")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineupsRequest generates requests for GetLineups
func NewGetLineupsRequest(server string, params *GetLineupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ListingProviders/Lineups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Location != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesDirectCountriesRequest generates requests for GetSchedulesDirectCountries
func NewGetSchedulesDirectCountriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/ListingProviders/SchedulesDirect/Countries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveRecordingFileRequest generates requests for GetLiveRecordingFile
func NewGetLiveRecordingFileRequest(server string, recordingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, recordingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/LiveRecordings/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveStreamFileRequest generates requests for GetLiveStreamFile
func NewGetLiveStreamFileRequest(server string, streamId string, container string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/LiveStreamFiles/%s/stream.%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveTvProgramsRequest generates requests for GetLiveTvPrograms
func NewGetLiveTvProgramsRequest(server string, params *GetLiveTvProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelIds", runtime.ParamLocationQuery, *params.ChannelIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinStartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minStartDate", runtime.ParamLocationQuery, *params.MinStartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasAired", runtime.ParamLocationQuery, *params.HasAired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsAiring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isAiring", runtime.ParamLocationQuery, *params.IsAiring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxStartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxStartDate", runtime.ParamLocationQuery, *params.MaxStartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minEndDate", runtime.ParamLocationQuery, *params.MinEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxEndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxEndDate", runtime.ParamLocationQuery, *params.MaxEndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesTimerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesTimerId", runtime.ParamLocationQuery, *params.SeriesTimerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LibrarySeriesId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "librarySeriesId", runtime.ParamLocationQuery, *params.LibrarySeriesId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramsRequestWithApplicationWildcardPlusJSONBody calls the generic GetPrograms builder with application/*+json body
func NewGetProgramsRequestWithApplicationWildcardPlusJSONBody(server string, body GetProgramsApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetProgramsRequestWithBody(server, "application/*+json", bodyReader)
}

// NewGetProgramsRequest calls the generic GetPrograms builder with application/json body
func NewGetProgramsRequest(server string, body GetProgramsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetProgramsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetProgramsRequestWithBody generates requests for GetPrograms with any type of body
func NewGetProgramsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecommendedProgramsRequest generates requests for GetRecommendedPrograms
func NewGetRecommendedProgramsRequest(server string, params *GetRecommendedProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Programs/Recommended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsAiring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isAiring", runtime.ParamLocationQuery, *params.IsAiring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasAired", runtime.ParamLocationQuery, *params.HasAired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, programId string, params *GetProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingsRequest generates requests for GetRecordings
func NewGetRecordingsRequest(server string, params *GetRecordingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInProgress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isInProgress", runtime.ParamLocationQuery, *params.IsInProgress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesTimerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesTimerId", runtime.ParamLocationQuery, *params.SeriesTimerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLibraryItem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLibraryItem", runtime.ParamLocationQuery, *params.IsLibraryItem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingFoldersRequest generates requests for GetRecordingFolders
func NewGetRecordingFoldersRequest(server string, params *GetRecordingFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/Folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingGroupsRequest generates requests for GetRecordingGroups
func NewGetRecordingGroupsRequest(server string, params *GetRecordingGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/Groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingGroupRequest generates requests for GetRecordingGroup
func NewGetRecordingGroupRequest(server string, groupId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/Groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingsSeriesRequest generates requests for GetRecordingsSeries
func NewGetRecordingsSeriesRequest(server string, params *GetRecordingsSeriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/Series")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupId", runtime.ParamLocationQuery, *params.GroupId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInProgress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isInProgress", runtime.ParamLocationQuery, *params.IsInProgress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesTimerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesTimerId", runtime.ParamLocationQuery, *params.SeriesTimerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordingRequest generates requests for DeleteRecording
func NewDeleteRecordingRequest(server string, recordingId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, recordingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingRequest generates requests for GetRecording
func NewGetRecordingRequest(server string, recordingId openapi_types.UUID, params *GetRecordingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, recordingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Recordings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesTimersRequest generates requests for GetSeriesTimers
func NewGetSeriesTimersRequest(server string, params *GetSeriesTimersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/SeriesTimers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSeriesTimerRequestWithApplicationWildcardPlusJSONBody calls the generic CreateSeriesTimer builder with application/*+json body
func NewCreateSeriesTimerRequestWithApplicationWildcardPlusJSONBody(server string, body CreateSeriesTimerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSeriesTimerRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateSeriesTimerRequest calls the generic CreateSeriesTimer builder with application/json body
func NewCreateSeriesTimerRequest(server string, body CreateSeriesTimerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSeriesTimerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSeriesTimerRequestWithBody generates requests for CreateSeriesTimer with any type of body
func NewCreateSeriesTimerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/SeriesTimers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSeriesTimerRequest generates requests for CancelSeriesTimer
func NewCancelSeriesTimerRequest(server string, timerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/SeriesTimers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeriesTimerRequest generates requests for GetSeriesTimer
func NewGetSeriesTimerRequest(server string, timerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/SeriesTimers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSeriesTimerRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateSeriesTimer builder with application/*+json body
func NewUpdateSeriesTimerRequestWithApplicationWildcardPlusJSONBody(server string, timerId string, body UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSeriesTimerRequestWithBody(server, timerId, "application/*+json", bodyReader)
}

// NewUpdateSeriesTimerRequest calls the generic UpdateSeriesTimer builder with application/json body
func NewUpdateSeriesTimerRequest(server string, timerId string, body UpdateSeriesTimerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSeriesTimerRequestWithBody(server, timerId, "application/json", bodyReader)
}

// NewUpdateSeriesTimerRequestWithBody generates requests for UpdateSeriesTimer with any type of body
func NewUpdateSeriesTimerRequestWithBody(server string, timerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/SeriesTimers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTimersRequest generates requests for GetTimers
func NewGetTimersRequest(server string, params *GetTimersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesTimerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesTimerId", runtime.ParamLocationQuery, *params.SeriesTimerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isActive", runtime.ParamLocationQuery, *params.IsActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsScheduled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isScheduled", runtime.ParamLocationQuery, *params.IsScheduled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTimerRequestWithApplicationWildcardPlusJSONBody calls the generic CreateTimer builder with application/*+json body
func NewCreateTimerRequestWithApplicationWildcardPlusJSONBody(server string, body CreateTimerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTimerRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateTimerRequest calls the generic CreateTimer builder with application/json body
func NewCreateTimerRequest(server string, body CreateTimerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTimerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTimerRequestWithBody generates requests for CreateTimer with any type of body
func NewCreateTimerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultTimerRequest generates requests for GetDefaultTimer
func NewGetDefaultTimerRequest(server string, params *GetDefaultTimerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers/Defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ProgramId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "programId", runtime.ParamLocationQuery, *params.ProgramId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelTimerRequest generates requests for CancelTimer
func NewCancelTimerRequest(server string, timerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTimerRequest generates requests for GetTimer
func NewGetTimerRequest(server string, timerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTimerRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateTimer builder with application/*+json body
func NewUpdateTimerRequestWithApplicationWildcardPlusJSONBody(server string, timerId string, body UpdateTimerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTimerRequestWithBody(server, timerId, "application/*+json", bodyReader)
}

// NewUpdateTimerRequest calls the generic UpdateTimer builder with application/json body
func NewUpdateTimerRequest(server string, timerId string, body UpdateTimerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTimerRequestWithBody(server, timerId, "application/json", bodyReader)
}

// NewUpdateTimerRequestWithBody generates requests for UpdateTimer with any type of body
func NewUpdateTimerRequestWithBody(server string, timerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "timerId", runtime.ParamLocationPath, timerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Timers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTunerHostRequest generates requests for DeleteTunerHost
func NewDeleteTunerHostRequest(server string, params *DeleteTunerHostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/TunerHosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTunerHostRequestWithApplicationWildcardPlusJSONBody calls the generic AddTunerHost builder with application/*+json body
func NewAddTunerHostRequestWithApplicationWildcardPlusJSONBody(server string, body AddTunerHostApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTunerHostRequestWithBody(server, "application/*+json", bodyReader)
}

// NewAddTunerHostRequest calls the generic AddTunerHost builder with application/json body
func NewAddTunerHostRequest(server string, body AddTunerHostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTunerHostRequestWithBody(server, "application/json", bodyReader)
}

// NewAddTunerHostRequestWithBody generates requests for AddTunerHost with any type of body
func NewAddTunerHostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/TunerHosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTunerHostTypesRequest generates requests for GetTunerHostTypes
func NewGetTunerHostTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/TunerHosts/Types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscoverTunersRequest generates requests for DiscoverTuners
func NewDiscoverTunersRequest(server string, params *DiscoverTunersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Tuners/Discover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewDevicesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newDevicesOnly", runtime.ParamLocationQuery, *params.NewDevicesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiscvoverTunersRequest generates requests for DiscvoverTuners
func NewDiscvoverTunersRequest(server string, params *DiscvoverTunersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Tuners/Discvover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewDevicesOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newDevicesOnly", runtime.ParamLocationQuery, *params.NewDevicesOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetTunerRequest generates requests for ResetTuner
func NewResetTunerRequest(server string, tunerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tunerId", runtime.ParamLocationPath, tunerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/LiveTv/Tuners/%s/Reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCountriesRequest generates requests for GetCountries
func NewGetCountriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Localization/Countries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCulturesRequest generates requests for GetCultures
func NewGetCulturesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Localization/Cultures")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalizationOptionsRequest generates requests for GetLocalizationOptions
func NewGetLocalizationOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Localization/Options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParentalRatingsRequest generates requests for GetParentalRatings
func NewGetParentalRatingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Localization/ParentalRatings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieRecommendationsRequest generates requests for GetMovieRecommendations
func NewGetMovieRecommendationsRequest(server string, params *GetMovieRecommendationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Movies/Recommendations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categoryLimit", runtime.ParamLocationQuery, *params.CategoryLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemLimit", runtime.ParamLocationQuery, *params.ItemLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarMoviesRequest generates requests for GetSimilarMovies
func NewGetSimilarMoviesRequest(server string, itemId openapi_types.UUID, params *GetSimilarMoviesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Movies/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMusicGenresRequest generates requests for GetMusicGenres
func NewGetMusicGenresRequest(server string, params *GetMusicGenresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantMixFromMusicGenreByIdRequest generates requests for GetInstantMixFromMusicGenreById
func NewGetInstantMixFromMusicGenreByIdRequest(server string, params *GetInstantMixFromMusicGenreByIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/InstantMix")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMusicGenreRequest generates requests for GetMusicGenre
func NewGetMusicGenreRequest(server string, genreName string, params *GetMusicGenreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "genreName", runtime.ParamLocationPath, genreName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMusicGenreImageRequest generates requests for GetMusicGenreImage
func NewGetMusicGenreImageRequest(server string, name string, imageType ImageType, params *GetMusicGenreImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadMusicGenreImageRequest generates requests for HeadMusicGenreImage
func NewHeadMusicGenreImageRequest(server string, name string, imageType ImageType, params *HeadMusicGenreImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMusicGenreImageByIndexRequest generates requests for GetMusicGenreImageByIndex
func NewGetMusicGenreImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *GetMusicGenreImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadMusicGenreImageByIndexRequest generates requests for HeadMusicGenreImageByIndex
func NewHeadMusicGenreImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *HeadMusicGenreImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantMixFromMusicGenreByNameRequest generates requests for GetInstantMixFromMusicGenreByName
func NewGetInstantMixFromMusicGenreByNameRequest(server string, name string, params *GetInstantMixFromMusicGenreByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/MusicGenres/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAdminNotificationRequestWithApplicationWildcardPlusJSONBody calls the generic CreateAdminNotification builder with application/*+json body
func NewCreateAdminNotificationRequestWithApplicationWildcardPlusJSONBody(server string, body CreateAdminNotificationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminNotificationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateAdminNotificationRequest calls the generic CreateAdminNotification builder with application/json body
func NewCreateAdminNotificationRequest(server string, body CreateAdminNotificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdminNotificationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAdminNotificationRequestWithBody generates requests for CreateAdminNotification with any type of body
func NewCreateAdminNotificationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/Admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationServicesRequest generates requests for GetNotificationServices
func NewGetNotificationServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/Services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationTypesRequest generates requests for GetNotificationTypes
func NewGetNotificationTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/Types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationsRequest generates requests for GetNotifications
func NewGetNotificationsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetReadRequest generates requests for SetRead
func NewSetReadRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/%s/Read", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationsSummaryRequest generates requests for GetNotificationsSummary
func NewGetNotificationsSummaryRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/%s/Summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetUnreadRequest generates requests for SetUnread
func NewSetUnreadRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Notifications/%s/Unread", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackagesRequest generates requests for GetPackages
func NewGetPackagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageRequest generates requests for InstallPackage
func NewInstallPackageRequest(server string, name string, params *InstallPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Packages/Installed/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssemblyGuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assemblyGuid", runtime.ParamLocationQuery, *params.AssemblyGuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RepositoryUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repositoryUrl", runtime.ParamLocationQuery, *params.RepositoryUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelPackageInstallationRequest generates requests for CancelPackageInstallation
func NewCancelPackageInstallationRequest(server string, packageId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageId", runtime.ParamLocationPath, packageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Packages/Installing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageInfoRequest generates requests for GetPackageInfo
func NewGetPackageInfoRequest(server string, name string, params *GetPackageInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Packages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssemblyGuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assemblyGuid", runtime.ParamLocationQuery, *params.AssemblyGuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonsRequest generates requests for GetPersons
func NewGetPersonsRequest(server string, params *GetPersonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludePersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludePersonTypes", runtime.ParamLocationQuery, *params.ExcludePersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppearsInItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appearsInItemId", runtime.ParamLocationQuery, *params.AppearsInItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonRequest generates requests for GetPerson
func NewGetPersonRequest(server string, name string, params *GetPersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonImageRequest generates requests for GetPersonImage
func NewGetPersonImageRequest(server string, name string, imageType ImageType, params *GetPersonImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadPersonImageRequest generates requests for HeadPersonImage
func NewHeadPersonImageRequest(server string, name string, imageType ImageType, params *HeadPersonImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonImageByIndexRequest generates requests for GetPersonImageByIndex
func NewGetPersonImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *GetPersonImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadPersonImageByIndexRequest generates requests for HeadPersonImageByIndex
func NewHeadPersonImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *HeadPersonImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Persons/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBitrateTestBytesRequest generates requests for GetBitrateTestBytes
func NewGetBitrateTestBytesRequest(server string, params *GetBitrateTestBytesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playback/BitrateTest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlaylistRequestWithApplicationWildcardPlusJSONBody calls the generic CreatePlaylist builder with application/*+json body
func NewCreatePlaylistRequestWithApplicationWildcardPlusJSONBody(server string, params *CreatePlaylistParams, body CreatePlaylistApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaylistRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewCreatePlaylistRequest calls the generic CreatePlaylist builder with application/json body
func NewCreatePlaylistRequest(server string, params *CreatePlaylistParams, body CreatePlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaylistRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlaylistRequestWithBody generates requests for CreatePlaylist with any type of body
func NewCreatePlaylistRequestWithBody(server string, params *CreatePlaylistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstantMixFromPlaylistRequest generates requests for GetInstantMixFromPlaylist
func NewGetInstantMixFromPlaylistRequest(server string, id openapi_types.UUID, params *GetInstantMixFromPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveFromPlaylistRequest generates requests for RemoveFromPlaylist
func NewRemoveFromPlaylistRequest(server string, playlistId string, params *RemoveFromPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EntryIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entryIds", runtime.ParamLocationQuery, *params.EntryIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaylistItemsRequest generates requests for GetPlaylistItems
func NewGetPlaylistItemsRequest(server string, playlistId openapi_types.UUID, params *GetPlaylistItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddToPlaylistRequest generates requests for AddToPlaylist
func NewAddToPlaylistRequest(server string, playlistId openapi_types.UUID, params *AddToPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMoveItemRequest generates requests for MoveItem
func NewMoveItemRequest(server string, playlistId string, itemId string, newIndex int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "newIndex", runtime.ParamLocationPath, newIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Playlists/%s/Items/%s/Move/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginsRequest generates requests for GetPlugins
func NewGetPluginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallPluginRequest generates requests for UninstallPlugin
func NewUninstallPluginRequest(server string, pluginId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginConfigurationRequest generates requests for GetPluginConfiguration
func NewGetPluginConfigurationRequest(server string, pluginId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/Configuration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginConfigurationRequest generates requests for UpdatePluginConfiguration
func NewUpdatePluginConfigurationRequest(server string, pluginId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/Configuration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginManifestRequest generates requests for GetPluginManifest
func NewGetPluginManifestRequest(server string, pluginId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/Manifest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallPluginByVersionRequest generates requests for UninstallPluginByVersion
func NewUninstallPluginByVersionRequest(server string, pluginId openapi_types.UUID, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisablePluginRequest generates requests for DisablePlugin
func NewDisablePluginRequest(server string, pluginId openapi_types.UUID, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/%s/Disable", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnablePluginRequest generates requests for EnablePlugin
func NewEnablePluginRequest(server string, pluginId openapi_types.UUID, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/%s/Enable", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginImageRequest generates requests for GetPluginImage
func NewGetPluginImageRequest(server string, pluginId openapi_types.UUID, version string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pluginId", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Plugins/%s/%s/Image", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRemoteSubtitlesRequest generates requests for GetRemoteSubtitles
func NewGetRemoteSubtitlesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Providers/Subtitles/Subtitles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/QuickConnect/Authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectRequest generates requests for Connect
func NewConnectRequest(server string, params *ConnectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/QuickConnect/Connect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret", runtime.ParamLocationQuery, params.Secret); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnabledRequest generates requests for GetEnabled
func NewGetEnabledRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/QuickConnect/Enabled")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitiateRequest generates requests for Initiate
func NewInitiateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/QuickConnect/Initiate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityLogsRequest generates requests for GetActivityLogs
func NewGetActivityLogsRequest(server string, params *GetActivityLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Reports/Activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReportView != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportView", runtime.ParamLocationQuery, *params.ReportView); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayType", runtime.ParamLocationQuery, *params.DisplayType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasQueryLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasQueryLimit", runtime.ParamLocationQuery, *params.HasQueryLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportColumns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportColumns", runtime.ParamLocationQuery, *params.ReportColumns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDate", runtime.ParamLocationQuery, *params.MinDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportHeadersRequest generates requests for GetReportHeaders
func NewGetReportHeadersRequest(server string, params *GetReportHeadersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Reports/Headers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReportView != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportView", runtime.ParamLocationQuery, *params.ReportView); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemReportRequest generates requests for GetItemReport
func NewGetItemReportRequest(server string, params *GetItemReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Reports/Items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HasThemeSong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeSong", runtime.ParamLocationQuery, *params.HasThemeSong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeVideo", runtime.ParamLocationQuery, *params.HasThemeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSubtitles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSubtitles", runtime.ParamLocationQuery, *params.HasSubtitles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSpecialFeature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSpecialFeature", runtime.ParamLocationQuery, *params.HasSpecialFeature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTrailer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTrailer", runtime.ParamLocationQuery, *params.HasTrailer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minIndexNumber", runtime.ParamLocationQuery, *params.MinIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentIndexNumber", runtime.ParamLocationQuery, *params.ParentIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasParentalRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasParentalRating", runtime.ParamLocationQuery, *params.HasParentalRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHd", runtime.ParamLocationQuery, *params.IsHd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationTypes", runtime.ParamLocationQuery, *params.LocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeLocationTypes", runtime.ParamLocationQuery, *params.ExcludeLocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsUnaried != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isUnaried", runtime.ParamLocationQuery, *params.IsUnaried); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCriticRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCriticRating", runtime.ParamLocationQuery, *params.MinCriticRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AiredDuringSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "airedDuringSeason", runtime.ParamLocationQuery, *params.AiredDuringSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPremiereDate", runtime.ParamLocationQuery, *params.MinPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSaved", runtime.ParamLocationQuery, *params.MinDateLastSaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSavedForUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSavedForUser", runtime.ParamLocationQuery, *params.MinDateLastSavedForUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPremiereDate", runtime.ParamLocationQuery, *params.MaxPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOverview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOverview", runtime.ParamLocationQuery, *params.HasOverview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasImdbId", runtime.ParamLocationQuery, *params.HasImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTmdbId", runtime.ParamLocationQuery, *params.HasTmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTvdbId", runtime.ParamLocationQuery, *params.HasTvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInBoxSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isInBoxSet", runtime.ParamLocationQuery, *params.IsInBoxSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemIds", runtime.ParamLocationQuery, *params.ExcludeItemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNotFavorite", runtime.ParamLocationQuery, *params.IsNotFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypes", runtime.ParamLocationQuery, *params.ImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artistIds", runtime.ParamLocationQuery, *params.ArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Albums != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albums", runtime.ParamLocationQuery, *params.Albums); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumIds", runtime.ParamLocationQuery, *params.AlbumIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoTypes", runtime.ParamLocationQuery, *params.VideoTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOfficialRating", runtime.ParamLocationQuery, *params.MinOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlaceHolder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlaceHolder", runtime.ParamLocationQuery, *params.IsPlaceHolder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOfficialRating", runtime.ParamLocationQuery, *params.HasOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapseBoxSetItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapseBoxSetItems", runtime.ParamLocationQuery, *params.CollapseBoxSetItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is3D != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is3D", runtime.ParamLocationQuery, *params.Is3D); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesStatus", runtime.ParamLocationQuery, *params.SeriesStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportView != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportView", runtime.ParamLocationQuery, *params.ReportView); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayType", runtime.ParamLocationQuery, *params.DisplayType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasQueryLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasQueryLimit", runtime.ParamLocationQuery, *params.HasQueryLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportColumns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportColumns", runtime.ParamLocationQuery, *params.ReportColumns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportDownloadRequest generates requests for GetReportDownload
func NewGetReportDownloadRequest(server string, params *GetReportDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Reports/Items/Download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HasThemeSong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeSong", runtime.ParamLocationQuery, *params.HasThemeSong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeVideo", runtime.ParamLocationQuery, *params.HasThemeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSubtitles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSubtitles", runtime.ParamLocationQuery, *params.HasSubtitles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSpecialFeature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSpecialFeature", runtime.ParamLocationQuery, *params.HasSpecialFeature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTrailer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTrailer", runtime.ParamLocationQuery, *params.HasTrailer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minIndexNumber", runtime.ParamLocationQuery, *params.MinIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentIndexNumber", runtime.ParamLocationQuery, *params.ParentIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasParentalRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasParentalRating", runtime.ParamLocationQuery, *params.HasParentalRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHd", runtime.ParamLocationQuery, *params.IsHd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationTypes", runtime.ParamLocationQuery, *params.LocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeLocationTypes", runtime.ParamLocationQuery, *params.ExcludeLocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsUnaried != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isUnaried", runtime.ParamLocationQuery, *params.IsUnaried); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCriticRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCriticRating", runtime.ParamLocationQuery, *params.MinCriticRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AiredDuringSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "airedDuringSeason", runtime.ParamLocationQuery, *params.AiredDuringSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPremiereDate", runtime.ParamLocationQuery, *params.MinPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSaved", runtime.ParamLocationQuery, *params.MinDateLastSaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSavedForUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSavedForUser", runtime.ParamLocationQuery, *params.MinDateLastSavedForUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPremiereDate", runtime.ParamLocationQuery, *params.MaxPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOverview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOverview", runtime.ParamLocationQuery, *params.HasOverview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasImdbId", runtime.ParamLocationQuery, *params.HasImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTmdbId", runtime.ParamLocationQuery, *params.HasTmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTvdbId", runtime.ParamLocationQuery, *params.HasTvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInBoxSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isInBoxSet", runtime.ParamLocationQuery, *params.IsInBoxSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemIds", runtime.ParamLocationQuery, *params.ExcludeItemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNotFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNotFavorite", runtime.ParamLocationQuery, *params.IsNotFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypes", runtime.ParamLocationQuery, *params.ImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artistIds", runtime.ParamLocationQuery, *params.ArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Albums != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albums", runtime.ParamLocationQuery, *params.Albums); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumIds", runtime.ParamLocationQuery, *params.AlbumIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoTypes", runtime.ParamLocationQuery, *params.VideoTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOfficialRating", runtime.ParamLocationQuery, *params.MinOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlaceHolder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlaceHolder", runtime.ParamLocationQuery, *params.IsPlaceHolder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOfficialRating", runtime.ParamLocationQuery, *params.HasOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapseBoxSetItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapseBoxSetItems", runtime.ParamLocationQuery, *params.CollapseBoxSetItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is3D != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is3D", runtime.ParamLocationQuery, *params.Is3D); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesStatus", runtime.ParamLocationQuery, *params.SeriesStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportView != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportView", runtime.ParamLocationQuery, *params.ReportView); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayType", runtime.ParamLocationQuery, *params.DisplayType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasQueryLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasQueryLimit", runtime.ParamLocationQuery, *params.HasQueryLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupBy", runtime.ParamLocationQuery, *params.GroupBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportColumns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportColumns", runtime.ParamLocationQuery, *params.ReportColumns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDate", runtime.ParamLocationQuery, *params.MinDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExportType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exportType", runtime.ParamLocationQuery, *params.ExportType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoriesRequest generates requests for GetRepositories
func NewGetRepositoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoriesRequestWithApplicationWildcardPlusJSONBody calls the generic SetRepositories builder with application/*+json body
func NewSetRepositoriesRequestWithApplicationWildcardPlusJSONBody(server string, body SetRepositoriesApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoriesRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSetRepositoriesRequest calls the generic SetRepositories builder with application/json body
func NewSetRepositoriesRequest(server string, body SetRepositoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoriesRequestWithBody(server, "application/json", bodyReader)
}

// NewSetRepositoriesRequestWithBody generates requests for SetRepositories with any type of body
func NewSetRepositoriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTasksRequest generates requests for GetTasks
func NewGetTasksRequest(server string, params *GetTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ScheduledTasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHidden", runtime.ParamLocationQuery, *params.IsHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isEnabled", runtime.ParamLocationQuery, *params.IsEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopTaskRequest generates requests for StopTask
func NewStopTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ScheduledTasks/Running/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartTaskRequest generates requests for StartTask
func NewStartTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ScheduledTasks/Running/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaskRequest generates requests for GetTask
func NewGetTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ScheduledTasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTaskRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateTask builder with application/*+json body
func NewUpdateTaskRequestWithApplicationWildcardPlusJSONBody(server string, taskId string, body UpdateTaskApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTaskRequestWithBody(server, taskId, "application/*+json", bodyReader)
}

// NewUpdateTaskRequest calls the generic UpdateTask builder with application/json body
func NewUpdateTaskRequest(server string, taskId string, body UpdateTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTaskRequestWithBody(server, taskId, "application/json", bodyReader)
}

// NewUpdateTaskRequestWithBody generates requests for UpdateTask with any type of body
func NewUpdateTaskRequestWithBody(server string, taskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taskId", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ScheduledTasks/%s/Triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(server string, params *GetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Search/Hints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, params.SearchTerm); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePeople != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includePeople", runtime.ParamLocationQuery, *params.IncludePeople); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMedia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeMedia", runtime.ParamLocationQuery, *params.IncludeMedia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeGenres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeGenres", runtime.ParamLocationQuery, *params.IncludeGenres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeStudios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeStudios", runtime.ParamLocationQuery, *params.IncludeStudios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeArtists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeArtists", runtime.ParamLocationQuery, *params.IncludeArtists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionsRequest generates requests for GetSessions
func NewGetSessionsRequest(server string, params *GetSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ControllableByUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "controllableByUserId", runtime.ParamLocationQuery, *params.ControllableByUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActiveWithinSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activeWithinSeconds", runtime.ParamLocationQuery, *params.ActiveWithinSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCapabilitiesRequest generates requests for PostCapabilities
func NewPostCapabilitiesRequest(server string, params *PostCapabilitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Capabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayableMediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playableMediaTypes", runtime.ParamLocationQuery, *params.PlayableMediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportedCommands != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportedCommands", runtime.ParamLocationQuery, *params.SupportedCommands); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportsMediaControl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsMediaControl", runtime.ParamLocationQuery, *params.SupportsMediaControl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportsSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsSync", runtime.ParamLocationQuery, *params.SupportsSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportsPersistentIdentifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supportsPersistentIdentifier", runtime.ParamLocationQuery, *params.SupportsPersistentIdentifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFullCapabilitiesRequestWithApplicationWildcardPlusJSONBody calls the generic PostFullCapabilities builder with application/*+json body
func NewPostFullCapabilitiesRequestWithApplicationWildcardPlusJSONBody(server string, params *PostFullCapabilitiesParams, body PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFullCapabilitiesRequestWithBody(server, params, "application/*+json", bodyReader)
}

// NewPostFullCapabilitiesRequest calls the generic PostFullCapabilities builder with application/json body
func NewPostFullCapabilitiesRequest(server string, params *PostFullCapabilitiesParams, body PostFullCapabilitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFullCapabilitiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFullCapabilitiesRequestWithBody generates requests for PostFullCapabilities with any type of body
func NewPostFullCapabilitiesRequestWithBody(server string, params *PostFullCapabilitiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Capabilities/Full")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReportSessionEndedRequest generates requests for ReportSessionEnded
func NewReportSessionEndedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportPlaybackStartRequestWithApplicationWildcardPlusJSONBody calls the generic ReportPlaybackStart builder with application/*+json body
func NewReportPlaybackStartRequestWithApplicationWildcardPlusJSONBody(server string, body ReportPlaybackStartApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackStartRequestWithBody(server, "application/*+json", bodyReader)
}

// NewReportPlaybackStartRequest calls the generic ReportPlaybackStart builder with application/json body
func NewReportPlaybackStartRequest(server string, body ReportPlaybackStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackStartRequestWithBody(server, "application/json", bodyReader)
}

// NewReportPlaybackStartRequestWithBody generates requests for ReportPlaybackStart with any type of body
func NewReportPlaybackStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Playing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPingPlaybackSessionRequest generates requests for PingPlaybackSession
func NewPingPlaybackSessionRequest(server string, params *PingPlaybackSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Playing/Ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, params.PlaySessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportPlaybackProgressRequestWithApplicationWildcardPlusJSONBody calls the generic ReportPlaybackProgress builder with application/*+json body
func NewReportPlaybackProgressRequestWithApplicationWildcardPlusJSONBody(server string, body ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackProgressRequestWithBody(server, "application/*+json", bodyReader)
}

// NewReportPlaybackProgressRequest calls the generic ReportPlaybackProgress builder with application/json body
func NewReportPlaybackProgressRequest(server string, body ReportPlaybackProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackProgressRequestWithBody(server, "application/json", bodyReader)
}

// NewReportPlaybackProgressRequestWithBody generates requests for ReportPlaybackProgress with any type of body
func NewReportPlaybackProgressRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Playing/Progress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReportPlaybackStoppedRequestWithApplicationWildcardPlusJSONBody calls the generic ReportPlaybackStopped builder with application/*+json body
func NewReportPlaybackStoppedRequestWithApplicationWildcardPlusJSONBody(server string, body ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackStoppedRequestWithBody(server, "application/*+json", bodyReader)
}

// NewReportPlaybackStoppedRequest calls the generic ReportPlaybackStopped builder with application/json body
func NewReportPlaybackStoppedRequest(server string, body ReportPlaybackStoppedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportPlaybackStoppedRequestWithBody(server, "application/json", bodyReader)
}

// NewReportPlaybackStoppedRequestWithBody generates requests for ReportPlaybackStopped with any type of body
func NewReportPlaybackStoppedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Playing/Stopped")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReportViewingRequest generates requests for ReportViewing
func NewReportViewingRequest(server string, params *ReportViewingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/Viewing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sessionId", runtime.ParamLocationQuery, *params.SessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemId", runtime.ParamLocationQuery, params.ItemId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendFullGeneralCommandRequestWithApplicationWildcardPlusJSONBody calls the generic SendFullGeneralCommand builder with application/*+json body
func NewSendFullGeneralCommandRequestWithApplicationWildcardPlusJSONBody(server string, sessionId string, body SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendFullGeneralCommandRequestWithBody(server, sessionId, "application/*+json", bodyReader)
}

// NewSendFullGeneralCommandRequest calls the generic SendFullGeneralCommand builder with application/json body
func NewSendFullGeneralCommandRequest(server string, sessionId string, body SendFullGeneralCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendFullGeneralCommandRequestWithBody(server, sessionId, "application/json", bodyReader)
}

// NewSendFullGeneralCommandRequestWithBody generates requests for SendFullGeneralCommand with any type of body
func NewSendFullGeneralCommandRequestWithBody(server string, sessionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendGeneralCommandRequest generates requests for SendGeneralCommand
func NewSendGeneralCommandRequest(server string, sessionId string, command GeneralCommandType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "command", runtime.ParamLocationPath, command)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Command/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendMessageCommandRequestWithApplicationWildcardPlusJSONBody calls the generic SendMessageCommand builder with application/*+json body
func NewSendMessageCommandRequestWithApplicationWildcardPlusJSONBody(server string, sessionId string, body SendMessageCommandApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageCommandRequestWithBody(server, sessionId, "application/*+json", bodyReader)
}

// NewSendMessageCommandRequest calls the generic SendMessageCommand builder with application/json body
func NewSendMessageCommandRequest(server string, sessionId string, body SendMessageCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendMessageCommandRequestWithBody(server, sessionId, "application/json", bodyReader)
}

// NewSendMessageCommandRequestWithBody generates requests for SendMessageCommand with any type of body
func NewSendMessageCommandRequestWithBody(server string, sessionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Message", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPlayRequest generates requests for Play
func NewPlayRequest(server string, sessionId string, params *PlayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Playing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playCommand", runtime.ParamLocationQuery, params.PlayCommand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemIds", runtime.ParamLocationQuery, params.ItemIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startPositionTicks", runtime.ParamLocationQuery, *params.StartPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendPlaystateCommandRequest generates requests for SendPlaystateCommand
func NewSendPlaystateCommandRequest(server string, sessionId string, command PlaystateCommand, params *SendPlaystateCommandParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "command", runtime.ParamLocationPath, command)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Playing/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SeekPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seekPositionTicks", runtime.ParamLocationQuery, *params.SeekPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ControllingUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "controllingUserId", runtime.ParamLocationQuery, *params.ControllingUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendSystemCommandRequest generates requests for SendSystemCommand
func NewSendSystemCommandRequest(server string, sessionId string, command GeneralCommandType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "command", runtime.ParamLocationPath, command)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/System/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserFromSessionRequest generates requests for RemoveUserFromSession
func NewRemoveUserFromSessionRequest(server string, sessionId string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/User/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToSessionRequest generates requests for AddUserToSession
func NewAddUserToSessionRequest(server string, sessionId string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/User/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisplayContentRequest generates requests for DisplayContent
func NewDisplayContentRequest(server string, sessionId string, params *DisplayContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, sessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Sessions/%s/Viewing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemType", runtime.ParamLocationQuery, params.ItemType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemId", runtime.ParamLocationQuery, params.ItemId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemName", runtime.ParamLocationQuery, params.ItemName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNextUpRequest generates requests for GetNextUp
func NewGetNextUpRequest(server string, params *GetNextUpParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Shows/NextUp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesId", runtime.ParamLocationQuery, *params.SeriesId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextUpDateCutoff != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextUpDateCutoff", runtime.ParamLocationQuery, *params.NextUpDateCutoff); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableFirstEpisode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disableFirstEpisode", runtime.ParamLocationQuery, *params.DisableFirstEpisode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableRewatching != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableRewatching", runtime.ParamLocationQuery, *params.EnableRewatching); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpcomingEpisodesRequest generates requests for GetUpcomingEpisodes
func NewGetUpcomingEpisodesRequest(server string, params *GetUpcomingEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Shows/Upcoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarShowsRequest generates requests for GetSimilarShows
func NewGetSimilarShowsRequest(server string, itemId openapi_types.UUID, params *GetSimilarShowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Shows/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodesRequest generates requests for GetEpisodes
func NewGetEpisodesRequest(server string, seriesId openapi_types.UUID, params *GetEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Shows/%s/Episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Season != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "season", runtime.ParamLocationQuery, *params.Season); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeasonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seasonId", runtime.ParamLocationQuery, *params.SeasonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startItemId", runtime.ParamLocationQuery, *params.StartItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonsRequest generates requests for GetSeasons
func NewGetSeasonsRequest(server string, seriesId openapi_types.UUID, params *GetSeasonsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seriesId", runtime.ParamLocationPath, seriesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Shows/%s/Seasons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSpecialSeason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSpecialSeason", runtime.ParamLocationQuery, *params.IsSpecialSeason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstantMixFromSongRequest generates requests for GetInstantMixFromSong
func NewGetInstantMixFromSongRequest(server string, id openapi_types.UUID, params *GetInstantMixFromSongParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Songs/%s/InstantMix", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteWizardRequest generates requests for CompleteWizard
func NewCompleteWizardRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/Complete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStartupConfigurationRequest generates requests for GetStartupConfiguration
func NewGetStartupConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/Configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInitialConfigurationRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateInitialConfiguration builder with application/*+json body
func NewUpdateInitialConfigurationRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInitialConfigurationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateInitialConfigurationRequest calls the generic UpdateInitialConfiguration builder with application/json body
func NewUpdateInitialConfigurationRequest(server string, body UpdateInitialConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInitialConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateInitialConfigurationRequestWithBody generates requests for UpdateInitialConfiguration with any type of body
func NewUpdateInitialConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/Configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFirstUser2Request generates requests for GetFirstUser2
func NewGetFirstUser2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/FirstUser")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRemoteAccessRequestWithApplicationWildcardPlusJSONBody calls the generic SetRemoteAccess builder with application/*+json body
func NewSetRemoteAccessRequestWithApplicationWildcardPlusJSONBody(server string, body SetRemoteAccessApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRemoteAccessRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSetRemoteAccessRequest calls the generic SetRemoteAccess builder with application/json body
func NewSetRemoteAccessRequest(server string, body SetRemoteAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRemoteAccessRequestWithBody(server, "application/json", bodyReader)
}

// NewSetRemoteAccessRequestWithBody generates requests for SetRemoteAccess with any type of body
func NewSetRemoteAccessRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/RemoteAccess")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFirstUserRequest generates requests for GetFirstUser
func NewGetFirstUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/User")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStartupUserRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateStartupUser builder with application/*+json body
func NewUpdateStartupUserRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateStartupUserApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStartupUserRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateStartupUserRequest calls the generic UpdateStartupUser builder with application/json body
func NewUpdateStartupUserRequest(server string, body UpdateStartupUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStartupUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateStartupUserRequestWithBody generates requests for UpdateStartupUser with any type of body
func NewUpdateStartupUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Startup/User")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStudiosRequest generates requests for GetStudios
func NewGetStudiosRequest(server string, params *GetStudiosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStudioRequest generates requests for GetStudio
func NewGetStudioRequest(server string, name string, params *GetStudioParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStudioImageRequest generates requests for GetStudioImage
func NewGetStudioImageRequest(server string, name string, imageType ImageType, params *GetStudioImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadStudioImageRequest generates requests for HeadStudioImage
func NewHeadStudioImageRequest(server string, name string, imageType ImageType, params *HeadStudioImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStudioImageByIndexRequest generates requests for GetStudioImageByIndex
func NewGetStudioImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *GetStudioImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadStudioImageByIndexRequest generates requests for HeadStudioImageByIndex
func NewHeadStudioImageByIndexRequest(server string, name string, imageType ImageType, imageIndex int32, params *HeadStudioImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Studios/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncPlayBufferingRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayBuffering builder with application/*+json body
func NewSyncPlayBufferingRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayBufferingApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayBufferingRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayBufferingRequest calls the generic SyncPlayBuffering builder with application/json body
func NewSyncPlayBufferingRequest(server string, body SyncPlayBufferingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayBufferingRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayBufferingRequestWithBody generates requests for SyncPlayBuffering with any type of body
func NewSyncPlayBufferingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Buffering")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayJoinGroupRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayJoinGroup builder with application/*+json body
func NewSyncPlayJoinGroupRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayJoinGroupRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayJoinGroupRequest calls the generic SyncPlayJoinGroup builder with application/json body
func NewSyncPlayJoinGroupRequest(server string, body SyncPlayJoinGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayJoinGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayJoinGroupRequestWithBody generates requests for SyncPlayJoinGroup with any type of body
func NewSyncPlayJoinGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Join")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayLeaveGroupRequest generates requests for SyncPlayLeaveGroup
func NewSyncPlayLeaveGroupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Leave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncPlayGetGroupsRequest generates requests for SyncPlayGetGroups
func NewSyncPlayGetGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/List")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncPlayMovePlaylistItemRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayMovePlaylistItem builder with application/*+json body
func NewSyncPlayMovePlaylistItemRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayMovePlaylistItemRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayMovePlaylistItemRequest calls the generic SyncPlayMovePlaylistItem builder with application/json body
func NewSyncPlayMovePlaylistItemRequest(server string, body SyncPlayMovePlaylistItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayMovePlaylistItemRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayMovePlaylistItemRequestWithBody generates requests for SyncPlayMovePlaylistItem with any type of body
func NewSyncPlayMovePlaylistItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/MovePlaylistItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayCreateGroupRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayCreateGroup builder with application/*+json body
func NewSyncPlayCreateGroupRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayCreateGroupRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayCreateGroupRequest calls the generic SyncPlayCreateGroup builder with application/json body
func NewSyncPlayCreateGroupRequest(server string, body SyncPlayCreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayCreateGroupRequestWithBody generates requests for SyncPlayCreateGroup with any type of body
func NewSyncPlayCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/New")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayNextItemRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayNextItem builder with application/*+json body
func NewSyncPlayNextItemRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayNextItemApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayNextItemRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayNextItemRequest calls the generic SyncPlayNextItem builder with application/json body
func NewSyncPlayNextItemRequest(server string, body SyncPlayNextItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayNextItemRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayNextItemRequestWithBody generates requests for SyncPlayNextItem with any type of body
func NewSyncPlayNextItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/NextItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayPauseRequest generates requests for SyncPlayPause
func NewSyncPlayPauseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Pause")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncPlayPingRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayPing builder with application/*+json body
func NewSyncPlayPingRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayPingApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayPingRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayPingRequest calls the generic SyncPlayPing builder with application/json body
func NewSyncPlayPingRequest(server string, body SyncPlayPingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayPingRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayPingRequestWithBody generates requests for SyncPlayPing with any type of body
func NewSyncPlayPingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayPreviousItemRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayPreviousItem builder with application/*+json body
func NewSyncPlayPreviousItemRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayPreviousItemRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayPreviousItemRequest calls the generic SyncPlayPreviousItem builder with application/json body
func NewSyncPlayPreviousItemRequest(server string, body SyncPlayPreviousItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayPreviousItemRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayPreviousItemRequestWithBody generates requests for SyncPlayPreviousItem with any type of body
func NewSyncPlayPreviousItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/PreviousItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayQueueRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayQueue builder with application/*+json body
func NewSyncPlayQueueRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayQueueApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayQueueRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayQueueRequest calls the generic SyncPlayQueue builder with application/json body
func NewSyncPlayQueueRequest(server string, body SyncPlayQueueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayQueueRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayQueueRequestWithBody generates requests for SyncPlayQueue with any type of body
func NewSyncPlayQueueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Queue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayReadyRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayReady builder with application/*+json body
func NewSyncPlayReadyRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayReadyApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayReadyRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayReadyRequest calls the generic SyncPlayReady builder with application/json body
func NewSyncPlayReadyRequest(server string, body SyncPlayReadyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayReadyRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayReadyRequestWithBody generates requests for SyncPlayReady with any type of body
func NewSyncPlayReadyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayRemoveFromPlaylistRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlayRemoveFromPlaylist builder with application/*+json body
func NewSyncPlayRemoveFromPlaylistRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayRemoveFromPlaylistRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlayRemoveFromPlaylistRequest calls the generic SyncPlayRemoveFromPlaylist builder with application/json body
func NewSyncPlayRemoveFromPlaylistRequest(server string, body SyncPlayRemoveFromPlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlayRemoveFromPlaylistRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlayRemoveFromPlaylistRequestWithBody generates requests for SyncPlayRemoveFromPlaylist with any type of body
func NewSyncPlayRemoveFromPlaylistRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/RemoveFromPlaylist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySeekRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySeek builder with application/*+json body
func NewSyncPlaySeekRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySeekApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySeekRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySeekRequest calls the generic SyncPlaySeek builder with application/json body
func NewSyncPlaySeekRequest(server string, body SyncPlaySeekJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySeekRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySeekRequestWithBody generates requests for SyncPlaySeek with any type of body
func NewSyncPlaySeekRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Seek")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySetIgnoreWaitRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySetIgnoreWait builder with application/*+json body
func NewSyncPlaySetIgnoreWaitRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetIgnoreWaitRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySetIgnoreWaitRequest calls the generic SyncPlaySetIgnoreWait builder with application/json body
func NewSyncPlaySetIgnoreWaitRequest(server string, body SyncPlaySetIgnoreWaitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetIgnoreWaitRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySetIgnoreWaitRequestWithBody generates requests for SyncPlaySetIgnoreWait with any type of body
func NewSyncPlaySetIgnoreWaitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/SetIgnoreWait")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySetNewQueueRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySetNewQueue builder with application/*+json body
func NewSyncPlaySetNewQueueRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetNewQueueRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySetNewQueueRequest calls the generic SyncPlaySetNewQueue builder with application/json body
func NewSyncPlaySetNewQueueRequest(server string, body SyncPlaySetNewQueueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetNewQueueRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySetNewQueueRequestWithBody generates requests for SyncPlaySetNewQueue with any type of body
func NewSyncPlaySetNewQueueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/SetNewQueue")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySetPlaylistItemRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySetPlaylistItem builder with application/*+json body
func NewSyncPlaySetPlaylistItemRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetPlaylistItemRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySetPlaylistItemRequest calls the generic SyncPlaySetPlaylistItem builder with application/json body
func NewSyncPlaySetPlaylistItemRequest(server string, body SyncPlaySetPlaylistItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetPlaylistItemRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySetPlaylistItemRequestWithBody generates requests for SyncPlaySetPlaylistItem with any type of body
func NewSyncPlaySetPlaylistItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/SetPlaylistItem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySetRepeatModeRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySetRepeatMode builder with application/*+json body
func NewSyncPlaySetRepeatModeRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetRepeatModeRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySetRepeatModeRequest calls the generic SyncPlaySetRepeatMode builder with application/json body
func NewSyncPlaySetRepeatModeRequest(server string, body SyncPlaySetRepeatModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetRepeatModeRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySetRepeatModeRequestWithBody generates requests for SyncPlaySetRepeatMode with any type of body
func NewSyncPlaySetRepeatModeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/SetRepeatMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlaySetShuffleModeRequestWithApplicationWildcardPlusJSONBody calls the generic SyncPlaySetShuffleMode builder with application/*+json body
func NewSyncPlaySetShuffleModeRequestWithApplicationWildcardPlusJSONBody(server string, body SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetShuffleModeRequestWithBody(server, "application/*+json", bodyReader)
}

// NewSyncPlaySetShuffleModeRequest calls the generic SyncPlaySetShuffleMode builder with application/json body
func NewSyncPlaySetShuffleModeRequest(server string, body SyncPlaySetShuffleModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncPlaySetShuffleModeRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncPlaySetShuffleModeRequestWithBody generates requests for SyncPlaySetShuffleMode with any type of body
func NewSyncPlaySetShuffleModeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/SetShuffleMode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncPlayStopRequest generates requests for SyncPlayStop
func NewSyncPlayStopRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncPlayUnpauseRequest generates requests for SyncPlayUnpause
func NewSyncPlayUnpauseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/SyncPlay/Unpause")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogEntriesRequest generates requests for GetLogEntries
func NewGetLogEntriesRequest(server string, params *GetLogEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/ActivityLog/Entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDate", runtime.ParamLocationQuery, *params.MinDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasUserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasUserId", runtime.ParamLocationQuery, *params.HasUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationRequest generates requests for GetConfiguration
func NewGetConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigurationRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateConfiguration builder with application/*+json body
func NewUpdateConfigurationRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateConfigurationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigurationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateConfigurationRequest calls the generic UpdateConfiguration builder with application/json body
func NewUpdateConfigurationRequest(server string, body UpdateConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConfigurationRequestWithBody generates requests for UpdateConfiguration with any type of body
func NewUpdateConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultMetadataOptionsRequest generates requests for GetDefaultMetadataOptions
func NewGetDefaultMetadataOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Configuration/MetadataOptions/Default")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNamedConfigurationRequest generates requests for GetNamedConfiguration
func NewGetNamedConfigurationRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNamedConfigurationRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateNamedConfiguration builder with application/*+json body
func NewUpdateNamedConfigurationRequestWithApplicationWildcardPlusJSONBody(server string, key string, body UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNamedConfigurationRequestWithBody(server, key, "application/*+json", bodyReader)
}

// NewUpdateNamedConfigurationRequest calls the generic UpdateNamedConfiguration builder with application/json body
func NewUpdateNamedConfigurationRequest(server string, key string, body UpdateNamedConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNamedConfigurationRequestWithBody(server, key, "application/json", bodyReader)
}

// NewUpdateNamedConfigurationRequestWithBody generates requests for UpdateNamedConfiguration with any type of body
func NewUpdateNamedConfigurationRequestWithBody(server string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEndpointInfoRequest generates requests for GetEndpointInfo
func NewGetEndpointInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Endpoint")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemInfoRequest generates requests for GetSystemInfo
func NewGetSystemInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicSystemInfoRequest generates requests for GetPublicSystemInfo
func NewGetPublicSystemInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Info/Public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerLogsRequest generates requests for GetServerLogs
func NewGetServerLogsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogFileRequest generates requests for GetLogFile
func NewGetLogFileRequest(server string, params *GetLogFileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Logs/Log")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMediaEncoderPathRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateMediaEncoderPath builder with application/*+json body
func NewUpdateMediaEncoderPathRequestWithApplicationWildcardPlusJSONBody(server string, body UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMediaEncoderPathRequestWithBody(server, "application/*+json", bodyReader)
}

// NewUpdateMediaEncoderPathRequest calls the generic UpdateMediaEncoderPath builder with application/json body
func NewUpdateMediaEncoderPathRequest(server string, body UpdateMediaEncoderPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMediaEncoderPathRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateMediaEncoderPathRequestWithBody generates requests for UpdateMediaEncoderPath with any type of body
func NewUpdateMediaEncoderPathRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/MediaEncoder/Path")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPingSystemRequest generates requests for GetPingSystem
func NewGetPingSystemRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPingSystemRequest generates requests for PostPingSystem
func NewPostPingSystemRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartApplicationRequest generates requests for RestartApplication
func NewRestartApplicationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Restart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShutdownApplicationRequest generates requests for ShutdownApplication
func NewShutdownApplicationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/Shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWakeOnLanInfoRequest generates requests for GetWakeOnLanInfo
func NewGetWakeOnLanInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/System/WakeOnLanInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTmdbClientConfigurationRequest generates requests for TmdbClientConfiguration
func NewTmdbClientConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Tmdb/ClientConfiguration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTrailersRequest generates requests for GetTrailers
func NewGetTrailersRequest(server string, params *GetTrailersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Trailers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxOfficialRating", runtime.ParamLocationQuery, *params.MaxOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeSong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeSong", runtime.ParamLocationQuery, *params.HasThemeSong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeVideo", runtime.ParamLocationQuery, *params.HasThemeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSubtitles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSubtitles", runtime.ParamLocationQuery, *params.HasSubtitles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSpecialFeature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSpecialFeature", runtime.ParamLocationQuery, *params.HasSpecialFeature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTrailer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTrailer", runtime.ParamLocationQuery, *params.HasTrailer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentIndexNumber", runtime.ParamLocationQuery, *params.ParentIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasParentalRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasParentalRating", runtime.ParamLocationQuery, *params.HasParentalRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHd", runtime.ParamLocationQuery, *params.IsHd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is4K != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is4K", runtime.ParamLocationQuery, *params.Is4K); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationTypes", runtime.ParamLocationQuery, *params.LocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeLocationTypes", runtime.ParamLocationQuery, *params.ExcludeLocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsUnaired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isUnaired", runtime.ParamLocationQuery, *params.IsUnaired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCriticRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCriticRating", runtime.ParamLocationQuery, *params.MinCriticRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPremiereDate", runtime.ParamLocationQuery, *params.MinPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSaved", runtime.ParamLocationQuery, *params.MinDateLastSaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSavedForUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSavedForUser", runtime.ParamLocationQuery, *params.MinDateLastSavedForUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPremiereDate", runtime.ParamLocationQuery, *params.MaxPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOverview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOverview", runtime.ParamLocationQuery, *params.HasOverview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasImdbId", runtime.ParamLocationQuery, *params.HasImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTmdbId", runtime.ParamLocationQuery, *params.HasTmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTvdbId", runtime.ParamLocationQuery, *params.HasTvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemIds", runtime.ParamLocationQuery, *params.ExcludeItemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypes", runtime.ParamLocationQuery, *params.ImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artistIds", runtime.ParamLocationQuery, *params.ArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumArtistIds", runtime.ParamLocationQuery, *params.AlbumArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContributingArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contributingArtistIds", runtime.ParamLocationQuery, *params.ContributingArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Albums != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albums", runtime.ParamLocationQuery, *params.Albums); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumIds", runtime.ParamLocationQuery, *params.AlbumIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoTypes", runtime.ParamLocationQuery, *params.VideoTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOfficialRating", runtime.ParamLocationQuery, *params.MinOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlaceHolder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlaceHolder", runtime.ParamLocationQuery, *params.IsPlaceHolder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOfficialRating", runtime.ParamLocationQuery, *params.HasOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapseBoxSetItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapseBoxSetItems", runtime.ParamLocationQuery, *params.CollapseBoxSetItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minWidth", runtime.ParamLocationQuery, *params.MinWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHeight", runtime.ParamLocationQuery, *params.MinHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is3D != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is3D", runtime.ParamLocationQuery, *params.Is3D); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesStatus", runtime.ParamLocationQuery, *params.SeriesStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSimilarTrailersRequest generates requests for GetSimilarTrailers
func NewGetSimilarTrailersRequest(server string, itemId openapi_types.UUID, params *GetSimilarTrailersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Trailers/%s/Similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHidden", runtime.ParamLocationQuery, *params.IsHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDisabled", runtime.ParamLocationQuery, *params.IsDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticateUserByNameRequestWithApplicationWildcardPlusJSONBody calls the generic AuthenticateUserByName builder with application/*+json body
func NewAuthenticateUserByNameRequestWithApplicationWildcardPlusJSONBody(server string, body AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateUserByNameRequestWithBody(server, "application/*+json", bodyReader)
}

// NewAuthenticateUserByNameRequest calls the generic AuthenticateUserByName builder with application/json body
func NewAuthenticateUserByNameRequest(server string, body AuthenticateUserByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateUserByNameRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateUserByNameRequestWithBody generates requests for AuthenticateUserByName with any type of body
func NewAuthenticateUserByNameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/AuthenticateByName")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticateWithQuickConnectRequestWithApplicationWildcardPlusJSONBody calls the generic AuthenticateWithQuickConnect builder with application/*+json body
func NewAuthenticateWithQuickConnectRequestWithApplicationWildcardPlusJSONBody(server string, body AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateWithQuickConnectRequestWithBody(server, "application/*+json", bodyReader)
}

// NewAuthenticateWithQuickConnectRequest calls the generic AuthenticateWithQuickConnect builder with application/json body
func NewAuthenticateWithQuickConnectRequest(server string, body AuthenticateWithQuickConnectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateWithQuickConnectRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateWithQuickConnectRequestWithBody generates requests for AuthenticateWithQuickConnect with any type of body
func NewAuthenticateWithQuickConnectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/AuthenticateWithQuickConnect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewForgotPasswordRequestWithApplicationWildcardPlusJSONBody calls the generic ForgotPassword builder with application/*+json body
func NewForgotPasswordRequestWithApplicationWildcardPlusJSONBody(server string, body ForgotPasswordApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForgotPasswordRequestWithBody(server, "application/*+json", bodyReader)
}

// NewForgotPasswordRequest calls the generic ForgotPassword builder with application/json body
func NewForgotPasswordRequest(server string, body ForgotPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForgotPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewForgotPasswordRequestWithBody generates requests for ForgotPassword with any type of body
func NewForgotPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/ForgotPassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewForgotPasswordPinRequestWithApplicationWildcardPlusJSONBody calls the generic ForgotPasswordPin builder with application/*+json body
func NewForgotPasswordPinRequestWithApplicationWildcardPlusJSONBody(server string, body ForgotPasswordPinApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForgotPasswordPinRequestWithBody(server, "application/*+json", bodyReader)
}

// NewForgotPasswordPinRequest calls the generic ForgotPasswordPin builder with application/json body
func NewForgotPasswordPinRequest(server string, body ForgotPasswordPinJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForgotPasswordPinRequestWithBody(server, "application/json", bodyReader)
}

// NewForgotPasswordPinRequestWithBody generates requests for ForgotPasswordPin with any type of body
func NewForgotPasswordPinRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/ForgotPassword/Pin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/Me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserByNameRequestWithApplicationWildcardPlusJSONBody calls the generic CreateUserByName builder with application/*+json body
func NewCreateUserByNameRequestWithApplicationWildcardPlusJSONBody(server string, body CreateUserByNameApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserByNameRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateUserByNameRequest calls the generic CreateUserByName builder with application/json body
func NewCreateUserByNameRequest(server string, body CreateUserByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserByNameRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserByNameRequestWithBody generates requests for CreateUserByName with any type of body
func NewCreateUserByNameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/New")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublicUsersRequest generates requests for GetPublicUsers
func NewGetPublicUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/Public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserByIdRequest generates requests for GetUserById
func NewGetUserByIdRequest(server string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateUser builder with application/*+json body
func NewUpdateUserRequestWithApplicationWildcardPlusJSONBody(server string, userId openapi_types.UUID, body UpdateUserApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/*+json", bodyReader)
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId openapi_types.UUID, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthenticateUserRequest generates requests for AuthenticateUser
func NewAuthenticateUserRequest(server string, userId openapi_types.UUID, params *AuthenticateUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Authenticate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pw", runtime.ParamLocationQuery, params.Pw); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserConfigurationRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateUserConfiguration builder with application/*+json body
func NewUpdateUserConfigurationRequestWithApplicationWildcardPlusJSONBody(server string, userId openapi_types.UUID, body UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserConfigurationRequestWithBody(server, userId, "application/*+json", bodyReader)
}

// NewUpdateUserConfigurationRequest calls the generic UpdateUserConfiguration builder with application/json body
func NewUpdateUserConfigurationRequest(server string, userId openapi_types.UUID, body UpdateUserConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserConfigurationRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserConfigurationRequestWithBody generates requests for UpdateUserConfiguration with any type of body
func NewUpdateUserConfigurationRequestWithBody(server string, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Configuration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserEasyPasswordRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateUserEasyPassword builder with application/*+json body
func NewUpdateUserEasyPasswordRequestWithApplicationWildcardPlusJSONBody(server string, userId openapi_types.UUID, body UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserEasyPasswordRequestWithBody(server, userId, "application/*+json", bodyReader)
}

// NewUpdateUserEasyPasswordRequest calls the generic UpdateUserEasyPassword builder with application/json body
func NewUpdateUserEasyPasswordRequest(server string, userId openapi_types.UUID, body UpdateUserEasyPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserEasyPasswordRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserEasyPasswordRequestWithBody generates requests for UpdateUserEasyPassword with any type of body
func NewUpdateUserEasyPasswordRequestWithBody(server string, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/EasyPassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnmarkFavoriteItemRequest generates requests for UnmarkFavoriteItem
func NewUnmarkFavoriteItemRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/FavoriteItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkFavoriteItemRequest generates requests for MarkFavoriteItem
func NewMarkFavoriteItemRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/FavoriteItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupingOptionsRequest generates requests for GetGroupingOptions
func NewGetGroupingOptionsRequest(server string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/GroupingOptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserImageRequest generates requests for DeleteUserImage
func NewDeleteUserImageRequest(server string, userId openapi_types.UUID, imageType ImageType, params *DeleteUserImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserImageRequest generates requests for GetUserImage
func NewGetUserImageRequest(server string, userId openapi_types.UUID, imageType ImageType, params *GetUserImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadUserImageRequest generates requests for HeadUserImage
func NewHeadUserImageRequest(server string, userId openapi_types.UUID, imageType ImageType, params *HeadUserImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageIndex", runtime.ParamLocationQuery, *params.ImageIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserImageRequestWithBody generates requests for PostUserImage with any type of body
func NewPostUserImageRequestWithBody(server string, userId openapi_types.UUID, imageType ImageType, params *PostUserImageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserImageByIndexRequest generates requests for GetUserImageByIndex
func NewGetUserImageByIndexRequest(server string, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetUserImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadUserImageByIndexRequest generates requests for HeadUserImageByIndex
func NewHeadUserImageByIndexRequest(server string, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadUserImageByIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "imageIndex", runtime.ParamLocationPath, imageIndex)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PercentPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentPlayed", runtime.ParamLocationQuery, *params.PercentPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnplayedCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unplayedCount", runtime.ParamLocationQuery, *params.UnplayedCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quality", runtime.ParamLocationQuery, *params.Quality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillWidth", runtime.ParamLocationQuery, *params.FillWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FillHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fillHeight", runtime.ParamLocationQuery, *params.FillHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CropWhitespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cropWhitespace", runtime.ParamLocationQuery, *params.CropWhitespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddPlayedIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addPlayedIndicator", runtime.ParamLocationQuery, *params.AddPlayedIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Blur != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blur", runtime.ParamLocationQuery, *params.Blur); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackgroundColor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backgroundColor", runtime.ParamLocationQuery, *params.BackgroundColor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForegroundLayer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "foregroundLayer", runtime.ParamLocationQuery, *params.ForegroundLayer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserImageByIndexRequest generates requests for DeleteUserImageByIndex
func NewDeleteUserImageByIndexRequest(server string, userId openapi_types.UUID, imageType ImageType, index int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserImageByIndexRequestWithBody generates requests for PostUserImageByIndex with any type of body
func NewPostUserImageByIndexRequestWithBody(server string, userId openapi_types.UUID, imageType ImageType, index int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "imageType", runtime.ParamLocationPath, imageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Images/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetItemsByUserIdRequest generates requests for GetItemsByUserId
func NewGetItemsByUserIdRequest(server string, userId openapi_types.UUID, params *GetItemsByUserIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxOfficialRating", runtime.ParamLocationQuery, *params.MaxOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeSong != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeSong", runtime.ParamLocationQuery, *params.HasThemeSong); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasThemeVideo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasThemeVideo", runtime.ParamLocationQuery, *params.HasThemeVideo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSubtitles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSubtitles", runtime.ParamLocationQuery, *params.HasSubtitles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasSpecialFeature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasSpecialFeature", runtime.ParamLocationQuery, *params.HasSpecialFeature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTrailer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTrailer", runtime.ParamLocationQuery, *params.HasTrailer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdjacentTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adjacentTo", runtime.ParamLocationQuery, *params.AdjacentTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentIndexNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentIndexNumber", runtime.ParamLocationQuery, *params.ParentIndexNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasParentalRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasParentalRating", runtime.ParamLocationQuery, *params.HasParentalRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHd", runtime.ParamLocationQuery, *params.IsHd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is4K != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is4K", runtime.ParamLocationQuery, *params.Is4K); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationTypes", runtime.ParamLocationQuery, *params.LocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeLocationTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeLocationTypes", runtime.ParamLocationQuery, *params.ExcludeLocationTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMissing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMissing", runtime.ParamLocationQuery, *params.IsMissing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsUnaired != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isUnaired", runtime.ParamLocationQuery, *params.IsUnaired); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCommunityRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCommunityRating", runtime.ParamLocationQuery, *params.MinCommunityRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCriticRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCriticRating", runtime.ParamLocationQuery, *params.MinCriticRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minPremiereDate", runtime.ParamLocationQuery, *params.MinPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSaved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSaved", runtime.ParamLocationQuery, *params.MinDateLastSaved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinDateLastSavedForUser != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minDateLastSavedForUser", runtime.ParamLocationQuery, *params.MinDateLastSavedForUser); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPremiereDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxPremiereDate", runtime.ParamLocationQuery, *params.MaxPremiereDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOverview != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOverview", runtime.ParamLocationQuery, *params.HasOverview); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasImdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasImdbId", runtime.ParamLocationQuery, *params.HasImdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTmdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTmdbId", runtime.ParamLocationQuery, *params.HasTmdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasTvdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasTvdbId", runtime.ParamLocationQuery, *params.HasTvdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMovie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMovie", runtime.ParamLocationQuery, *params.IsMovie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSeries != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSeries", runtime.ParamLocationQuery, *params.IsSeries); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsNews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isNews", runtime.ParamLocationQuery, *params.IsNews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsKids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isKids", runtime.ParamLocationQuery, *params.IsKids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsSports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isSports", runtime.ParamLocationQuery, *params.IsSports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemIds", runtime.ParamLocationQuery, *params.ExcludeItemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFavorite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFavorite", runtime.ParamLocationQuery, *params.IsFavorite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypes", runtime.ParamLocationQuery, *params.ImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OfficialRatings != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "officialRatings", runtime.ParamLocationQuery, *params.OfficialRatings); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Years != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "years", runtime.ParamLocationQuery, *params.Years); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Person != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person", runtime.ParamLocationQuery, *params.Person); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personIds", runtime.ParamLocationQuery, *params.PersonIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "personTypes", runtime.ParamLocationQuery, *params.PersonTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Studios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studios", runtime.ParamLocationQuery, *params.Studios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeArtistIds", runtime.ParamLocationQuery, *params.ExcludeArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artistIds", runtime.ParamLocationQuery, *params.ArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumArtistIds", runtime.ParamLocationQuery, *params.AlbumArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContributingArtistIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contributingArtistIds", runtime.ParamLocationQuery, *params.ContributingArtistIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Albums != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albums", runtime.ParamLocationQuery, *params.Albums); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AlbumIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "albumIds", runtime.ParamLocationQuery, *params.AlbumIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoTypes", runtime.ParamLocationQuery, *params.VideoTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minOfficialRating", runtime.ParamLocationQuery, *params.MinOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLocked != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLocked", runtime.ParamLocationQuery, *params.IsLocked); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlaceHolder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlaceHolder", runtime.ParamLocationQuery, *params.IsPlaceHolder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOfficialRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOfficialRating", runtime.ParamLocationQuery, *params.HasOfficialRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollapseBoxSetItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collapseBoxSetItems", runtime.ParamLocationQuery, *params.CollapseBoxSetItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minWidth", runtime.ParamLocationQuery, *params.MinWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minHeight", runtime.ParamLocationQuery, *params.MinHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Is3D != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is3D", runtime.ParamLocationQuery, *params.Is3D); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeriesStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "seriesStatus", runtime.ParamLocationQuery, *params.SeriesStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWithOrGreater != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWithOrGreater", runtime.ParamLocationQuery, *params.NameStartsWithOrGreater); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameStartsWith != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameStartsWith", runtime.ParamLocationQuery, *params.NameStartsWith); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameLessThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameLessThan", runtime.ParamLocationQuery, *params.NameLessThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StudioIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "studioIds", runtime.ParamLocationQuery, *params.StudioIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenreIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genreIds", runtime.ParamLocationQuery, *params.GenreIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestMediaRequest generates requests for GetLatestMedia
func NewGetLatestMediaRequest(server string, userId openapi_types.UUID, params *GetLatestMediaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/Latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPlayed", runtime.ParamLocationQuery, *params.IsPlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupItems != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupItems", runtime.ParamLocationQuery, *params.GroupItems); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResumeItemsRequest generates requests for GetResumeItems
func NewGetResumeItemsRequest(server string, userId openapi_types.UUID, params *GetResumeItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/Resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "searchTerm", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeActiveSessions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeActiveSessions", runtime.ParamLocationQuery, *params.ExcludeActiveSessions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRootFolderRequest generates requests for GetRootFolder
func NewGetRootFolderRequest(server string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/Root", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemRequest generates requests for GetItem
func NewGetItemRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntrosRequest generates requests for GetIntros
func NewGetIntrosRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s/Intros", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalTrailersRequest generates requests for GetLocalTrailers
func NewGetLocalTrailersRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s/LocalTrailers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserItemRatingRequest generates requests for DeleteUserItemRating
func NewDeleteUserItemRatingRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s/Rating", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserItemRatingRequest generates requests for UpdateUserItemRating
func NewUpdateUserItemRatingRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID, params *UpdateUserItemRatingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s/Rating", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Likes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "likes", runtime.ParamLocationQuery, *params.Likes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpecialFeaturesRequest generates requests for GetSpecialFeatures
func NewGetSpecialFeaturesRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Items/%s/SpecialFeatures", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserPasswordRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateUserPassword builder with application/*+json body
func NewUpdateUserPasswordRequestWithApplicationWildcardPlusJSONBody(server string, userId openapi_types.UUID, body UpdateUserPasswordApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, userId, "application/*+json", bodyReader)
}

// NewUpdateUserPasswordRequest calls the generic UpdateUserPassword builder with application/json body
func NewUpdateUserPasswordRequest(server string, userId openapi_types.UUID, body UpdateUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserPasswordRequestWithBody generates requests for UpdateUserPassword with any type of body
func NewUpdateUserPasswordRequestWithBody(server string, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkUnplayedItemRequest generates requests for MarkUnplayedItem
func NewMarkUnplayedItemRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/PlayedItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkPlayedItemRequest generates requests for MarkPlayedItem
func NewMarkPlayedItemRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID, params *MarkPlayedItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/PlayedItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DatePlayed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datePlayed", runtime.ParamLocationQuery, *params.DatePlayed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOnPlaybackStoppedRequest generates requests for OnPlaybackStopped
func NewOnPlaybackStoppedRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStoppedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/PlayingItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextMediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextMediaType", runtime.ParamLocationQuery, *params.NextMediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positionTicks", runtime.ParamLocationQuery, *params.PositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOnPlaybackStartRequest generates requests for OnPlaybackStart
func NewOnPlaybackStartRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/PlayingItems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playMethod", runtime.ParamLocationQuery, *params.PlayMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CanSeek != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "canSeek", runtime.ParamLocationQuery, *params.CanSeek); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOnPlaybackProgressRequest generates requests for OnPlaybackProgress
func NewOnPlaybackProgressRequest(server string, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackProgressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/PlayingItems/%s/Progress", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "positionTicks", runtime.ParamLocationQuery, *params.PositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VolumeLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volumeLevel", runtime.ParamLocationQuery, *params.VolumeLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlayMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playMethod", runtime.ParamLocationQuery, *params.PlayMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RepeatMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repeatMode", runtime.ParamLocationQuery, *params.RepeatMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsPaused != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isPaused", runtime.ParamLocationQuery, *params.IsPaused); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsMuted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isMuted", runtime.ParamLocationQuery, *params.IsMuted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserPolicyRequestWithApplicationWildcardPlusJSONBody calls the generic UpdateUserPolicy builder with application/*+json body
func NewUpdateUserPolicyRequestWithApplicationWildcardPlusJSONBody(server string, userId openapi_types.UUID, body UpdateUserPolicyApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPolicyRequestWithBody(server, userId, "application/*+json", bodyReader)
}

// NewUpdateUserPolicyRequest calls the generic UpdateUserPolicy builder with application/json body
func NewUpdateUserPolicyRequest(server string, userId openapi_types.UUID, body UpdateUserPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPolicyRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserPolicyRequestWithBody generates requests for UpdateUserPolicy with any type of body
func NewUpdateUserPolicyRequestWithBody(server string, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSuggestionsRequest generates requests for GetSuggestions
func NewGetSuggestionsRequest(server string, userId openapi_types.UUID, params *GetSuggestionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Suggestions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MediaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaType", runtime.ParamLocationQuery, *params.MediaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableTotalRecordCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableTotalRecordCount", runtime.ParamLocationQuery, *params.EnableTotalRecordCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserViewsRequest generates requests for GetUserViews
func NewGetUserViewsRequest(server string, userId openapi_types.UUID, params *GetUserViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Users/%s/Views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeExternalContent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeExternalContent", runtime.ParamLocationQuery, *params.IncludeExternalContent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PresetViews != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presetViews", runtime.ParamLocationQuery, *params.PresetViews); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopEncodingProcessRequest generates requests for StopEncodingProcess
func NewStopEncodingProcessRequest(server string, params *StopEncodingProcessParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/ActiveEncodings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, params.DeviceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, params.PlaySessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeVersionsRequest generates requests for MergeVersions
func NewMergeVersionsRequest(server string, params *MergeVersionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/MergeVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAdditionalPartRequest generates requests for GetAdditionalPart
func NewGetAdditionalPartRequest(server string, itemId openapi_types.UUID, params *GetAdditionalPartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/AdditionalParts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAlternateSourcesRequest generates requests for DeleteAlternateSources
func NewDeleteAlternateSourcesRequest(server string, itemId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/AlternateSources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSubtitleRequestWithApplicationWildcardPlusJSONBody calls the generic UploadSubtitle builder with application/*+json body
func NewUploadSubtitleRequestWithApplicationWildcardPlusJSONBody(server string, itemId openapi_types.UUID, body UploadSubtitleApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadSubtitleRequestWithBody(server, itemId, "application/*+json", bodyReader)
}

// NewUploadSubtitleRequest calls the generic UploadSubtitle builder with application/json body
func NewUploadSubtitleRequest(server string, itemId openapi_types.UUID, body UploadSubtitleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadSubtitleRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUploadSubtitleRequestWithBody generates requests for UploadSubtitle with any type of body
func NewUploadSubtitleRequestWithBody(server string, itemId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/Subtitles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubtitleRequest generates requests for DeleteSubtitle
func NewDeleteSubtitleRequest(server string, itemId openapi_types.UUID, index int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/Subtitles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsPlaylistLegacyRequest generates requests for GetHlsPlaylistLegacy
func NewGetHlsPlaylistLegacyRequest(server string, itemId string, playlistId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/hls/%s/stream.m3u8", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsVideoSegmentLegacyRequest generates requests for GetHlsVideoSegmentLegacy
func NewGetHlsVideoSegmentLegacyRequest(server string, itemId string, playlistId string, segmentId string, segmentContainer string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "segmentId", runtime.ParamLocationPath, segmentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "segmentContainer", runtime.ParamLocationPath, segmentContainer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/hls/%s/%s.%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHlsVideoSegmentRequest generates requests for GetHlsVideoSegment
func NewGetHlsVideoSegmentRequest(server string, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsVideoSegmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "playlistId", runtime.ParamLocationPath, playlistId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "segmentId", runtime.ParamLocationPath, segmentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/hls1/%s/%s.%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runtimeTicks", runtime.ParamLocationQuery, params.RuntimeTicks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actualSegmentLengthTicks", runtime.ParamLocationQuery, params.ActualSegmentLengthTicks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveHlsStreamRequest generates requests for GetLiveHlsStream
func NewGetLiveHlsStreamRequest(server string, itemId openapi_types.UUID, params *GetLiveHlsStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/live.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableSubtitlesInManifest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableSubtitlesInManifest", runtime.ParamLocationQuery, *params.EnableSubtitlesInManifest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariantHlsVideoPlaylistRequest generates requests for GetVariantHlsVideoPlaylist
func NewGetVariantHlsVideoPlaylistRequest(server string, itemId openapi_types.UUID, params *GetVariantHlsVideoPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/main.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMasterHlsVideoPlaylistRequest generates requests for GetMasterHlsVideoPlaylist
func NewGetMasterHlsVideoPlaylistRequest(server string, itemId openapi_types.UUID, params *GetMasterHlsVideoPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/master.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, params.MediaSourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAdaptiveBitrateStreaming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAdaptiveBitrateStreaming", runtime.ParamLocationQuery, *params.EnableAdaptiveBitrateStreaming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadMasterHlsVideoPlaylistRequest generates requests for HeadMasterHlsVideoPlaylist
func NewHeadMasterHlsVideoPlaylistRequest(server string, itemId openapi_types.UUID, params *HeadMasterHlsVideoPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/master.m3u8", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, params.MediaSourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAdaptiveBitrateStreaming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAdaptiveBitrateStreaming", runtime.ParamLocationQuery, *params.EnableAdaptiveBitrateStreaming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideoStreamRequest generates requests for GetVideoStream
func NewGetVideoStreamRequest(server string, itemId openapi_types.UUID, params *GetVideoStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadVideoStreamRequest generates requests for HeadVideoStream
func NewHeadVideoStreamRequest(server string, itemId openapi_types.UUID, params *HeadVideoStreamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Container != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "container", runtime.ParamLocationQuery, *params.Container); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideoStreamByContainerRequest generates requests for GetVideoStreamByContainer
func NewGetVideoStreamByContainerRequest(server string, itemId openapi_types.UUID, container string, params *GetVideoStreamByContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/stream.%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHeadVideoStreamByContainerRequest generates requests for HeadVideoStreamByContainer
func NewHeadVideoStreamByContainerRequest(server string, itemId openapi_types.UUID, container string, params *HeadVideoStreamByContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "container", runtime.ParamLocationPath, container)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/stream.%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Static != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "static", runtime.ParamLocationQuery, *params.Static); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Params != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "params", runtime.ParamLocationQuery, *params.Params); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, *params.Tag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceProfileId", runtime.ParamLocationQuery, *params.DeviceProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlaySessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playSessionId", runtime.ParamLocationQuery, *params.PlaySessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentContainer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentContainer", runtime.ParamLocationQuery, *params.SegmentContainer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SegmentLength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, *params.SegmentLength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinSegments != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minSegments", runtime.ParamLocationQuery, *params.MinSegments); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeviceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deviceId", runtime.ParamLocationQuery, *params.DeviceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioCodec", runtime.ParamLocationQuery, *params.AudioCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableAutoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableAutoStreamCopy", runtime.ParamLocationQuery, *params.EnableAutoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowVideoStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowVideoStreamCopy", runtime.ParamLocationQuery, *params.AllowVideoStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowAudioStreamCopy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allowAudioStreamCopy", runtime.ParamLocationQuery, *params.AllowAudioStreamCopy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BreakOnNonKeyFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "breakOnNonKeyFrames", runtime.ParamLocationQuery, *params.BreakOnNonKeyFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioSampleRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioSampleRate", runtime.ParamLocationQuery, *params.AudioSampleRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioBitDepth", runtime.ParamLocationQuery, *params.MaxAudioBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioBitRate", runtime.ParamLocationQuery, *params.AudioBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioChannels", runtime.ParamLocationQuery, *params.AudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAudioChannels", runtime.ParamLocationQuery, *params.MaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Profile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "profile", runtime.ParamLocationQuery, *params.Profile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Framerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "framerate", runtime.ParamLocationQuery, *params.Framerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxFramerate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxFramerate", runtime.ParamLocationQuery, *params.MaxFramerate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTimeTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startTimeTicks", runtime.ParamLocationQuery, *params.StartTimeTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxWidth", runtime.ParamLocationQuery, *params.MaxWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxHeight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxHeight", runtime.ParamLocationQuery, *params.MaxHeight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoBitRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoBitRate", runtime.ParamLocationQuery, *params.VideoBitRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleStreamIndex", runtime.ParamLocationQuery, *params.SubtitleStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleMethod", runtime.ParamLocationQuery, *params.SubtitleMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxRefFrames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxRefFrames", runtime.ParamLocationQuery, *params.MaxRefFrames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxVideoBitDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxVideoBitDepth", runtime.ParamLocationQuery, *params.MaxVideoBitDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireAvc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireAvc", runtime.ParamLocationQuery, *params.RequireAvc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeInterlace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deInterlace", runtime.ParamLocationQuery, *params.DeInterlace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequireNonAnamorphic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requireNonAnamorphic", runtime.ParamLocationQuery, *params.RequireNonAnamorphic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodingMaxAudioChannels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodingMaxAudioChannels", runtime.ParamLocationQuery, *params.TranscodingMaxAudioChannels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CpuCoreLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cpuCoreLimit", runtime.ParamLocationQuery, *params.CpuCoreLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LiveStreamId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liveStreamId", runtime.ParamLocationQuery, *params.LiveStreamId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableMpegtsM2TsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableMpegtsM2TsMode", runtime.ParamLocationQuery, *params.EnableMpegtsM2TsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoCodec", runtime.ParamLocationQuery, *params.VideoCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubtitleCodec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subtitleCodec", runtime.ParamLocationQuery, *params.SubtitleCodec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranscodeReasons != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transcodeReasons", runtime.ParamLocationQuery, *params.TranscodeReasons); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AudioStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "audioStreamIndex", runtime.ParamLocationQuery, *params.AudioStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoStreamIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "videoStreamIndex", runtime.ParamLocationQuery, *params.VideoStreamIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StreamOptions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "streamOptions", runtime.ParamLocationQuery, *params.StreamOptions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubtitlePlaylistRequest generates requests for GetSubtitlePlaylist
func NewGetSubtitlePlaylistRequest(server string, itemId openapi_types.UUID, mediaSourceId string, index int32, params *GetSubtitlePlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mediaSourceId", runtime.ParamLocationPath, mediaSourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/%s/Subtitles/%s/subtitles.m3u8", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segmentLength", runtime.ParamLocationQuery, params.SegmentLength); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubtitleRequest generates requests for GetSubtitle
func NewGetSubtitleRequest(server string, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeFormat string, params *GetSubtitleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "routeItemId", runtime.ParamLocationPath, routeItemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "routeMediaSourceId", runtime.ParamLocationPath, routeMediaSourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "routeIndex", runtime.ParamLocationPath, routeIndex)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "routeFormat", runtime.ParamLocationPath, routeFormat)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/%s/Subtitles/%s/Stream.%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemId", runtime.ParamLocationQuery, *params.ItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endPositionTicks", runtime.ParamLocationQuery, *params.EndPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddVttTimeMap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addVttTimeMap", runtime.ParamLocationQuery, *params.AddVttTimeMap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startPositionTicks", runtime.ParamLocationQuery, *params.StartPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubtitleWithTicksRequest generates requests for GetSubtitleWithTicks
func NewGetSubtitleWithTicksRequest(server string, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeStartPositionTicks int64, routeFormat string, params *GetSubtitleWithTicksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "routeItemId", runtime.ParamLocationPath, routeItemId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "routeMediaSourceId", runtime.ParamLocationPath, routeMediaSourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "routeIndex", runtime.ParamLocationPath, routeIndex)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "routeStartPositionTicks", runtime.ParamLocationPath, routeStartPositionTicks)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "routeFormat", runtime.ParamLocationPath, routeFormat)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/%s/Subtitles/%s/%s/Stream.%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemId", runtime.ParamLocationQuery, *params.ItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaSourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaSourceId", runtime.ParamLocationQuery, *params.MediaSourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startPositionTicks", runtime.ParamLocationQuery, *params.StartPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndPositionTicks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endPositionTicks", runtime.ParamLocationQuery, *params.EndPositionTicks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CopyTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "copyTimestamps", runtime.ParamLocationQuery, *params.CopyTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddVttTimeMap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addVttTimeMap", runtime.ParamLocationQuery, *params.AddVttTimeMap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentRequest generates requests for GetAttachment
func NewGetAttachmentRequest(server string, videoId openapi_types.UUID, mediaSourceId string, index int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoId", runtime.ParamLocationPath, videoId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mediaSourceId", runtime.ParamLocationPath, mediaSourceId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Videos/%s/%s/Attachments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetYearsRequest generates requests for GetYears
func NewGetYearsRequest(server string, params *GetYearsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Years")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentId", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeItemTypes", runtime.ParamLocationQuery, *params.ExcludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeItemTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeItemTypes", runtime.ParamLocationQuery, *params.IncludeItemTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MediaTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaTypes", runtime.ParamLocationQuery, *params.MediaTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableUserData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableUserData", runtime.ParamLocationQuery, *params.EnableUserData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImageTypeLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imageTypeLimit", runtime.ParamLocationQuery, *params.ImageTypeLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImageTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImageTypes", runtime.ParamLocationQuery, *params.EnableImageTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnableImages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableImages", runtime.ParamLocationQuery, *params.EnableImages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetYearRequest generates requests for GetYear
func NewGetYearRequest(server string, year int32, params *GetYearParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/Years/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userId", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDurationHistogramReportRequest generates requests for GetDurationHistogramReport
func NewGetDurationHistogramReportRequest(server string, params *GetDurationHistogramReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/DurationHistogramReport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTvShowsReportRequest generates requests for GetTvShowsReport
func NewGetTvShowsReportRequest(server string, params *GetTvShowsReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/GetTvShowsReport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHourlyReportRequest generates requests for GetHourlyReport
func NewGetHourlyReportRequest(server string, params *GetHourlyReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/HourlyReport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMovieReportRequest generates requests for GetMovieReport
func NewGetMovieReportRequest(server string, params *GetMovieReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/MoviesReport")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageStatsRequest generates requests for GetUsageStats
func NewGetUsageStatsRequest(server string, params *GetUsageStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/PlayActivity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DataType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dataType", runtime.ParamLocationQuery, *params.DataType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadBackupRequest generates requests for LoadBackup
func NewLoadBackupRequest(server string, params *LoadBackupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/load_backup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BackupFilePath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backupFilePath", runtime.ParamLocationQuery, *params.BackupFilePath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveBackupRequest generates requests for SaveBackup
func NewSaveBackupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/save_backup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCustomQueryRequestWithApplicationWildcardPlusJSONBody calls the generic CustomQuery builder with application/*+json body
func NewCustomQueryRequestWithApplicationWildcardPlusJSONBody(server string, body CustomQueryApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomQueryRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCustomQueryRequest calls the generic CustomQuery builder with application/json body
func NewCustomQueryRequest(server string, body CustomQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCustomQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewCustomQueryRequestWithBody generates requests for CustomQuery with any type of body
func NewCustomQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/submit_custom_query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTypeFilterListRequest generates requests for GetTypeFilterList
func NewGetTypeFilterListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/type_filter_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserReportRequest generates requests for GetUserReport
func NewGetUserReportRequest(server string, params *GetUserReportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/user_activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJellyfinUsersRequest generates requests for GetJellyfinUsers
func NewGetJellyfinUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/user_list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIgnoreListAddRequest generates requests for IgnoreListAdd
func NewIgnoreListAddRequest(server string, params *IgnoreListAddParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/user_manage/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPruneUnknownUsersRequest generates requests for PruneUnknownUsers
func NewPruneUnknownUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/user_manage/prune")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIgnoreListRemoveRequest generates requests for IgnoreListRemove
func NewIgnoreListRemoveRequest(server string, params *IgnoreListRemoveParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/user_manage/remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBreakdownReportRequest generates requests for GetBreakdownReport
func NewGetBreakdownReportRequest(server string, breakdownType string, params *GetBreakdownReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "breakdownType", runtime.ParamLocationPath, breakdownType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/%s/BreakdownReport", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserReportDataRequest generates requests for GetUserReportData
func NewGetUserReportDataRequest(server string, userId string, date string, params *GetUserReportDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user_usage_stats/%s/%s/GetItems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimezoneOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezoneOffset", runtime.ParamLocationQuery, *params.TimezoneOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDashboardConfigurationPageRequest generates requests for GetDashboardConfigurationPage
func NewGetDashboardConfigurationPageRequest(server string, params *GetDashboardConfigurationPageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web/ConfigurationPage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationPagesRequest generates requests for GetConfigurationPages
func NewGetConfigurationPagesRequest(server string, params *GetConfigurationPagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/web/ConfigurationPages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EnableInMainMenu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enableInMainMenu", runtime.ParamLocationQuery, *params.EnableInMainMenu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetInstantMixFromAlbumWithResponse request
	GetInstantMixFromAlbumWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromAlbumParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromAlbumResponse, error)

	// GetSimilarAlbumsWithResponse request
	GetSimilarAlbumsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarAlbumsParams, reqEditors ...RequestEditorFn) (*GetSimilarAlbumsResponse, error)

	// GetArtistsWithResponse request
	GetArtistsWithResponse(ctx context.Context, params *GetArtistsParams, reqEditors ...RequestEditorFn) (*GetArtistsResponse, error)

	// GetAlbumArtistsWithResponse request
	GetAlbumArtistsWithResponse(ctx context.Context, params *GetAlbumArtistsParams, reqEditors ...RequestEditorFn) (*GetAlbumArtistsResponse, error)

	// GetInstantMixFromArtists2WithResponse request
	GetInstantMixFromArtists2WithResponse(ctx context.Context, params *GetInstantMixFromArtists2Params, reqEditors ...RequestEditorFn) (*GetInstantMixFromArtists2Response, error)

	// GetInstantMixFromArtistsWithResponse request
	GetInstantMixFromArtistsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromArtistsParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromArtistsResponse, error)

	// GetSimilarArtistsWithResponse request
	GetSimilarArtistsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarArtistsParams, reqEditors ...RequestEditorFn) (*GetSimilarArtistsResponse, error)

	// GetArtistByNameWithResponse request
	GetArtistByNameWithResponse(ctx context.Context, name string, params *GetArtistByNameParams, reqEditors ...RequestEditorFn) (*GetArtistByNameResponse, error)

	// GetArtistImageWithResponse request
	GetArtistImageWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetArtistImageParams, reqEditors ...RequestEditorFn) (*GetArtistImageResponse, error)

	// HeadArtistImageWithResponse request
	HeadArtistImageWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadArtistImageParams, reqEditors ...RequestEditorFn) (*HeadArtistImageResponse, error)

	// GetHlsAudioSegmentLegacyAacWithResponse request
	GetHlsAudioSegmentLegacyAacWithResponse(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentLegacyAacResponse, error)

	// GetHlsAudioSegmentLegacyMp3WithResponse request
	GetHlsAudioSegmentLegacyMp3WithResponse(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentLegacyMp3Response, error)

	// GetHlsAudioSegmentWithResponse request
	GetHlsAudioSegmentWithResponse(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsAudioSegmentParams, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentResponse, error)

	// GetVariantHlsAudioPlaylistWithResponse request
	GetVariantHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*GetVariantHlsAudioPlaylistResponse, error)

	// GetMasterHlsAudioPlaylistWithResponse request
	GetMasterHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*GetMasterHlsAudioPlaylistResponse, error)

	// HeadMasterHlsAudioPlaylistWithResponse request
	HeadMasterHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*HeadMasterHlsAudioPlaylistResponse, error)

	// GetAudioStreamWithResponse request
	GetAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAudioStreamParams, reqEditors ...RequestEditorFn) (*GetAudioStreamResponse, error)

	// HeadAudioStreamWithResponse request
	HeadAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadAudioStreamParams, reqEditors ...RequestEditorFn) (*HeadAudioStreamResponse, error)

	// GetAudioStreamByContainerWithResponse request
	GetAudioStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *GetAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*GetAudioStreamByContainerResponse, error)

	// HeadAudioStreamByContainerWithResponse request
	HeadAudioStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*HeadAudioStreamByContainerResponse, error)

	// GetUniversalAudioStreamWithResponse request
	GetUniversalAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*GetUniversalAudioStreamResponse, error)

	// HeadUniversalAudioStreamWithResponse request
	HeadUniversalAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*HeadUniversalAudioStreamResponse, error)

	// GetKeysWithResponse request
	GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// CreateKeyWithResponse request
	CreateKeyWithResponse(ctx context.Context, params *CreateKeyParams, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error)

	// RevokeKeyWithResponse request
	RevokeKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*RevokeKeyResponse, error)

	// GetPasswordResetProvidersWithResponse request
	GetPasswordResetProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPasswordResetProvidersResponse, error)

	// GetAuthProvidersWithResponse request
	GetAuthProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthProvidersResponse, error)

	// GetBrandingOptionsWithResponse request
	GetBrandingOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingOptionsResponse, error)

	// GetBrandingCssWithResponse request
	GetBrandingCssWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingCssResponse, error)

	// GetBrandingCss2WithResponse request
	GetBrandingCss2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingCss2Response, error)

	// DeleteCustomSplashscreenWithResponse request
	DeleteCustomSplashscreenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCustomSplashscreenResponse, error)

	// GetSplashscreenWithResponse request
	GetSplashscreenWithResponse(ctx context.Context, params *GetSplashscreenParams, reqEditors ...RequestEditorFn) (*GetSplashscreenResponse, error)

	// UploadCustomSplashscreenWithBodyWithResponse request with any body
	UploadCustomSplashscreenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomSplashscreenResponse, error)

	// GetChannelsWithResponse request
	GetChannelsWithResponse(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error)

	// GetAllChannelFeaturesWithResponse request
	GetAllChannelFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllChannelFeaturesResponse, error)

	// GetLatestChannelItemsWithResponse request
	GetLatestChannelItemsWithResponse(ctx context.Context, params *GetLatestChannelItemsParams, reqEditors ...RequestEditorFn) (*GetLatestChannelItemsResponse, error)

	// GetChannelFeaturesWithResponse request
	GetChannelFeaturesWithResponse(ctx context.Context, channelId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetChannelFeaturesResponse, error)

	// GetChannelItemsWithResponse request
	GetChannelItemsWithResponse(ctx context.Context, channelId openapi_types.UUID, params *GetChannelItemsParams, reqEditors ...RequestEditorFn) (*GetChannelItemsResponse, error)

	// LogFileWithBodyWithResponse request with any body
	LogFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogFileResponse, error)

	LogFileWithTextBodyWithResponse(ctx context.Context, body LogFileTextRequestBody, reqEditors ...RequestEditorFn) (*LogFileResponse, error)

	// CreateCollectionWithResponse request
	CreateCollectionWithResponse(ctx context.Context, params *CreateCollectionParams, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// RemoveFromCollectionWithResponse request
	RemoveFromCollectionWithResponse(ctx context.Context, collectionId openapi_types.UUID, params *RemoveFromCollectionParams, reqEditors ...RequestEditorFn) (*RemoveFromCollectionResponse, error)

	// AddToCollectionWithResponse request
	AddToCollectionWithResponse(ctx context.Context, collectionId openapi_types.UUID, params *AddToCollectionParams, reqEditors ...RequestEditorFn) (*AddToCollectionResponse, error)

	// DeleteDeviceWithResponse request
	DeleteDeviceWithResponse(ctx context.Context, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error)

	// GetDevicesWithResponse request
	GetDevicesWithResponse(ctx context.Context, params *GetDevicesParams, reqEditors ...RequestEditorFn) (*GetDevicesResponse, error)

	// GetDeviceInfoWithResponse request
	GetDeviceInfoWithResponse(ctx context.Context, params *GetDeviceInfoParams, reqEditors ...RequestEditorFn) (*GetDeviceInfoResponse, error)

	// GetDeviceOptionsWithResponse request
	GetDeviceOptionsWithResponse(ctx context.Context, params *GetDeviceOptionsParams, reqEditors ...RequestEditorFn) (*GetDeviceOptionsResponse, error)

	// UpdateDeviceOptionsWithBodyWithResponse request with any body
	UpdateDeviceOptionsWithBodyWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error)

	UpdateDeviceOptionsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error)

	UpdateDeviceOptionsWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error)

	// GetDisplayPreferencesWithResponse request
	GetDisplayPreferencesWithResponse(ctx context.Context, displayPreferencesId string, params *GetDisplayPreferencesParams, reqEditors ...RequestEditorFn) (*GetDisplayPreferencesResponse, error)

	// UpdateDisplayPreferencesWithBodyWithResponse request with any body
	UpdateDisplayPreferencesWithBodyWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error)

	UpdateDisplayPreferencesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error)

	UpdateDisplayPreferencesWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error)

	// GetProfileInfosWithResponse request
	GetProfileInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileInfosResponse, error)

	// CreateProfileWithBodyWithResponse request with any body
	CreateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error)

	CreateProfileWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error)

	CreateProfileWithResponse(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error)

	// GetDefaultProfileWithResponse request
	GetDefaultProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultProfileResponse, error)

	// DeleteProfileWithResponse request
	DeleteProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*DeleteProfileResponse, error)

	// GetProfileWithResponse request
	GetProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*GetProfileResponse, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, profileId string, body UpdateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithResponse(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// GetIconWithResponse request
	GetIconWithResponse(ctx context.Context, fileName string, reqEditors ...RequestEditorFn) (*GetIconResponse, error)

	// GetConnectionManagerWithResponse request
	GetConnectionManagerWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManagerResponse, error)

	// GetConnectionManager2WithResponse request
	GetConnectionManager2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManager2Response, error)

	// GetConnectionManager3WithResponse request
	GetConnectionManager3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManager3Response, error)

	// ProcessConnectionManagerControlRequestWithResponse request
	ProcessConnectionManagerControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessConnectionManagerControlRequestResponse, error)

	// GetContentDirectoryWithResponse request
	GetContentDirectoryWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectoryResponse, error)

	// GetContentDirectory2WithResponse request
	GetContentDirectory2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectory2Response, error)

	// GetContentDirectory3WithResponse request
	GetContentDirectory3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectory3Response, error)

	// ProcessContentDirectoryControlRequestWithResponse request
	ProcessContentDirectoryControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessContentDirectoryControlRequestResponse, error)

	// GetMediaReceiverRegistrarWithResponse request
	GetMediaReceiverRegistrarWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrarResponse, error)

	// ProcessMediaReceiverRegistrarControlRequestWithResponse request
	ProcessMediaReceiverRegistrarControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessMediaReceiverRegistrarControlRequestResponse, error)

	// GetMediaReceiverRegistrar2WithResponse request
	GetMediaReceiverRegistrar2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrar2Response, error)

	// GetMediaReceiverRegistrar3WithResponse request
	GetMediaReceiverRegistrar3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrar3Response, error)

	// GetDescriptionXmlWithResponse request
	GetDescriptionXmlWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetDescriptionXmlResponse, error)

	// GetDescriptionXml2WithResponse request
	GetDescriptionXml2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetDescriptionXml2Response, error)

	// GetIconIdWithResponse request
	GetIconIdWithResponse(ctx context.Context, serverId string, fileName string, reqEditors ...RequestEditorFn) (*GetIconIdResponse, error)

	// GetDefaultDirectoryBrowserWithResponse request
	GetDefaultDirectoryBrowserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultDirectoryBrowserResponse, error)

	// GetDirectoryContentsWithResponse request
	GetDirectoryContentsWithResponse(ctx context.Context, params *GetDirectoryContentsParams, reqEditors ...RequestEditorFn) (*GetDirectoryContentsResponse, error)

	// GetDrivesWithResponse request
	GetDrivesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrivesResponse, error)

	// GetNetworkSharesWithResponse request
	GetNetworkSharesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkSharesResponse, error)

	// GetParentPathWithResponse request
	GetParentPathWithResponse(ctx context.Context, params *GetParentPathParams, reqEditors ...RequestEditorFn) (*GetParentPathResponse, error)

	// ValidatePathWithBodyWithResponse request with any body
	ValidatePathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error)

	ValidatePathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ValidatePathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error)

	ValidatePathWithResponse(ctx context.Context, body ValidatePathJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error)

	// GetFallbackFontListWithResponse request
	GetFallbackFontListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFallbackFontListResponse, error)

	// GetFallbackFontWithResponse request
	GetFallbackFontWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetFallbackFontResponse, error)

	// GetGenresWithResponse request
	GetGenresWithResponse(ctx context.Context, params *GetGenresParams, reqEditors ...RequestEditorFn) (*GetGenresResponse, error)

	// GetGenreWithResponse request
	GetGenreWithResponse(ctx context.Context, genreName string, params *GetGenreParams, reqEditors ...RequestEditorFn) (*GetGenreResponse, error)

	// GetGenreImageWithResponse request
	GetGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetGenreImageParams, reqEditors ...RequestEditorFn) (*GetGenreImageResponse, error)

	// HeadGenreImageWithResponse request
	HeadGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadGenreImageParams, reqEditors ...RequestEditorFn) (*HeadGenreImageResponse, error)

	// GetGenreImageByIndexWithResponse request
	GetGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*GetGenreImageByIndexResponse, error)

	// HeadGenreImageByIndexWithResponse request
	HeadGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadGenreImageByIndexResponse, error)

	// GetUtcTimeWithResponse request
	GetUtcTimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtcTimeResponse, error)

	// GetGeneralImagesWithResponse request
	GetGeneralImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGeneralImagesResponse, error)

	// GetGeneralImageWithResponse request
	GetGeneralImageWithResponse(ctx context.Context, name string, pType string, reqEditors ...RequestEditorFn) (*GetGeneralImageResponse, error)

	// GetMediaInfoImagesWithResponse request
	GetMediaInfoImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMediaInfoImagesResponse, error)

	// GetMediaInfoImageWithResponse request
	GetMediaInfoImageWithResponse(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*GetMediaInfoImageResponse, error)

	// GetRatingImagesWithResponse request
	GetRatingImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRatingImagesResponse, error)

	// GetRatingImageWithResponse request
	GetRatingImageWithResponse(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*GetRatingImageResponse, error)

	// DeleteItemsWithResponse request
	DeleteItemsWithResponse(ctx context.Context, params *DeleteItemsParams, reqEditors ...RequestEditorFn) (*DeleteItemsResponse, error)

	// GetItemsWithResponse request
	GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error)

	// GetItemCountsWithResponse request
	GetItemCountsWithResponse(ctx context.Context, params *GetItemCountsParams, reqEditors ...RequestEditorFn) (*GetItemCountsResponse, error)

	// GetQueryFiltersLegacyWithResponse request
	GetQueryFiltersLegacyWithResponse(ctx context.Context, params *GetQueryFiltersLegacyParams, reqEditors ...RequestEditorFn) (*GetQueryFiltersLegacyResponse, error)

	// GetQueryFiltersWithResponse request
	GetQueryFiltersWithResponse(ctx context.Context, params *GetQueryFiltersParams, reqEditors ...RequestEditorFn) (*GetQueryFiltersResponse, error)

	// ApplySearchCriteriaWithBodyWithResponse request with any body
	ApplySearchCriteriaWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error)

	ApplySearchCriteriaWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error)

	ApplySearchCriteriaWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error)

	// GetBookRemoteSearchResultsWithBodyWithResponse request with any body
	GetBookRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error)

	GetBookRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error)

	GetBookRemoteSearchResultsWithResponse(ctx context.Context, body GetBookRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error)

	// GetBoxSetRemoteSearchResultsWithBodyWithResponse request with any body
	GetBoxSetRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error)

	GetBoxSetRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error)

	GetBoxSetRemoteSearchResultsWithResponse(ctx context.Context, body GetBoxSetRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error)

	// GetMovieRemoteSearchResultsWithBodyWithResponse request with any body
	GetMovieRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error)

	GetMovieRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error)

	GetMovieRemoteSearchResultsWithResponse(ctx context.Context, body GetMovieRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error)

	// GetMusicAlbumRemoteSearchResultsWithBodyWithResponse request with any body
	GetMusicAlbumRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error)

	GetMusicAlbumRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error)

	GetMusicAlbumRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicAlbumRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error)

	// GetMusicArtistRemoteSearchResultsWithBodyWithResponse request with any body
	GetMusicArtistRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error)

	GetMusicArtistRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error)

	GetMusicArtistRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicArtistRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error)

	// GetMusicVideoRemoteSearchResultsWithBodyWithResponse request with any body
	GetMusicVideoRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error)

	GetMusicVideoRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error)

	GetMusicVideoRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicVideoRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error)

	// GetPersonRemoteSearchResultsWithBodyWithResponse request with any body
	GetPersonRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error)

	GetPersonRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error)

	GetPersonRemoteSearchResultsWithResponse(ctx context.Context, body GetPersonRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error)

	// GetSeriesRemoteSearchResultsWithBodyWithResponse request with any body
	GetSeriesRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error)

	GetSeriesRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error)

	GetSeriesRemoteSearchResultsWithResponse(ctx context.Context, body GetSeriesRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error)

	// GetTrailerRemoteSearchResultsWithBodyWithResponse request with any body
	GetTrailerRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error)

	GetTrailerRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error)

	GetTrailerRemoteSearchResultsWithResponse(ctx context.Context, body GetTrailerRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error)

	// GetInstantMixFromItemWithResponse request
	GetInstantMixFromItemWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromItemParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromItemResponse, error)

	// DeleteItemWithResponse request
	DeleteItemWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteItemResponse, error)

	// UpdateItemWithBodyWithResponse request with any body
	UpdateItemWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error)

	UpdateItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, body UpdateItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error)

	UpdateItemWithResponse(ctx context.Context, itemId openapi_types.UUID, body UpdateItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error)

	// GetAncestorsWithResponse request
	GetAncestorsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAncestorsParams, reqEditors ...RequestEditorFn) (*GetAncestorsResponse, error)

	// UpdateItemContentTypeWithResponse request
	UpdateItemContentTypeWithResponse(ctx context.Context, itemId openapi_types.UUID, params *UpdateItemContentTypeParams, reqEditors ...RequestEditorFn) (*UpdateItemContentTypeResponse, error)

	// GetCriticReviewsWithResponse request
	GetCriticReviewsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetCriticReviewsResponse, error)

	// GetDownloadWithResponse request
	GetDownloadWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDownloadResponse, error)

	// GetExternalIdInfosWithResponse request
	GetExternalIdInfosWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExternalIdInfosResponse, error)

	// GetFileWithResponse request
	GetFileWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// GetItemImageInfosWithResponse request
	GetItemImageInfosWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemImageInfosResponse, error)

	// DeleteItemImageWithResponse request
	DeleteItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *DeleteItemImageParams, reqEditors ...RequestEditorFn) (*DeleteItemImageResponse, error)

	// GetItemImageWithResponse request
	GetItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *GetItemImageParams, reqEditors ...RequestEditorFn) (*GetItemImageResponse, error)

	// HeadItemImageWithResponse request
	HeadItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *HeadItemImageParams, reqEditors ...RequestEditorFn) (*HeadItemImageResponse, error)

	// SetItemImageWithBodyWithResponse request with any body
	SetItemImageWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetItemImageResponse, error)

	// DeleteItemImageByIndexWithResponse request
	DeleteItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, reqEditors ...RequestEditorFn) (*DeleteItemImageByIndexResponse, error)

	// GetItemImageByIndexWithResponse request
	GetItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetItemImageByIndexParams, reqEditors ...RequestEditorFn) (*GetItemImageByIndexResponse, error)

	// HeadItemImageByIndexWithResponse request
	HeadItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadItemImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadItemImageByIndexResponse, error)

	// SetItemImageByIndexWithBodyWithResponse request with any body
	SetItemImageByIndexWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetItemImageByIndexResponse, error)

	// UpdateItemImageIndexWithResponse request
	UpdateItemImageIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *UpdateItemImageIndexParams, reqEditors ...RequestEditorFn) (*UpdateItemImageIndexResponse, error)

	// GetItemImage2WithResponse request
	GetItemImage2WithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *GetItemImage2Params, reqEditors ...RequestEditorFn) (*GetItemImage2Response, error)

	// HeadItemImage2WithResponse request
	HeadItemImage2WithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *HeadItemImage2Params, reqEditors ...RequestEditorFn) (*HeadItemImage2Response, error)

	// GetMetadataEditorInfoWithResponse request
	GetMetadataEditorInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMetadataEditorInfoResponse, error)

	// GetPlaybackInfoWithResponse request
	GetPlaybackInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPlaybackInfoParams, reqEditors ...RequestEditorFn) (*GetPlaybackInfoResponse, error)

	// GetPostedPlaybackInfoWithBodyWithResponse request with any body
	GetPostedPlaybackInfoWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error)

	GetPostedPlaybackInfoWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error)

	GetPostedPlaybackInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error)

	// RefreshItemWithResponse request
	RefreshItemWithResponse(ctx context.Context, itemId openapi_types.UUID, params *RefreshItemParams, reqEditors ...RequestEditorFn) (*RefreshItemResponse, error)

	// GetRemoteImagesWithResponse request
	GetRemoteImagesWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetRemoteImagesParams, reqEditors ...RequestEditorFn) (*GetRemoteImagesResponse, error)

	// DownloadRemoteImageWithResponse request
	DownloadRemoteImageWithResponse(ctx context.Context, itemId openapi_types.UUID, params *DownloadRemoteImageParams, reqEditors ...RequestEditorFn) (*DownloadRemoteImageResponse, error)

	// GetRemoteImageProvidersWithResponse request
	GetRemoteImageProvidersWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRemoteImageProvidersResponse, error)

	// SearchRemoteSubtitlesWithResponse request
	SearchRemoteSubtitlesWithResponse(ctx context.Context, itemId openapi_types.UUID, language string, params *SearchRemoteSubtitlesParams, reqEditors ...RequestEditorFn) (*SearchRemoteSubtitlesResponse, error)

	// DownloadRemoteSubtitlesWithResponse request
	DownloadRemoteSubtitlesWithResponse(ctx context.Context, itemId openapi_types.UUID, subtitleId string, reqEditors ...RequestEditorFn) (*DownloadRemoteSubtitlesResponse, error)

	// GetSimilarItemsWithResponse request
	GetSimilarItemsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarItemsParams, reqEditors ...RequestEditorFn) (*GetSimilarItemsResponse, error)

	// GetThemeMediaWithResponse request
	GetThemeMediaWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeMediaParams, reqEditors ...RequestEditorFn) (*GetThemeMediaResponse, error)

	// GetThemeSongsWithResponse request
	GetThemeSongsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeSongsParams, reqEditors ...RequestEditorFn) (*GetThemeSongsResponse, error)

	// GetThemeVideosWithResponse request
	GetThemeVideosWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeVideosParams, reqEditors ...RequestEditorFn) (*GetThemeVideosResponse, error)

	// ValidateLoginInfoWithBodyWithResponse request with any body
	ValidateLoginInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error)

	ValidateLoginInfoWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ValidateLoginInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error)

	ValidateLoginInfoWithResponse(ctx context.Context, body ValidateLoginInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error)

	// GetLibraryOptionsInfoWithResponse request
	GetLibraryOptionsInfoWithResponse(ctx context.Context, params *GetLibraryOptionsInfoParams, reqEditors ...RequestEditorFn) (*GetLibraryOptionsInfoResponse, error)

	// PostUpdatedMediaWithBodyWithResponse request with any body
	PostUpdatedMediaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error)

	PostUpdatedMediaWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostUpdatedMediaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error)

	PostUpdatedMediaWithResponse(ctx context.Context, body PostUpdatedMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error)

	// GetMediaFoldersWithResponse request
	GetMediaFoldersWithResponse(ctx context.Context, params *GetMediaFoldersParams, reqEditors ...RequestEditorFn) (*GetMediaFoldersResponse, error)

	// PostAddedMoviesWithResponse request
	PostAddedMoviesWithResponse(ctx context.Context, params *PostAddedMoviesParams, reqEditors ...RequestEditorFn) (*PostAddedMoviesResponse, error)

	// PostUpdatedMoviesWithResponse request
	PostUpdatedMoviesWithResponse(ctx context.Context, params *PostUpdatedMoviesParams, reqEditors ...RequestEditorFn) (*PostUpdatedMoviesResponse, error)

	// GetPhysicalPathsWithResponse request
	GetPhysicalPathsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPhysicalPathsResponse, error)

	// RefreshLibraryWithResponse request
	RefreshLibraryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshLibraryResponse, error)

	// PostAddedSeriesWithResponse request
	PostAddedSeriesWithResponse(ctx context.Context, params *PostAddedSeriesParams, reqEditors ...RequestEditorFn) (*PostAddedSeriesResponse, error)

	// PostUpdatedSeriesWithResponse request
	PostUpdatedSeriesWithResponse(ctx context.Context, params *PostUpdatedSeriesParams, reqEditors ...RequestEditorFn) (*PostUpdatedSeriesResponse, error)

	// RemoveVirtualFolderWithResponse request
	RemoveVirtualFolderWithResponse(ctx context.Context, params *RemoveVirtualFolderParams, reqEditors ...RequestEditorFn) (*RemoveVirtualFolderResponse, error)

	// GetVirtualFoldersWithResponse request
	GetVirtualFoldersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVirtualFoldersResponse, error)

	// AddVirtualFolderWithBodyWithResponse request with any body
	AddVirtualFolderWithBodyWithResponse(ctx context.Context, params *AddVirtualFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error)

	AddVirtualFolderWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error)

	AddVirtualFolderWithResponse(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error)

	// UpdateLibraryOptionsWithBodyWithResponse request with any body
	UpdateLibraryOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error)

	UpdateLibraryOptionsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error)

	UpdateLibraryOptionsWithResponse(ctx context.Context, body UpdateLibraryOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error)

	// RenameVirtualFolderWithResponse request
	RenameVirtualFolderWithResponse(ctx context.Context, params *RenameVirtualFolderParams, reqEditors ...RequestEditorFn) (*RenameVirtualFolderResponse, error)

	// RemoveMediaPathWithResponse request
	RemoveMediaPathWithResponse(ctx context.Context, params *RemoveMediaPathParams, reqEditors ...RequestEditorFn) (*RemoveMediaPathResponse, error)

	// AddMediaPathWithBodyWithResponse request with any body
	AddMediaPathWithBodyWithResponse(ctx context.Context, params *AddMediaPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error)

	AddMediaPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddMediaPathParams, body AddMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error)

	AddMediaPathWithResponse(ctx context.Context, params *AddMediaPathParams, body AddMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error)

	// UpdateMediaPathWithBodyWithResponse request with any body
	UpdateMediaPathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error)

	UpdateMediaPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error)

	UpdateMediaPathWithResponse(ctx context.Context, body UpdateMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error)

	// CloseLiveStreamWithResponse request
	CloseLiveStreamWithResponse(ctx context.Context, params *CloseLiveStreamParams, reqEditors ...RequestEditorFn) (*CloseLiveStreamResponse, error)

	// OpenLiveStreamWithBodyWithResponse request with any body
	OpenLiveStreamWithBodyWithResponse(ctx context.Context, params *OpenLiveStreamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error)

	OpenLiveStreamWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error)

	OpenLiveStreamWithResponse(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error)

	// GetChannelMappingOptionsWithResponse request
	GetChannelMappingOptionsWithResponse(ctx context.Context, params *GetChannelMappingOptionsParams, reqEditors ...RequestEditorFn) (*GetChannelMappingOptionsResponse, error)

	// SetChannelMappingWithBodyWithResponse request with any body
	SetChannelMappingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error)

	SetChannelMappingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetChannelMappingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error)

	SetChannelMappingWithResponse(ctx context.Context, body SetChannelMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error)

	// GetLiveTvChannelsWithResponse request
	GetLiveTvChannelsWithResponse(ctx context.Context, params *GetLiveTvChannelsParams, reqEditors ...RequestEditorFn) (*GetLiveTvChannelsResponse, error)

	// GetChannelWithResponse request
	GetChannelWithResponse(ctx context.Context, channelId openapi_types.UUID, params *GetChannelParams, reqEditors ...RequestEditorFn) (*GetChannelResponse, error)

	// GetGuideInfoWithResponse request
	GetGuideInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGuideInfoResponse, error)

	// GetLiveTvInfoWithResponse request
	GetLiveTvInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveTvInfoResponse, error)

	// DeleteListingProviderWithResponse request
	DeleteListingProviderWithResponse(ctx context.Context, params *DeleteListingProviderParams, reqEditors ...RequestEditorFn) (*DeleteListingProviderResponse, error)

	// AddListingProviderWithBodyWithResponse request with any body
	AddListingProviderWithBodyWithResponse(ctx context.Context, params *AddListingProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error)

	AddListingProviderWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddListingProviderParams, body AddListingProviderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error)

	AddListingProviderWithResponse(ctx context.Context, params *AddListingProviderParams, body AddListingProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error)

	// GetDefaultListingProviderWithResponse request
	GetDefaultListingProviderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultListingProviderResponse, error)

	// GetLineupsWithResponse request
	GetLineupsWithResponse(ctx context.Context, params *GetLineupsParams, reqEditors ...RequestEditorFn) (*GetLineupsResponse, error)

	// GetSchedulesDirectCountriesWithResponse request
	GetSchedulesDirectCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSchedulesDirectCountriesResponse, error)

	// GetLiveRecordingFileWithResponse request
	GetLiveRecordingFileWithResponse(ctx context.Context, recordingId string, reqEditors ...RequestEditorFn) (*GetLiveRecordingFileResponse, error)

	// GetLiveStreamFileWithResponse request
	GetLiveStreamFileWithResponse(ctx context.Context, streamId string, container string, reqEditors ...RequestEditorFn) (*GetLiveStreamFileResponse, error)

	// GetLiveTvProgramsWithResponse request
	GetLiveTvProgramsWithResponse(ctx context.Context, params *GetLiveTvProgramsParams, reqEditors ...RequestEditorFn) (*GetLiveTvProgramsResponse, error)

	// GetProgramsWithBodyWithResponse request with any body
	GetProgramsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	GetProgramsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetProgramsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	GetProgramsWithResponse(ctx context.Context, body GetProgramsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	// GetRecommendedProgramsWithResponse request
	GetRecommendedProgramsWithResponse(ctx context.Context, params *GetRecommendedProgramsParams, reqEditors ...RequestEditorFn) (*GetRecommendedProgramsResponse, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, programId string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// GetRecordingsWithResponse request
	GetRecordingsWithResponse(ctx context.Context, params *GetRecordingsParams, reqEditors ...RequestEditorFn) (*GetRecordingsResponse, error)

	// GetRecordingFoldersWithResponse request
	GetRecordingFoldersWithResponse(ctx context.Context, params *GetRecordingFoldersParams, reqEditors ...RequestEditorFn) (*GetRecordingFoldersResponse, error)

	// GetRecordingGroupsWithResponse request
	GetRecordingGroupsWithResponse(ctx context.Context, params *GetRecordingGroupsParams, reqEditors ...RequestEditorFn) (*GetRecordingGroupsResponse, error)

	// GetRecordingGroupWithResponse request
	GetRecordingGroupWithResponse(ctx context.Context, groupId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRecordingGroupResponse, error)

	// GetRecordingsSeriesWithResponse request
	GetRecordingsSeriesWithResponse(ctx context.Context, params *GetRecordingsSeriesParams, reqEditors ...RequestEditorFn) (*GetRecordingsSeriesResponse, error)

	// DeleteRecordingWithResponse request
	DeleteRecordingWithResponse(ctx context.Context, recordingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error)

	// GetRecordingWithResponse request
	GetRecordingWithResponse(ctx context.Context, recordingId openapi_types.UUID, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error)

	// GetSeriesTimersWithResponse request
	GetSeriesTimersWithResponse(ctx context.Context, params *GetSeriesTimersParams, reqEditors ...RequestEditorFn) (*GetSeriesTimersResponse, error)

	// CreateSeriesTimerWithBodyWithResponse request with any body
	CreateSeriesTimerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error)

	CreateSeriesTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error)

	CreateSeriesTimerWithResponse(ctx context.Context, body CreateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error)

	// CancelSeriesTimerWithResponse request
	CancelSeriesTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*CancelSeriesTimerResponse, error)

	// GetSeriesTimerWithResponse request
	GetSeriesTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*GetSeriesTimerResponse, error)

	// UpdateSeriesTimerWithBodyWithResponse request with any body
	UpdateSeriesTimerWithBodyWithResponse(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error)

	UpdateSeriesTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, timerId string, body UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error)

	UpdateSeriesTimerWithResponse(ctx context.Context, timerId string, body UpdateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error)

	// GetTimersWithResponse request
	GetTimersWithResponse(ctx context.Context, params *GetTimersParams, reqEditors ...RequestEditorFn) (*GetTimersResponse, error)

	// CreateTimerWithBodyWithResponse request with any body
	CreateTimerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error)

	CreateTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error)

	CreateTimerWithResponse(ctx context.Context, body CreateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error)

	// GetDefaultTimerWithResponse request
	GetDefaultTimerWithResponse(ctx context.Context, params *GetDefaultTimerParams, reqEditors ...RequestEditorFn) (*GetDefaultTimerResponse, error)

	// CancelTimerWithResponse request
	CancelTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*CancelTimerResponse, error)

	// GetTimerWithResponse request
	GetTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*GetTimerResponse, error)

	// UpdateTimerWithBodyWithResponse request with any body
	UpdateTimerWithBodyWithResponse(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error)

	UpdateTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, timerId string, body UpdateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error)

	UpdateTimerWithResponse(ctx context.Context, timerId string, body UpdateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error)

	// DeleteTunerHostWithResponse request
	DeleteTunerHostWithResponse(ctx context.Context, params *DeleteTunerHostParams, reqEditors ...RequestEditorFn) (*DeleteTunerHostResponse, error)

	// AddTunerHostWithBodyWithResponse request with any body
	AddTunerHostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error)

	AddTunerHostWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AddTunerHostApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error)

	AddTunerHostWithResponse(ctx context.Context, body AddTunerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error)

	// GetTunerHostTypesWithResponse request
	GetTunerHostTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTunerHostTypesResponse, error)

	// DiscoverTunersWithResponse request
	DiscoverTunersWithResponse(ctx context.Context, params *DiscoverTunersParams, reqEditors ...RequestEditorFn) (*DiscoverTunersResponse, error)

	// DiscvoverTunersWithResponse request
	DiscvoverTunersWithResponse(ctx context.Context, params *DiscvoverTunersParams, reqEditors ...RequestEditorFn) (*DiscvoverTunersResponse, error)

	// ResetTunerWithResponse request
	ResetTunerWithResponse(ctx context.Context, tunerId string, reqEditors ...RequestEditorFn) (*ResetTunerResponse, error)

	// GetCountriesWithResponse request
	GetCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountriesResponse, error)

	// GetCulturesWithResponse request
	GetCulturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCulturesResponse, error)

	// GetLocalizationOptionsWithResponse request
	GetLocalizationOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalizationOptionsResponse, error)

	// GetParentalRatingsWithResponse request
	GetParentalRatingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetParentalRatingsResponse, error)

	// GetMovieRecommendationsWithResponse request
	GetMovieRecommendationsWithResponse(ctx context.Context, params *GetMovieRecommendationsParams, reqEditors ...RequestEditorFn) (*GetMovieRecommendationsResponse, error)

	// GetSimilarMoviesWithResponse request
	GetSimilarMoviesWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarMoviesParams, reqEditors ...RequestEditorFn) (*GetSimilarMoviesResponse, error)

	// GetMusicGenresWithResponse request
	GetMusicGenresWithResponse(ctx context.Context, params *GetMusicGenresParams, reqEditors ...RequestEditorFn) (*GetMusicGenresResponse, error)

	// GetInstantMixFromMusicGenreByIdWithResponse request
	GetInstantMixFromMusicGenreByIdWithResponse(ctx context.Context, params *GetInstantMixFromMusicGenreByIdParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromMusicGenreByIdResponse, error)

	// GetMusicGenreWithResponse request
	GetMusicGenreWithResponse(ctx context.Context, genreName string, params *GetMusicGenreParams, reqEditors ...RequestEditorFn) (*GetMusicGenreResponse, error)

	// GetMusicGenreImageWithResponse request
	GetMusicGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetMusicGenreImageParams, reqEditors ...RequestEditorFn) (*GetMusicGenreImageResponse, error)

	// HeadMusicGenreImageWithResponse request
	HeadMusicGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadMusicGenreImageParams, reqEditors ...RequestEditorFn) (*HeadMusicGenreImageResponse, error)

	// GetMusicGenreImageByIndexWithResponse request
	GetMusicGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*GetMusicGenreImageByIndexResponse, error)

	// HeadMusicGenreImageByIndexWithResponse request
	HeadMusicGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadMusicGenreImageByIndexResponse, error)

	// GetInstantMixFromMusicGenreByNameWithResponse request
	GetInstantMixFromMusicGenreByNameWithResponse(ctx context.Context, name string, params *GetInstantMixFromMusicGenreByNameParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromMusicGenreByNameResponse, error)

	// CreateAdminNotificationWithBodyWithResponse request with any body
	CreateAdminNotificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error)

	CreateAdminNotificationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateAdminNotificationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error)

	CreateAdminNotificationWithResponse(ctx context.Context, body CreateAdminNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error)

	// GetNotificationServicesWithResponse request
	GetNotificationServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationServicesResponse, error)

	// GetNotificationTypesWithResponse request
	GetNotificationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationTypesResponse, error)

	// GetNotificationsWithResponse request
	GetNotificationsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error)

	// SetReadWithResponse request
	SetReadWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetReadResponse, error)

	// GetNotificationsSummaryWithResponse request
	GetNotificationsSummaryWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetNotificationsSummaryResponse, error)

	// SetUnreadWithResponse request
	SetUnreadWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetUnreadResponse, error)

	// GetPackagesWithResponse request
	GetPackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error)

	// InstallPackageWithResponse request
	InstallPackageWithResponse(ctx context.Context, name string, params *InstallPackageParams, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	// CancelPackageInstallationWithResponse request
	CancelPackageInstallationWithResponse(ctx context.Context, packageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*CancelPackageInstallationResponse, error)

	// GetPackageInfoWithResponse request
	GetPackageInfoWithResponse(ctx context.Context, name string, params *GetPackageInfoParams, reqEditors ...RequestEditorFn) (*GetPackageInfoResponse, error)

	// GetPersonsWithResponse request
	GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error)

	// GetPersonWithResponse request
	GetPersonWithResponse(ctx context.Context, name string, params *GetPersonParams, reqEditors ...RequestEditorFn) (*GetPersonResponse, error)

	// GetPersonImageWithResponse request
	GetPersonImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetPersonImageParams, reqEditors ...RequestEditorFn) (*GetPersonImageResponse, error)

	// HeadPersonImageWithResponse request
	HeadPersonImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadPersonImageParams, reqEditors ...RequestEditorFn) (*HeadPersonImageResponse, error)

	// GetPersonImageByIndexWithResponse request
	GetPersonImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*GetPersonImageByIndexResponse, error)

	// HeadPersonImageByIndexWithResponse request
	HeadPersonImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadPersonImageByIndexResponse, error)

	// GetBitrateTestBytesWithResponse request
	GetBitrateTestBytesWithResponse(ctx context.Context, params *GetBitrateTestBytesParams, reqEditors ...RequestEditorFn) (*GetBitrateTestBytesResponse, error)

	// CreatePlaylistWithBodyWithResponse request with any body
	CreatePlaylistWithBodyWithResponse(ctx context.Context, params *CreatePlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	CreatePlaylistWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	CreatePlaylistWithResponse(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	// GetInstantMixFromPlaylistWithResponse request
	GetInstantMixFromPlaylistWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromPlaylistParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromPlaylistResponse, error)

	// RemoveFromPlaylistWithResponse request
	RemoveFromPlaylistWithResponse(ctx context.Context, playlistId string, params *RemoveFromPlaylistParams, reqEditors ...RequestEditorFn) (*RemoveFromPlaylistResponse, error)

	// GetPlaylistItemsWithResponse request
	GetPlaylistItemsWithResponse(ctx context.Context, playlistId openapi_types.UUID, params *GetPlaylistItemsParams, reqEditors ...RequestEditorFn) (*GetPlaylistItemsResponse, error)

	// AddToPlaylistWithResponse request
	AddToPlaylistWithResponse(ctx context.Context, playlistId openapi_types.UUID, params *AddToPlaylistParams, reqEditors ...RequestEditorFn) (*AddToPlaylistResponse, error)

	// MoveItemWithResponse request
	MoveItemWithResponse(ctx context.Context, playlistId string, itemId string, newIndex int32, reqEditors ...RequestEditorFn) (*MoveItemResponse, error)

	// GetPluginsWithResponse request
	GetPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginsResponse, error)

	// UninstallPluginWithResponse request
	UninstallPluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UninstallPluginResponse, error)

	// GetPluginConfigurationWithResponse request
	GetPluginConfigurationWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPluginConfigurationResponse, error)

	// UpdatePluginConfigurationWithResponse request
	UpdatePluginConfigurationWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UpdatePluginConfigurationResponse, error)

	// GetPluginManifestWithResponse request
	GetPluginManifestWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPluginManifestResponse, error)

	// UninstallPluginByVersionWithResponse request
	UninstallPluginByVersionWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*UninstallPluginByVersionResponse, error)

	// DisablePluginWithResponse request
	DisablePluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*DisablePluginResponse, error)

	// EnablePluginWithResponse request
	EnablePluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*EnablePluginResponse, error)

	// GetPluginImageWithResponse request
	GetPluginImageWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*GetPluginImageResponse, error)

	// GetRemoteSubtitlesWithResponse request
	GetRemoteSubtitlesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRemoteSubtitlesResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// ConnectWithResponse request
	ConnectWithResponse(ctx context.Context, params *ConnectParams, reqEditors ...RequestEditorFn) (*ConnectResponse, error)

	// GetEnabledWithResponse request
	GetEnabledWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnabledResponse, error)

	// InitiateWithResponse request
	InitiateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateResponse, error)

	// GetActivityLogsWithResponse request
	GetActivityLogsWithResponse(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*GetActivityLogsResponse, error)

	// GetReportHeadersWithResponse request
	GetReportHeadersWithResponse(ctx context.Context, params *GetReportHeadersParams, reqEditors ...RequestEditorFn) (*GetReportHeadersResponse, error)

	// GetItemReportWithResponse request
	GetItemReportWithResponse(ctx context.Context, params *GetItemReportParams, reqEditors ...RequestEditorFn) (*GetItemReportResponse, error)

	// GetReportDownloadWithResponse request
	GetReportDownloadWithResponse(ctx context.Context, params *GetReportDownloadParams, reqEditors ...RequestEditorFn) (*GetReportDownloadResponse, error)

	// GetRepositoriesWithResponse request
	GetRepositoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoriesResponse, error)

	// SetRepositoriesWithBodyWithResponse request with any body
	SetRepositoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error)

	SetRepositoriesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetRepositoriesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error)

	SetRepositoriesWithResponse(ctx context.Context, body SetRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error)

	// GetTasksWithResponse request
	GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error)

	// StopTaskWithResponse request
	StopTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*StopTaskResponse, error)

	// StartTaskWithResponse request
	StartTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*StartTaskResponse, error)

	// GetTaskWithResponse request
	GetTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error)

	// UpdateTaskWithBodyWithResponse request with any body
	UpdateTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	UpdateTaskWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, taskId string, body UpdateTaskApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	UpdateTaskWithResponse(ctx context.Context, taskId string, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error)

	// GetWithResponse request
	GetWithResponse(ctx context.Context, params *GetParams, reqEditors ...RequestEditorFn) (*GetResponse, error)

	// GetSessionsWithResponse request
	GetSessionsWithResponse(ctx context.Context, params *GetSessionsParams, reqEditors ...RequestEditorFn) (*GetSessionsResponse, error)

	// PostCapabilitiesWithResponse request
	PostCapabilitiesWithResponse(ctx context.Context, params *PostCapabilitiesParams, reqEditors ...RequestEditorFn) (*PostCapabilitiesResponse, error)

	// PostFullCapabilitiesWithBodyWithResponse request with any body
	PostFullCapabilitiesWithBodyWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error)

	PostFullCapabilitiesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error)

	PostFullCapabilitiesWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error)

	// ReportSessionEndedWithResponse request
	ReportSessionEndedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReportSessionEndedResponse, error)

	// ReportPlaybackStartWithBodyWithResponse request with any body
	ReportPlaybackStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error)

	ReportPlaybackStartWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackStartApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error)

	ReportPlaybackStartWithResponse(ctx context.Context, body ReportPlaybackStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error)

	// PingPlaybackSessionWithResponse request
	PingPlaybackSessionWithResponse(ctx context.Context, params *PingPlaybackSessionParams, reqEditors ...RequestEditorFn) (*PingPlaybackSessionResponse, error)

	// ReportPlaybackProgressWithBodyWithResponse request with any body
	ReportPlaybackProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error)

	ReportPlaybackProgressWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error)

	ReportPlaybackProgressWithResponse(ctx context.Context, body ReportPlaybackProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error)

	// ReportPlaybackStoppedWithBodyWithResponse request with any body
	ReportPlaybackStoppedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error)

	ReportPlaybackStoppedWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error)

	ReportPlaybackStoppedWithResponse(ctx context.Context, body ReportPlaybackStoppedJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error)

	// ReportViewingWithResponse request
	ReportViewingWithResponse(ctx context.Context, params *ReportViewingParams, reqEditors ...RequestEditorFn) (*ReportViewingResponse, error)

	// SendFullGeneralCommandWithBodyWithResponse request with any body
	SendFullGeneralCommandWithBodyWithResponse(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error)

	SendFullGeneralCommandWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, sessionId string, body SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error)

	SendFullGeneralCommandWithResponse(ctx context.Context, sessionId string, body SendFullGeneralCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error)

	// SendGeneralCommandWithResponse request
	SendGeneralCommandWithResponse(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*SendGeneralCommandResponse, error)

	// SendMessageCommandWithBodyWithResponse request with any body
	SendMessageCommandWithBodyWithResponse(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error)

	SendMessageCommandWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, sessionId string, body SendMessageCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error)

	SendMessageCommandWithResponse(ctx context.Context, sessionId string, body SendMessageCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error)

	// PlayWithResponse request
	PlayWithResponse(ctx context.Context, sessionId string, params *PlayParams, reqEditors ...RequestEditorFn) (*PlayResponse, error)

	// SendPlaystateCommandWithResponse request
	SendPlaystateCommandWithResponse(ctx context.Context, sessionId string, command PlaystateCommand, params *SendPlaystateCommandParams, reqEditors ...RequestEditorFn) (*SendPlaystateCommandResponse, error)

	// SendSystemCommandWithResponse request
	SendSystemCommandWithResponse(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*SendSystemCommandResponse, error)

	// RemoveUserFromSessionWithResponse request
	RemoveUserFromSessionWithResponse(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RemoveUserFromSessionResponse, error)

	// AddUserToSessionWithResponse request
	AddUserToSessionWithResponse(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AddUserToSessionResponse, error)

	// DisplayContentWithResponse request
	DisplayContentWithResponse(ctx context.Context, sessionId string, params *DisplayContentParams, reqEditors ...RequestEditorFn) (*DisplayContentResponse, error)

	// GetNextUpWithResponse request
	GetNextUpWithResponse(ctx context.Context, params *GetNextUpParams, reqEditors ...RequestEditorFn) (*GetNextUpResponse, error)

	// GetUpcomingEpisodesWithResponse request
	GetUpcomingEpisodesWithResponse(ctx context.Context, params *GetUpcomingEpisodesParams, reqEditors ...RequestEditorFn) (*GetUpcomingEpisodesResponse, error)

	// GetSimilarShowsWithResponse request
	GetSimilarShowsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarShowsParams, reqEditors ...RequestEditorFn) (*GetSimilarShowsResponse, error)

	// GetEpisodesWithResponse request
	GetEpisodesWithResponse(ctx context.Context, seriesId openapi_types.UUID, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*GetEpisodesResponse, error)

	// GetSeasonsWithResponse request
	GetSeasonsWithResponse(ctx context.Context, seriesId openapi_types.UUID, params *GetSeasonsParams, reqEditors ...RequestEditorFn) (*GetSeasonsResponse, error)

	// GetInstantMixFromSongWithResponse request
	GetInstantMixFromSongWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromSongParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromSongResponse, error)

	// CompleteWizardWithResponse request
	CompleteWizardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CompleteWizardResponse, error)

	// GetStartupConfigurationWithResponse request
	GetStartupConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStartupConfigurationResponse, error)

	// UpdateInitialConfigurationWithBodyWithResponse request with any body
	UpdateInitialConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error)

	UpdateInitialConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error)

	UpdateInitialConfigurationWithResponse(ctx context.Context, body UpdateInitialConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error)

	// GetFirstUser2WithResponse request
	GetFirstUser2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirstUser2Response, error)

	// SetRemoteAccessWithBodyWithResponse request with any body
	SetRemoteAccessWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error)

	SetRemoteAccessWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetRemoteAccessApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error)

	SetRemoteAccessWithResponse(ctx context.Context, body SetRemoteAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error)

	// GetFirstUserWithResponse request
	GetFirstUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirstUserResponse, error)

	// UpdateStartupUserWithBodyWithResponse request with any body
	UpdateStartupUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error)

	UpdateStartupUserWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateStartupUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error)

	UpdateStartupUserWithResponse(ctx context.Context, body UpdateStartupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error)

	// GetStudiosWithResponse request
	GetStudiosWithResponse(ctx context.Context, params *GetStudiosParams, reqEditors ...RequestEditorFn) (*GetStudiosResponse, error)

	// GetStudioWithResponse request
	GetStudioWithResponse(ctx context.Context, name string, params *GetStudioParams, reqEditors ...RequestEditorFn) (*GetStudioResponse, error)

	// GetStudioImageWithResponse request
	GetStudioImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetStudioImageParams, reqEditors ...RequestEditorFn) (*GetStudioImageResponse, error)

	// HeadStudioImageWithResponse request
	HeadStudioImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadStudioImageParams, reqEditors ...RequestEditorFn) (*HeadStudioImageResponse, error)

	// GetStudioImageByIndexWithResponse request
	GetStudioImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*GetStudioImageByIndexResponse, error)

	// HeadStudioImageByIndexWithResponse request
	HeadStudioImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadStudioImageByIndexResponse, error)

	// SyncPlayBufferingWithBodyWithResponse request with any body
	SyncPlayBufferingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error)

	SyncPlayBufferingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayBufferingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error)

	SyncPlayBufferingWithResponse(ctx context.Context, body SyncPlayBufferingJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error)

	// SyncPlayJoinGroupWithBodyWithResponse request with any body
	SyncPlayJoinGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error)

	SyncPlayJoinGroupWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error)

	SyncPlayJoinGroupWithResponse(ctx context.Context, body SyncPlayJoinGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error)

	// SyncPlayLeaveGroupWithResponse request
	SyncPlayLeaveGroupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayLeaveGroupResponse, error)

	// SyncPlayGetGroupsWithResponse request
	SyncPlayGetGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayGetGroupsResponse, error)

	// SyncPlayMovePlaylistItemWithBodyWithResponse request with any body
	SyncPlayMovePlaylistItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error)

	SyncPlayMovePlaylistItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error)

	SyncPlayMovePlaylistItemWithResponse(ctx context.Context, body SyncPlayMovePlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error)

	// SyncPlayCreateGroupWithBodyWithResponse request with any body
	SyncPlayCreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error)

	SyncPlayCreateGroupWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error)

	SyncPlayCreateGroupWithResponse(ctx context.Context, body SyncPlayCreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error)

	// SyncPlayNextItemWithBodyWithResponse request with any body
	SyncPlayNextItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error)

	SyncPlayNextItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayNextItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error)

	SyncPlayNextItemWithResponse(ctx context.Context, body SyncPlayNextItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error)

	// SyncPlayPauseWithResponse request
	SyncPlayPauseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayPauseResponse, error)

	// SyncPlayPingWithBodyWithResponse request with any body
	SyncPlayPingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error)

	SyncPlayPingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayPingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error)

	SyncPlayPingWithResponse(ctx context.Context, body SyncPlayPingJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error)

	// SyncPlayPreviousItemWithBodyWithResponse request with any body
	SyncPlayPreviousItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error)

	SyncPlayPreviousItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error)

	SyncPlayPreviousItemWithResponse(ctx context.Context, body SyncPlayPreviousItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error)

	// SyncPlayQueueWithBodyWithResponse request with any body
	SyncPlayQueueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error)

	SyncPlayQueueWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error)

	SyncPlayQueueWithResponse(ctx context.Context, body SyncPlayQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error)

	// SyncPlayReadyWithBodyWithResponse request with any body
	SyncPlayReadyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error)

	SyncPlayReadyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayReadyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error)

	SyncPlayReadyWithResponse(ctx context.Context, body SyncPlayReadyJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error)

	// SyncPlayRemoveFromPlaylistWithBodyWithResponse request with any body
	SyncPlayRemoveFromPlaylistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error)

	SyncPlayRemoveFromPlaylistWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error)

	SyncPlayRemoveFromPlaylistWithResponse(ctx context.Context, body SyncPlayRemoveFromPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error)

	// SyncPlaySeekWithBodyWithResponse request with any body
	SyncPlaySeekWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error)

	SyncPlaySeekWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySeekApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error)

	SyncPlaySeekWithResponse(ctx context.Context, body SyncPlaySeekJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error)

	// SyncPlaySetIgnoreWaitWithBodyWithResponse request with any body
	SyncPlaySetIgnoreWaitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error)

	SyncPlaySetIgnoreWaitWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error)

	SyncPlaySetIgnoreWaitWithResponse(ctx context.Context, body SyncPlaySetIgnoreWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error)

	// SyncPlaySetNewQueueWithBodyWithResponse request with any body
	SyncPlaySetNewQueueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error)

	SyncPlaySetNewQueueWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error)

	SyncPlaySetNewQueueWithResponse(ctx context.Context, body SyncPlaySetNewQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error)

	// SyncPlaySetPlaylistItemWithBodyWithResponse request with any body
	SyncPlaySetPlaylistItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error)

	SyncPlaySetPlaylistItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error)

	SyncPlaySetPlaylistItemWithResponse(ctx context.Context, body SyncPlaySetPlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error)

	// SyncPlaySetRepeatModeWithBodyWithResponse request with any body
	SyncPlaySetRepeatModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error)

	SyncPlaySetRepeatModeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error)

	SyncPlaySetRepeatModeWithResponse(ctx context.Context, body SyncPlaySetRepeatModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error)

	// SyncPlaySetShuffleModeWithBodyWithResponse request with any body
	SyncPlaySetShuffleModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error)

	SyncPlaySetShuffleModeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error)

	SyncPlaySetShuffleModeWithResponse(ctx context.Context, body SyncPlaySetShuffleModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error)

	// SyncPlayStopWithResponse request
	SyncPlayStopWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayStopResponse, error)

	// SyncPlayUnpauseWithResponse request
	SyncPlayUnpauseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayUnpauseResponse, error)

	// GetLogEntriesWithResponse request
	GetLogEntriesWithResponse(ctx context.Context, params *GetLogEntriesParams, reqEditors ...RequestEditorFn) (*GetLogEntriesResponse, error)

	// GetConfigurationWithResponse request
	GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error)

	// UpdateConfigurationWithBodyWithResponse request with any body
	UpdateConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error)

	UpdateConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error)

	UpdateConfigurationWithResponse(ctx context.Context, body UpdateConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error)

	// GetDefaultMetadataOptionsWithResponse request
	GetDefaultMetadataOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultMetadataOptionsResponse, error)

	// GetNamedConfigurationWithResponse request
	GetNamedConfigurationWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetNamedConfigurationResponse, error)

	// UpdateNamedConfigurationWithBodyWithResponse request with any body
	UpdateNamedConfigurationWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error)

	UpdateNamedConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, key string, body UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error)

	UpdateNamedConfigurationWithResponse(ctx context.Context, key string, body UpdateNamedConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error)

	// GetEndpointInfoWithResponse request
	GetEndpointInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointInfoResponse, error)

	// GetSystemInfoWithResponse request
	GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error)

	// GetPublicSystemInfoWithResponse request
	GetPublicSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublicSystemInfoResponse, error)

	// GetServerLogsWithResponse request
	GetServerLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerLogsResponse, error)

	// GetLogFileWithResponse request
	GetLogFileWithResponse(ctx context.Context, params *GetLogFileParams, reqEditors ...RequestEditorFn) (*GetLogFileResponse, error)

	// UpdateMediaEncoderPathWithBodyWithResponse request with any body
	UpdateMediaEncoderPathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error)

	UpdateMediaEncoderPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error)

	UpdateMediaEncoderPathWithResponse(ctx context.Context, body UpdateMediaEncoderPathJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error)

	// GetPingSystemWithResponse request
	GetPingSystemWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingSystemResponse, error)

	// PostPingSystemWithResponse request
	PostPingSystemWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostPingSystemResponse, error)

	// RestartApplicationWithResponse request
	RestartApplicationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RestartApplicationResponse, error)

	// ShutdownApplicationWithResponse request
	ShutdownApplicationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShutdownApplicationResponse, error)

	// GetWakeOnLanInfoWithResponse request
	GetWakeOnLanInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWakeOnLanInfoResponse, error)

	// TmdbClientConfigurationWithResponse request
	TmdbClientConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TmdbClientConfigurationResponse, error)

	// GetTrailersWithResponse request
	GetTrailersWithResponse(ctx context.Context, params *GetTrailersParams, reqEditors ...RequestEditorFn) (*GetTrailersResponse, error)

	// GetSimilarTrailersWithResponse request
	GetSimilarTrailersWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarTrailersParams, reqEditors ...RequestEditorFn) (*GetSimilarTrailersResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// AuthenticateUserByNameWithBodyWithResponse request with any body
	AuthenticateUserByNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error)

	AuthenticateUserByNameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error)

	AuthenticateUserByNameWithResponse(ctx context.Context, body AuthenticateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error)

	// AuthenticateWithQuickConnectWithBodyWithResponse request with any body
	AuthenticateWithQuickConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error)

	AuthenticateWithQuickConnectWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error)

	AuthenticateWithQuickConnectWithResponse(ctx context.Context, body AuthenticateWithQuickConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error)

	// ForgotPasswordWithBodyWithResponse request with any body
	ForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error)

	ForgotPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ForgotPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error)

	ForgotPasswordWithResponse(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error)

	// ForgotPasswordPinWithBodyWithResponse request with any body
	ForgotPasswordPinWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error)

	ForgotPasswordPinWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ForgotPasswordPinApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error)

	ForgotPasswordPinWithResponse(ctx context.Context, body ForgotPasswordPinJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// CreateUserByNameWithBodyWithResponse request with any body
	CreateUserByNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error)

	CreateUserByNameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error)

	CreateUserByNameWithResponse(ctx context.Context, body CreateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error)

	// GetPublicUsersWithResponse request
	GetPublicUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublicUsersResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserByIdWithResponse request
	GetUserByIdWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// AuthenticateUserWithResponse request
	AuthenticateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *AuthenticateUserParams, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error)

	// UpdateUserConfigurationWithBodyWithResponse request with any body
	UpdateUserConfigurationWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error)

	UpdateUserConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error)

	UpdateUserConfigurationWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error)

	// UpdateUserEasyPasswordWithBodyWithResponse request with any body
	UpdateUserEasyPasswordWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error)

	UpdateUserEasyPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error)

	UpdateUserEasyPasswordWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error)

	// UnmarkFavoriteItemWithResponse request
	UnmarkFavoriteItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UnmarkFavoriteItemResponse, error)

	// MarkFavoriteItemWithResponse request
	MarkFavoriteItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkFavoriteItemResponse, error)

	// GetGroupingOptionsWithResponse request
	GetGroupingOptionsWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetGroupingOptionsResponse, error)

	// DeleteUserImageWithResponse request
	DeleteUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *DeleteUserImageParams, reqEditors ...RequestEditorFn) (*DeleteUserImageResponse, error)

	// GetUserImageWithResponse request
	GetUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *GetUserImageParams, reqEditors ...RequestEditorFn) (*GetUserImageResponse, error)

	// HeadUserImageWithResponse request
	HeadUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *HeadUserImageParams, reqEditors ...RequestEditorFn) (*HeadUserImageResponse, error)

	// PostUserImageWithBodyWithResponse request with any body
	PostUserImageWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *PostUserImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserImageResponse, error)

	// GetUserImageByIndexWithResponse request
	GetUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetUserImageByIndexParams, reqEditors ...RequestEditorFn) (*GetUserImageByIndexResponse, error)

	// HeadUserImageByIndexWithResponse request
	HeadUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadUserImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadUserImageByIndexResponse, error)

	// DeleteUserImageByIndexWithResponse request
	DeleteUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, reqEditors ...RequestEditorFn) (*DeleteUserImageByIndexResponse, error)

	// PostUserImageByIndexWithBodyWithResponse request with any body
	PostUserImageByIndexWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserImageByIndexResponse, error)

	// GetItemsByUserIdWithResponse request
	GetItemsByUserIdWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetItemsByUserIdParams, reqEditors ...RequestEditorFn) (*GetItemsByUserIdResponse, error)

	// GetLatestMediaWithResponse request
	GetLatestMediaWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetLatestMediaParams, reqEditors ...RequestEditorFn) (*GetLatestMediaResponse, error)

	// GetResumeItemsWithResponse request
	GetResumeItemsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetResumeItemsParams, reqEditors ...RequestEditorFn) (*GetResumeItemsResponse, error)

	// GetRootFolderWithResponse request
	GetRootFolderWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRootFolderResponse, error)

	// GetItemWithResponse request
	GetItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemResponse, error)

	// GetIntrosWithResponse request
	GetIntrosWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetIntrosResponse, error)

	// GetLocalTrailersWithResponse request
	GetLocalTrailersWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLocalTrailersResponse, error)

	// DeleteUserItemRatingWithResponse request
	DeleteUserItemRatingWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserItemRatingResponse, error)

	// UpdateUserItemRatingWithResponse request
	UpdateUserItemRatingWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *UpdateUserItemRatingParams, reqEditors ...RequestEditorFn) (*UpdateUserItemRatingResponse, error)

	// GetSpecialFeaturesWithResponse request
	GetSpecialFeaturesWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSpecialFeaturesResponse, error)

	// UpdateUserPasswordWithBodyWithResponse request with any body
	UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	// MarkUnplayedItemWithResponse request
	MarkUnplayedItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkUnplayedItemResponse, error)

	// MarkPlayedItemWithResponse request
	MarkPlayedItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *MarkPlayedItemParams, reqEditors ...RequestEditorFn) (*MarkPlayedItemResponse, error)

	// OnPlaybackStoppedWithResponse request
	OnPlaybackStoppedWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStoppedParams, reqEditors ...RequestEditorFn) (*OnPlaybackStoppedResponse, error)

	// OnPlaybackStartWithResponse request
	OnPlaybackStartWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStartParams, reqEditors ...RequestEditorFn) (*OnPlaybackStartResponse, error)

	// OnPlaybackProgressWithResponse request
	OnPlaybackProgressWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackProgressParams, reqEditors ...RequestEditorFn) (*OnPlaybackProgressResponse, error)

	// UpdateUserPolicyWithBodyWithResponse request with any body
	UpdateUserPolicyWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error)

	UpdateUserPolicyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error)

	UpdateUserPolicyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error)

	// GetSuggestionsWithResponse request
	GetSuggestionsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetSuggestionsParams, reqEditors ...RequestEditorFn) (*GetSuggestionsResponse, error)

	// GetUserViewsWithResponse request
	GetUserViewsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserViewsParams, reqEditors ...RequestEditorFn) (*GetUserViewsResponse, error)

	// StopEncodingProcessWithResponse request
	StopEncodingProcessWithResponse(ctx context.Context, params *StopEncodingProcessParams, reqEditors ...RequestEditorFn) (*StopEncodingProcessResponse, error)

	// MergeVersionsWithResponse request
	MergeVersionsWithResponse(ctx context.Context, params *MergeVersionsParams, reqEditors ...RequestEditorFn) (*MergeVersionsResponse, error)

	// GetAdditionalPartWithResponse request
	GetAdditionalPartWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAdditionalPartParams, reqEditors ...RequestEditorFn) (*GetAdditionalPartResponse, error)

	// DeleteAlternateSourcesWithResponse request
	DeleteAlternateSourcesWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAlternateSourcesResponse, error)

	// UploadSubtitleWithBodyWithResponse request with any body
	UploadSubtitleWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error)

	UploadSubtitleWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error)

	UploadSubtitleWithResponse(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error)

	// DeleteSubtitleWithResponse request
	DeleteSubtitleWithResponse(ctx context.Context, itemId openapi_types.UUID, index int32, reqEditors ...RequestEditorFn) (*DeleteSubtitleResponse, error)

	// GetHlsPlaylistLegacyWithResponse request
	GetHlsPlaylistLegacyWithResponse(ctx context.Context, itemId string, playlistId string, reqEditors ...RequestEditorFn) (*GetHlsPlaylistLegacyResponse, error)

	// GetHlsVideoSegmentLegacyWithResponse request
	GetHlsVideoSegmentLegacyWithResponse(ctx context.Context, itemId string, playlistId string, segmentId string, segmentContainer string, reqEditors ...RequestEditorFn) (*GetHlsVideoSegmentLegacyResponse, error)

	// GetHlsVideoSegmentWithResponse request
	GetHlsVideoSegmentWithResponse(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsVideoSegmentParams, reqEditors ...RequestEditorFn) (*GetHlsVideoSegmentResponse, error)

	// GetLiveHlsStreamWithResponse request
	GetLiveHlsStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetLiveHlsStreamParams, reqEditors ...RequestEditorFn) (*GetLiveHlsStreamResponse, error)

	// GetVariantHlsVideoPlaylistWithResponse request
	GetVariantHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*GetVariantHlsVideoPlaylistResponse, error)

	// GetMasterHlsVideoPlaylistWithResponse request
	GetMasterHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*GetMasterHlsVideoPlaylistResponse, error)

	// HeadMasterHlsVideoPlaylistWithResponse request
	HeadMasterHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*HeadMasterHlsVideoPlaylistResponse, error)

	// GetVideoStreamWithResponse request
	GetVideoStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVideoStreamParams, reqEditors ...RequestEditorFn) (*GetVideoStreamResponse, error)

	// HeadVideoStreamWithResponse request
	HeadVideoStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadVideoStreamParams, reqEditors ...RequestEditorFn) (*HeadVideoStreamResponse, error)

	// GetVideoStreamByContainerWithResponse request
	GetVideoStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *GetVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*GetVideoStreamByContainerResponse, error)

	// HeadVideoStreamByContainerWithResponse request
	HeadVideoStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*HeadVideoStreamByContainerResponse, error)

	// GetSubtitlePlaylistWithResponse request
	GetSubtitlePlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, mediaSourceId string, index int32, params *GetSubtitlePlaylistParams, reqEditors ...RequestEditorFn) (*GetSubtitlePlaylistResponse, error)

	// GetSubtitleWithResponse request
	GetSubtitleWithResponse(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeFormat string, params *GetSubtitleParams, reqEditors ...RequestEditorFn) (*GetSubtitleResponse, error)

	// GetSubtitleWithTicksWithResponse request
	GetSubtitleWithTicksWithResponse(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeStartPositionTicks int64, routeFormat string, params *GetSubtitleWithTicksParams, reqEditors ...RequestEditorFn) (*GetSubtitleWithTicksResponse, error)

	// GetAttachmentWithResponse request
	GetAttachmentWithResponse(ctx context.Context, videoId openapi_types.UUID, mediaSourceId string, index int32, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error)

	// GetYearsWithResponse request
	GetYearsWithResponse(ctx context.Context, params *GetYearsParams, reqEditors ...RequestEditorFn) (*GetYearsResponse, error)

	// GetYearWithResponse request
	GetYearWithResponse(ctx context.Context, year int32, params *GetYearParams, reqEditors ...RequestEditorFn) (*GetYearResponse, error)

	// GetDurationHistogramReportWithResponse request
	GetDurationHistogramReportWithResponse(ctx context.Context, params *GetDurationHistogramReportParams, reqEditors ...RequestEditorFn) (*GetDurationHistogramReportResponse, error)

	// GetTvShowsReportWithResponse request
	GetTvShowsReportWithResponse(ctx context.Context, params *GetTvShowsReportParams, reqEditors ...RequestEditorFn) (*GetTvShowsReportResponse, error)

	// GetHourlyReportWithResponse request
	GetHourlyReportWithResponse(ctx context.Context, params *GetHourlyReportParams, reqEditors ...RequestEditorFn) (*GetHourlyReportResponse, error)

	// GetMovieReportWithResponse request
	GetMovieReportWithResponse(ctx context.Context, params *GetMovieReportParams, reqEditors ...RequestEditorFn) (*GetMovieReportResponse, error)

	// GetUsageStatsWithResponse request
	GetUsageStatsWithResponse(ctx context.Context, params *GetUsageStatsParams, reqEditors ...RequestEditorFn) (*GetUsageStatsResponse, error)

	// LoadBackupWithResponse request
	LoadBackupWithResponse(ctx context.Context, params *LoadBackupParams, reqEditors ...RequestEditorFn) (*LoadBackupResponse, error)

	// SaveBackupWithResponse request
	SaveBackupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SaveBackupResponse, error)

	// CustomQueryWithBodyWithResponse request with any body
	CustomQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error)

	CustomQueryWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CustomQueryApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error)

	CustomQueryWithResponse(ctx context.Context, body CustomQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error)

	// GetTypeFilterListWithResponse request
	GetTypeFilterListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypeFilterListResponse, error)

	// GetUserReportWithResponse request
	GetUserReportWithResponse(ctx context.Context, params *GetUserReportParams, reqEditors ...RequestEditorFn) (*GetUserReportResponse, error)

	// GetJellyfinUsersWithResponse request
	GetJellyfinUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJellyfinUsersResponse, error)

	// IgnoreListAddWithResponse request
	IgnoreListAddWithResponse(ctx context.Context, params *IgnoreListAddParams, reqEditors ...RequestEditorFn) (*IgnoreListAddResponse, error)

	// PruneUnknownUsersWithResponse request
	PruneUnknownUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PruneUnknownUsersResponse, error)

	// IgnoreListRemoveWithResponse request
	IgnoreListRemoveWithResponse(ctx context.Context, params *IgnoreListRemoveParams, reqEditors ...RequestEditorFn) (*IgnoreListRemoveResponse, error)

	// GetBreakdownReportWithResponse request
	GetBreakdownReportWithResponse(ctx context.Context, breakdownType string, params *GetBreakdownReportParams, reqEditors ...RequestEditorFn) (*GetBreakdownReportResponse, error)

	// GetUserReportDataWithResponse request
	GetUserReportDataWithResponse(ctx context.Context, userId string, date string, params *GetUserReportDataParams, reqEditors ...RequestEditorFn) (*GetUserReportDataResponse, error)

	// GetDashboardConfigurationPageWithResponse request
	GetDashboardConfigurationPageWithResponse(ctx context.Context, params *GetDashboardConfigurationPageParams, reqEditors ...RequestEditorFn) (*GetDashboardConfigurationPageResponse, error)

	// GetConfigurationPagesWithResponse request
	GetConfigurationPagesWithResponse(ctx context.Context, params *GetConfigurationPagesParams, reqEditors ...RequestEditorFn) (*GetConfigurationPagesResponse, error)
}

type GetInstantMixFromAlbumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromAlbumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromAlbumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlbumArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetAlbumArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlbumArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromArtists2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromArtists2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromArtists2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtistByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetArtistByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtistByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtistImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetArtistImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtistImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadArtistImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadArtistImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadArtistImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsAudioSegmentLegacyAacResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHlsAudioSegmentLegacyAacResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsAudioSegmentLegacyAacResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsAudioSegmentLegacyMp3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHlsAudioSegmentLegacyMp3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsAudioSegmentLegacyMp3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsAudioSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHlsAudioSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsAudioSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariantHlsAudioPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVariantHlsAudioPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariantHlsAudioPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterHlsAudioPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMasterHlsAudioPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterHlsAudioPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadMasterHlsAudioPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadMasterHlsAudioPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadMasterHlsAudioPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAudioStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadAudioStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadAudioStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadAudioStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioStreamByContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAudioStreamByContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioStreamByContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadAudioStreamByContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadAudioStreamByContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadAudioStreamByContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUniversalAudioStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUniversalAudioStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUniversalAudioStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadUniversalAudioStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadUniversalAudioStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadUniversalAudioStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationInfoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokeKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPasswordResetProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NameIdPair
}

// Status returns HTTPResponse.Status
func (r GetPasswordResetProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPasswordResetProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NameIdPair
}

// Status returns HTTPResponse.Status
func (r GetAuthProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrandingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandingOptions
}

// Status returns HTTPResponse.Status
func (r GetBrandingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrandingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrandingCssResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetBrandingCssResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrandingCssResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBrandingCss2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetBrandingCss2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBrandingCss2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomSplashscreenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomSplashscreenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomSplashscreenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSplashscreenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSplashscreenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSplashscreenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCustomSplashscreenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ProblemDetails
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UploadCustomSplashscreenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCustomSplashscreenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllChannelFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelFeatures
}

// Status returns HTTPResponse.Status
func (r GetAllChannelFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllChannelFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestChannelItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetLatestChannelItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestChannelItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelFeatures
}

// Status returns HTTPResponse.Status
func (r GetChannelFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetChannelItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientLogDocumentResponseDto
	JSON403      *ProblemDetails
	JSON413      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r LogFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionCreationResult
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveFromCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveFromCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveFromCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddToCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddToCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddToCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceInfoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeviceInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceOptions
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDeviceOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDeviceOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateDeviceOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDeviceOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDisplayPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DisplayPreferencesDto
}

// Status returns HTTPResponse.Status
func (r GetDisplayPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDisplayPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDisplayPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateDisplayPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDisplayPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DeviceProfileInfo
}

// Status returns HTTPResponse.Status
func (r GetProfileInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceProfile
}

// Status returns HTTPResponse.Status
func (r GetDefaultProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceProfile
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionManagerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetConnectionManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionManager2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetConnectionManager2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionManager2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionManager3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetConnectionManager3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionManager3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessConnectionManagerControlRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r ProcessConnectionManagerControlRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessConnectionManagerControlRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetContentDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentDirectory2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetContentDirectory2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentDirectory2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentDirectory3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetContentDirectory3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentDirectory3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessContentDirectoryControlRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r ProcessContentDirectoryControlRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessContentDirectoryControlRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaReceiverRegistrarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetMediaReceiverRegistrarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaReceiverRegistrarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessMediaReceiverRegistrarControlRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r ProcessMediaReceiverRegistrarControlRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessMediaReceiverRegistrarControlRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaReceiverRegistrar2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetMediaReceiverRegistrar2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaReceiverRegistrar2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaReceiverRegistrar3Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetMediaReceiverRegistrar3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaReceiverRegistrar3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDescriptionXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetDescriptionXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDescriptionXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDescriptionXml2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	XML200       *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetDescriptionXml2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDescriptionXml2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIconIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetIconIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIconIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultDirectoryBrowserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DefaultDirectoryBrowserInfoDto
}

// Status returns HTTPResponse.Status
func (r GetDefaultDirectoryBrowserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultDirectoryBrowserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDirectoryContentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FileSystemEntryInfo
}

// Status returns HTTPResponse.Status
func (r GetDirectoryContentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDirectoryContentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDrivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FileSystemEntryInfo
}

// Status returns HTTPResponse.Status
func (r GetDrivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDrivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FileSystemEntryInfo
}

// Status returns HTTPResponse.Status
func (r GetNetworkSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParentPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetParentPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParentPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidatePathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r ValidatePathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidatePathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFallbackFontListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FontFile
}

// Status returns HTTPResponse.Status
func (r GetFallbackFontListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFallbackFontListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFallbackFontResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFallbackFontResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFallbackFontResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetGenreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenreImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetGenreImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenreImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadGenreImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadGenreImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadGenreImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenreImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetGenreImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenreImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadGenreImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadGenreImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadGenreImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUtcTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UtcTimeResponse
}

// Status returns HTTPResponse.Status
func (r GetUtcTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUtcTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGeneralImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImageByNameInfo
}

// Status returns HTTPResponse.Status
func (r GetGeneralImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGeneralImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGeneralImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetGeneralImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGeneralImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaInfoImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImageByNameInfo
}

// Status returns HTTPResponse.Status
func (r GetMediaInfoImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaInfoImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaInfoImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMediaInfoImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaInfoImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRatingImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImageByNameInfo
}

// Status returns HTTPResponse.Status
func (r GetRatingImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRatingImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRatingImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetRatingImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRatingImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemCountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemCounts
}

// Status returns HTTPResponse.Status
func (r GetItemCountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemCountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueryFiltersLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryFiltersLegacy
}

// Status returns HTTPResponse.Status
func (r GetQueryFiltersLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueryFiltersLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryFilters
}

// Status returns HTTPResponse.Status
func (r GetQueryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApplySearchCriteriaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApplySearchCriteriaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplySearchCriteriaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetBookRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBoxSetRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetBoxSetRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBoxSetRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetMovieRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicAlbumRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetMusicAlbumRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicAlbumRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicArtistRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetMusicArtistRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicArtistRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicVideoRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetMusicVideoRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicVideoRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetPersonRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetSeriesRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrailerRemoteSearchResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSearchResult
}

// Status returns HTTPResponse.Status
func (r GetTrailerRemoteSearchResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrailerRemoteSearchResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAncestorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseItemDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAncestorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAncestorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemContentTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateItemContentTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemContentTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCriticReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetCriticReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCriticReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalIdInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ExternalIdInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetExternalIdInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalIdInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemImageInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImageInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetItemImageInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemImageInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteItemImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetItemImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadItemImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadItemImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadItemImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetItemImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r SetItemImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetItemImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteItemImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetItemImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadItemImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadItemImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadItemImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetItemImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r SetItemImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetItemImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemImageIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateItemImageIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemImageIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemImage2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetItemImage2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemImage2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadItemImage2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadItemImage2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadItemImage2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetadataEditorInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataEditorInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMetadataEditorInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetadataEditorInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaybackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybackInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetPlaybackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaybackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostedPlaybackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaybackInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetPostedPlaybackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostedPlaybackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r RefreshItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteImageResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetRemoteImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadRemoteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DownloadRemoteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadRemoteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteImageProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImageProviderInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetRemoteImageProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteImageProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRemoteSubtitlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RemoteSubtitleInfo
}

// Status returns HTTPResponse.Status
func (r SearchRemoteSubtitlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRemoteSubtitlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadRemoteSubtitlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadRemoteSubtitlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadRemoteSubtitlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThemeMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllThemeMediaResult
}

// Status returns HTTPResponse.Status
func (r GetThemeMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThemeMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThemeSongsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThemeMediaResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetThemeSongsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThemeSongsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThemeVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThemeMediaResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetThemeVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThemeVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateLoginInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ProblemDetails
	JSON401      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r ValidateLoginInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateLoginInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLibraryOptionsInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LibraryOptionsResultDto
}

// Status returns HTTPResponse.Status
func (r GetLibraryOptionsInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLibraryOptionsInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUpdatedMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUpdatedMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUpdatedMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMediaFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetMediaFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMediaFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAddedMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAddedMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAddedMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUpdatedMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUpdatedMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUpdatedMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetPhysicalPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAddedSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAddedSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAddedSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUpdatedSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostUpdatedSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUpdatedSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveVirtualFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveVirtualFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveVirtualFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VirtualFolderInfo
}

// Status returns HTTPResponse.Status
func (r GetVirtualFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddVirtualFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLibraryOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateLibraryOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLibraryOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameVirtualFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
	JSON409      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r RenameVirtualFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameVirtualFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMediaPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMediaPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMediaPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMediaPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMediaPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMediaPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMediaPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMediaPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMediaPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseLiveStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CloseLiveStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseLiveStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenLiveStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LiveStreamResponse
}

// Status returns HTTPResponse.Status
func (r OpenLiveStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenLiveStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelMappingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelMappingOptionsDto
}

// Status returns HTTPResponse.Status
func (r GetChannelMappingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelMappingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetChannelMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TunerChannelMapping
}

// Status returns HTTPResponse.Status
func (r SetChannelMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetChannelMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveTvChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetLiveTvChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveTvChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGuideInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GuideInfo
}

// Status returns HTTPResponse.Status
func (r GetGuideInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGuideInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveTvInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LiveTvInfo
}

// Status returns HTTPResponse.Status
func (r GetLiveTvInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveTvInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListingProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteListingProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListingProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddListingProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsProviderInfo
}

// Status returns HTTPResponse.Status
func (r AddListingProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddListingProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultListingProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListingsProviderInfo
}

// Status returns HTTPResponse.Status
func (r GetDefaultListingProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultListingProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NameIdPair
}

// Status returns HTTPResponse.Status
func (r GetLineupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesDirectCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetSchedulesDirectCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesDirectCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveRecordingFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetLiveRecordingFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveRecordingFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveStreamFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetLiveStreamFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveStreamFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveTvProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetLiveTvProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveTvProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecommendedProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetRecommendedProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecommendedProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetRecordingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetRecordingFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetRecordingGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetRecordingGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingsSeriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetRecordingsSeriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingsSeriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesTimersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesTimerInfoDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSeriesTimersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesTimersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSeriesTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSeriesTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSeriesTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSeriesTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSeriesTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSeriesTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeriesTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesTimerInfoDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSeriesTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeriesTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSeriesTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSeriesTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSeriesTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimerInfoDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetTimersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SeriesTimerInfoDto
}

// Status returns HTTPResponse.Status
func (r GetDefaultTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimerInfoDto
}

// Status returns HTTPResponse.Status
func (r GetTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateTimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTunerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTunerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTunerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTunerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TunerHostInfo
}

// Status returns HTTPResponse.Status
func (r AddTunerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTunerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTunerHostTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NameIdPair
}

// Status returns HTTPResponse.Status
func (r GetTunerHostTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTunerHostTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscoverTunersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TunerHostInfo
}

// Status returns HTTPResponse.Status
func (r DiscoverTunersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscoverTunersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiscvoverTunersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TunerHostInfo
}

// Status returns HTTPResponse.Status
func (r DiscvoverTunersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiscvoverTunersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetTunerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResetTunerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetTunerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CountryInfo
}

// Status returns HTTPResponse.Status
func (r GetCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCulturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CultureDto
}

// Status returns HTTPResponse.Status
func (r GetCulturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCulturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalizationOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LocalizationOption
}

// Status returns HTTPResponse.Status
func (r GetLocalizationOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalizationOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParentalRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ParentalRating
}

// Status returns HTTPResponse.Status
func (r GetParentalRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParentalRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RecommendationDto
}

// Status returns HTTPResponse.Status
func (r GetMovieRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarMoviesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarMoviesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarMoviesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetMusicGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromMusicGenreByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromMusicGenreByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromMusicGenreByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicGenreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetMusicGenreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicGenreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicGenreImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMusicGenreImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicGenreImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadMusicGenreImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadMusicGenreImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadMusicGenreImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMusicGenreImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMusicGenreImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMusicGenreImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadMusicGenreImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadMusicGenreImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadMusicGenreImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromMusicGenreByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromMusicGenreByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromMusicGenreByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdminNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAdminNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdminNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NameIdPair
}

// Status returns HTTPResponse.Status
func (r GetNotificationServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NotificationTypeInfo
}

// Status returns HTTPResponse.Status
func (r GetNotificationTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationResultDto
}

// Status returns HTTPResponse.Status
func (r GetNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationsSummaryDto
}

// Status returns HTTPResponse.Status
func (r GetNotificationsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetUnreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetUnreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetUnreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageInfo
}

// Status returns HTTPResponse.Status
func (r GetPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r InstallPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPackageInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelPackageInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPackageInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageInfo
}

// Status returns HTTPResponse.Status
func (r GetPackageInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetPersonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPersonImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadPersonImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadPersonImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadPersonImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPersonImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadPersonImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadPersonImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadPersonImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitrateTestBytesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBitrateTestBytesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitrateTestBytesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlaylistCreationResult
}

// Status returns HTTPResponse.Status
func (r CreatePlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveFromPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveFromPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveFromPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetPlaylistItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddToPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddToPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddToPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MoveItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PluginInfo
}

// Status returns HTTPResponse.Status
func (r GetPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UninstallPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BasePluginConfiguration
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPluginConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdatePluginConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPluginManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallPluginByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UninstallPluginByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallPluginByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisablePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DisablePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisablePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnablePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r EnablePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnablePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetPluginImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRemoteSubtitlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRemoteSubtitlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRemoteSubtitlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuickConnectResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r ConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r GetEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuickConnectResult
}

// Status returns HTTPResponse.Status
func (r InitiateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetActivityLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportHeadersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReportHeadersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportHeadersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportResult
}

// Status returns HTTPResponse.Status
func (r GetItemReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportResult
}

// Status returns HTTPResponse.Status
func (r GetReportDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RepositoryInfo
}

// Status returns HTTPResponse.Status
func (r GetRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TaskInfo
}

// Status returns HTTPResponse.Status
func (r GetTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r StopTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r StartTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchHintResult
}

// Status returns HTTPResponse.Status
func (r GetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SessionInfo
}

// Status returns HTTPResponse.Status
func (r GetSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFullCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostFullCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFullCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportSessionEndedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportSessionEndedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportSessionEndedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportPlaybackStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportPlaybackStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportPlaybackStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingPlaybackSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PingPlaybackSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingPlaybackSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportPlaybackProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportPlaybackProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportPlaybackProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportPlaybackStoppedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportPlaybackStoppedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportPlaybackStoppedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportViewingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReportViewingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportViewingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendFullGeneralCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendFullGeneralCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendFullGeneralCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendGeneralCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendGeneralCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendGeneralCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendMessageCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendMessageCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendMessageCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PlayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPlaystateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendPlaystateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPlaystateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendSystemCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendSystemCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendSystemCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserToSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisplayContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisplayContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisplayContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNextUpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetNextUpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNextUpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpcomingEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetUpcomingEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpcomingEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarShowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarShowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarShowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSeasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstantMixFromSongResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetInstantMixFromSongResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstantMixFromSongResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteWizardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompleteWizardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteWizardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStartupConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartupConfigurationDto
}

// Status returns HTTPResponse.Status
func (r GetStartupConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStartupConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInitialConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateInitialConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInitialConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFirstUser2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartupUserDto
}

// Status returns HTTPResponse.Status
func (r GetFirstUser2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFirstUser2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRemoteAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRemoteAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRemoteAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFirstUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartupUserDto
}

// Status returns HTTPResponse.Status
func (r GetFirstUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFirstUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStartupUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateStartupUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStartupUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudiosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetStudiosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudiosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetStudioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudioImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetStudioImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudioImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadStudioImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadStudioImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadStudioImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStudioImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetStudioImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStudioImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadStudioImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadStudioImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadStudioImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayBufferingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayBufferingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayBufferingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayJoinGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayJoinGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayJoinGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayLeaveGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayLeaveGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayLeaveGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayGetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GroupInfoDto
}

// Status returns HTTPResponse.Status
func (r SyncPlayGetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayGetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayMovePlaylistItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayMovePlaylistItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayMovePlaylistItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayCreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayCreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayCreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayNextItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayNextItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayNextItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayPauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayPauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayPauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayPreviousItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayPreviousItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayPreviousItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayRemoveFromPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayRemoveFromPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayRemoveFromPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySeekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySeekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySeekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySetIgnoreWaitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySetIgnoreWaitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySetIgnoreWaitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySetNewQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySetNewQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySetNewQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySetPlaylistItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySetPlaylistItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySetPlaylistItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySetRepeatModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySetRepeatModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySetRepeatModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlaySetShuffleModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlaySetShuffleModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlaySetShuffleModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncPlayUnpauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncPlayUnpauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncPlayUnpauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityLogEntryQueryResult
}

// Status returns HTTPResponse.Status
func (r GetLogEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerConfiguration
}

// Status returns HTTPResponse.Status
func (r GetConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultMetadataOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetadataOptions
}

// Status returns HTTPResponse.Status
func (r GetDefaultMetadataOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultMetadataOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNamedConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetNamedConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNamedConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNamedConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNamedConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNamedConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndpointInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndPointInfo
}

// Status returns HTTPResponse.Status
func (r GetEndpointInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndpointInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfo
}

// Status returns HTTPResponse.Status
func (r GetSystemInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicSystemInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicSystemInfo
}

// Status returns HTTPResponse.Status
func (r GetPublicSystemInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicSystemInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LogFile
}

// Status returns HTTPResponse.Status
func (r GetServerLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLogFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMediaEncoderPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMediaEncoderPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMediaEncoderPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPingSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetPingSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPingSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPingSystemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r PostPingSystemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPingSystemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShutdownApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ShutdownApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShutdownApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWakeOnLanInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WakeOnLanInfo
}

// Status returns HTTPResponse.Status
func (r GetWakeOnLanInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWakeOnLanInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TmdbClientConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigImageTypes
}

// Status returns HTTPResponse.Status
func (r TmdbClientConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TmdbClientConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrailersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetTrailersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrailersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimilarTrailersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSimilarTrailersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimilarTrailersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserDto
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateUserByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationResult
}

// Status returns HTTPResponse.Status
func (r AuthenticateUserByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateUserByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateWithQuickConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationResult
}

// Status returns HTTPResponse.Status
func (r AuthenticateWithQuickConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateWithQuickConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForgotPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForgotPasswordResult
}

// Status returns HTTPResponse.Status
func (r ForgotPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForgotPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForgotPasswordPinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PinRedeemResult
}

// Status returns HTTPResponse.Status
func (r ForgotPasswordPinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForgotPasswordPinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDto
	JSON400      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDto
}

// Status returns HTTPResponse.Status
func (r CreateUserByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserDto
}

// Status returns HTTPResponse.Status
func (r GetPublicUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetUserByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ProblemDetails
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationResult
	JSON403      *ProblemDetails
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r AuthenticateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateUserConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserEasyPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateUserEasyPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserEasyPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnmarkFavoriteItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r UnmarkFavoriteItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnmarkFavoriteItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkFavoriteItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r MarkFavoriteItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkFavoriteItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SpecialViewOptionDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetGroupingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteUserImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetUserImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadUserImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadUserImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadUserImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r PostUserImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetUserImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadUserImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r HeadUserImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadUserImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteUserImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserImageByIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r PostUserImageByIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserImageByIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsByUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetItemsByUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsByUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetLatestMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResumeItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetResumeItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResumeItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRootFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetRootFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntrosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetIntrosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntrosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalTrailersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetLocalTrailersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalTrailersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserItemRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r DeleteUserItemRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserItemRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserItemRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r UpdateUserItemRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserItemRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpecialFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseItemDto
}

// Status returns HTTPResponse.Status
func (r GetSpecialFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpecialFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ProblemDetails
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkUnplayedItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r MarkUnplayedItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkUnplayedItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkPlayedItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserItemDataDto
}

// Status returns HTTPResponse.Status
func (r MarkPlayedItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkPlayedItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OnPlaybackStoppedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OnPlaybackStoppedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OnPlaybackStoppedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OnPlaybackStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OnPlaybackStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OnPlaybackStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OnPlaybackProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OnPlaybackProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OnPlaybackProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ProblemDetails
	JSON403      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateUserPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSuggestionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetSuggestionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSuggestionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetUserViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopEncodingProcessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StopEncodingProcessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopEncodingProcessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r MergeVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdditionalPartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetAdditionalPartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdditionalPartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAlternateSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteAlternateSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlternateSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSubtitleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadSubtitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSubtitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubtitleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteSubtitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubtitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsPlaylistLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHlsPlaylistLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsPlaylistLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsVideoSegmentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetHlsVideoSegmentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsVideoSegmentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHlsVideoSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHlsVideoSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHlsVideoSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveHlsStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLiveHlsStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveHlsStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariantHlsVideoPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVariantHlsVideoPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariantHlsVideoPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMasterHlsVideoPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMasterHlsVideoPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMasterHlsVideoPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadMasterHlsVideoPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadMasterHlsVideoPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadMasterHlsVideoPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideoStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVideoStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideoStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadVideoStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadVideoStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadVideoStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideoStreamByContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetVideoStreamByContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideoStreamByContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadVideoStreamByContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadVideoStreamByContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadVideoStreamByContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubtitlePlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubtitlePlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubtitlePlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubtitleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubtitleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubtitleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubtitleWithTicksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSubtitleWithTicksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubtitleWithTicksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAttachmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetYearsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDtoQueryResult
}

// Status returns HTTPResponse.Status
func (r GetYearsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetYearsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetYearResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BaseItemDto
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetYearResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetYearResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDurationHistogramReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDurationHistogramReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDurationHistogramReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTvShowsReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTvShowsReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTvShowsReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHourlyReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHourlyReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHourlyReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMovieReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMovieReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMovieReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUsageStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r LoadBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r SaveBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r CustomQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypeFilterListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetTypeFilterListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypeFilterListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUserReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJellyfinUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetJellyfinUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJellyfinUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IgnoreListAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IgnoreListAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IgnoreListAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PruneUnknownUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r PruneUnknownUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PruneUnknownUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IgnoreListRemoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IgnoreListRemoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IgnoreListRemoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBreakdownReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBreakdownReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBreakdownReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserReportDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUserReportDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserReportDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDashboardConfigurationPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetDashboardConfigurationPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDashboardConfigurationPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurationPageInfo
	JSON404      *ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetConfigurationPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetInstantMixFromAlbumWithResponse request returning *GetInstantMixFromAlbumResponse
func (c *ClientWithResponses) GetInstantMixFromAlbumWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromAlbumParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromAlbumResponse, error) {
	rsp, err := c.GetInstantMixFromAlbum(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromAlbumResponse(rsp)
}

// GetSimilarAlbumsWithResponse request returning *GetSimilarAlbumsResponse
func (c *ClientWithResponses) GetSimilarAlbumsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarAlbumsParams, reqEditors ...RequestEditorFn) (*GetSimilarAlbumsResponse, error) {
	rsp, err := c.GetSimilarAlbums(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarAlbumsResponse(rsp)
}

// GetArtistsWithResponse request returning *GetArtistsResponse
func (c *ClientWithResponses) GetArtistsWithResponse(ctx context.Context, params *GetArtistsParams, reqEditors ...RequestEditorFn) (*GetArtistsResponse, error) {
	rsp, err := c.GetArtists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtistsResponse(rsp)
}

// GetAlbumArtistsWithResponse request returning *GetAlbumArtistsResponse
func (c *ClientWithResponses) GetAlbumArtistsWithResponse(ctx context.Context, params *GetAlbumArtistsParams, reqEditors ...RequestEditorFn) (*GetAlbumArtistsResponse, error) {
	rsp, err := c.GetAlbumArtists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlbumArtistsResponse(rsp)
}

// GetInstantMixFromArtists2WithResponse request returning *GetInstantMixFromArtists2Response
func (c *ClientWithResponses) GetInstantMixFromArtists2WithResponse(ctx context.Context, params *GetInstantMixFromArtists2Params, reqEditors ...RequestEditorFn) (*GetInstantMixFromArtists2Response, error) {
	rsp, err := c.GetInstantMixFromArtists2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromArtists2Response(rsp)
}

// GetInstantMixFromArtistsWithResponse request returning *GetInstantMixFromArtistsResponse
func (c *ClientWithResponses) GetInstantMixFromArtistsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromArtistsParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromArtistsResponse, error) {
	rsp, err := c.GetInstantMixFromArtists(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromArtistsResponse(rsp)
}

// GetSimilarArtistsWithResponse request returning *GetSimilarArtistsResponse
func (c *ClientWithResponses) GetSimilarArtistsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarArtistsParams, reqEditors ...RequestEditorFn) (*GetSimilarArtistsResponse, error) {
	rsp, err := c.GetSimilarArtists(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarArtistsResponse(rsp)
}

// GetArtistByNameWithResponse request returning *GetArtistByNameResponse
func (c *ClientWithResponses) GetArtistByNameWithResponse(ctx context.Context, name string, params *GetArtistByNameParams, reqEditors ...RequestEditorFn) (*GetArtistByNameResponse, error) {
	rsp, err := c.GetArtistByName(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtistByNameResponse(rsp)
}

// GetArtistImageWithResponse request returning *GetArtistImageResponse
func (c *ClientWithResponses) GetArtistImageWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetArtistImageParams, reqEditors ...RequestEditorFn) (*GetArtistImageResponse, error) {
	rsp, err := c.GetArtistImage(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtistImageResponse(rsp)
}

// HeadArtistImageWithResponse request returning *HeadArtistImageResponse
func (c *ClientWithResponses) HeadArtistImageWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadArtistImageParams, reqEditors ...RequestEditorFn) (*HeadArtistImageResponse, error) {
	rsp, err := c.HeadArtistImage(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadArtistImageResponse(rsp)
}

// GetHlsAudioSegmentLegacyAacWithResponse request returning *GetHlsAudioSegmentLegacyAacResponse
func (c *ClientWithResponses) GetHlsAudioSegmentLegacyAacWithResponse(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentLegacyAacResponse, error) {
	rsp, err := c.GetHlsAudioSegmentLegacyAac(ctx, itemId, segmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsAudioSegmentLegacyAacResponse(rsp)
}

// GetHlsAudioSegmentLegacyMp3WithResponse request returning *GetHlsAudioSegmentLegacyMp3Response
func (c *ClientWithResponses) GetHlsAudioSegmentLegacyMp3WithResponse(ctx context.Context, itemId string, segmentId string, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentLegacyMp3Response, error) {
	rsp, err := c.GetHlsAudioSegmentLegacyMp3(ctx, itemId, segmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsAudioSegmentLegacyMp3Response(rsp)
}

// GetHlsAudioSegmentWithResponse request returning *GetHlsAudioSegmentResponse
func (c *ClientWithResponses) GetHlsAudioSegmentWithResponse(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsAudioSegmentParams, reqEditors ...RequestEditorFn) (*GetHlsAudioSegmentResponse, error) {
	rsp, err := c.GetHlsAudioSegment(ctx, itemId, playlistId, segmentId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsAudioSegmentResponse(rsp)
}

// GetVariantHlsAudioPlaylistWithResponse request returning *GetVariantHlsAudioPlaylistResponse
func (c *ClientWithResponses) GetVariantHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*GetVariantHlsAudioPlaylistResponse, error) {
	rsp, err := c.GetVariantHlsAudioPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariantHlsAudioPlaylistResponse(rsp)
}

// GetMasterHlsAudioPlaylistWithResponse request returning *GetMasterHlsAudioPlaylistResponse
func (c *ClientWithResponses) GetMasterHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*GetMasterHlsAudioPlaylistResponse, error) {
	rsp, err := c.GetMasterHlsAudioPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterHlsAudioPlaylistResponse(rsp)
}

// HeadMasterHlsAudioPlaylistWithResponse request returning *HeadMasterHlsAudioPlaylistResponse
func (c *ClientWithResponses) HeadMasterHlsAudioPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsAudioPlaylistParams, reqEditors ...RequestEditorFn) (*HeadMasterHlsAudioPlaylistResponse, error) {
	rsp, err := c.HeadMasterHlsAudioPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadMasterHlsAudioPlaylistResponse(rsp)
}

// GetAudioStreamWithResponse request returning *GetAudioStreamResponse
func (c *ClientWithResponses) GetAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAudioStreamParams, reqEditors ...RequestEditorFn) (*GetAudioStreamResponse, error) {
	rsp, err := c.GetAudioStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioStreamResponse(rsp)
}

// HeadAudioStreamWithResponse request returning *HeadAudioStreamResponse
func (c *ClientWithResponses) HeadAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadAudioStreamParams, reqEditors ...RequestEditorFn) (*HeadAudioStreamResponse, error) {
	rsp, err := c.HeadAudioStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadAudioStreamResponse(rsp)
}

// GetAudioStreamByContainerWithResponse request returning *GetAudioStreamByContainerResponse
func (c *ClientWithResponses) GetAudioStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *GetAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*GetAudioStreamByContainerResponse, error) {
	rsp, err := c.GetAudioStreamByContainer(ctx, itemId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioStreamByContainerResponse(rsp)
}

// HeadAudioStreamByContainerWithResponse request returning *HeadAudioStreamByContainerResponse
func (c *ClientWithResponses) HeadAudioStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadAudioStreamByContainerParams, reqEditors ...RequestEditorFn) (*HeadAudioStreamByContainerResponse, error) {
	rsp, err := c.HeadAudioStreamByContainer(ctx, itemId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadAudioStreamByContainerResponse(rsp)
}

// GetUniversalAudioStreamWithResponse request returning *GetUniversalAudioStreamResponse
func (c *ClientWithResponses) GetUniversalAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*GetUniversalAudioStreamResponse, error) {
	rsp, err := c.GetUniversalAudioStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUniversalAudioStreamResponse(rsp)
}

// HeadUniversalAudioStreamWithResponse request returning *HeadUniversalAudioStreamResponse
func (c *ClientWithResponses) HeadUniversalAudioStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadUniversalAudioStreamParams, reqEditors ...RequestEditorFn) (*HeadUniversalAudioStreamResponse, error) {
	rsp, err := c.HeadUniversalAudioStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadUniversalAudioStreamResponse(rsp)
}

// GetKeysWithResponse request returning *GetKeysResponse
func (c *ClientWithResponses) GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeysResponse(rsp)
}

// CreateKeyWithResponse request returning *CreateKeyResponse
func (c *ClientWithResponses) CreateKeyWithResponse(ctx context.Context, params *CreateKeyParams, reqEditors ...RequestEditorFn) (*CreateKeyResponse, error) {
	rsp, err := c.CreateKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateKeyResponse(rsp)
}

// RevokeKeyWithResponse request returning *RevokeKeyResponse
func (c *ClientWithResponses) RevokeKeyWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*RevokeKeyResponse, error) {
	rsp, err := c.RevokeKey(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeKeyResponse(rsp)
}

// GetPasswordResetProvidersWithResponse request returning *GetPasswordResetProvidersResponse
func (c *ClientWithResponses) GetPasswordResetProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPasswordResetProvidersResponse, error) {
	rsp, err := c.GetPasswordResetProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPasswordResetProvidersResponse(rsp)
}

// GetAuthProvidersWithResponse request returning *GetAuthProvidersResponse
func (c *ClientWithResponses) GetAuthProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthProvidersResponse, error) {
	rsp, err := c.GetAuthProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthProvidersResponse(rsp)
}

// GetBrandingOptionsWithResponse request returning *GetBrandingOptionsResponse
func (c *ClientWithResponses) GetBrandingOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingOptionsResponse, error) {
	rsp, err := c.GetBrandingOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrandingOptionsResponse(rsp)
}

// GetBrandingCssWithResponse request returning *GetBrandingCssResponse
func (c *ClientWithResponses) GetBrandingCssWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingCssResponse, error) {
	rsp, err := c.GetBrandingCss(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrandingCssResponse(rsp)
}

// GetBrandingCss2WithResponse request returning *GetBrandingCss2Response
func (c *ClientWithResponses) GetBrandingCss2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBrandingCss2Response, error) {
	rsp, err := c.GetBrandingCss2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBrandingCss2Response(rsp)
}

// DeleteCustomSplashscreenWithResponse request returning *DeleteCustomSplashscreenResponse
func (c *ClientWithResponses) DeleteCustomSplashscreenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCustomSplashscreenResponse, error) {
	rsp, err := c.DeleteCustomSplashscreen(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomSplashscreenResponse(rsp)
}

// GetSplashscreenWithResponse request returning *GetSplashscreenResponse
func (c *ClientWithResponses) GetSplashscreenWithResponse(ctx context.Context, params *GetSplashscreenParams, reqEditors ...RequestEditorFn) (*GetSplashscreenResponse, error) {
	rsp, err := c.GetSplashscreen(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSplashscreenResponse(rsp)
}

// UploadCustomSplashscreenWithBodyWithResponse request with arbitrary body returning *UploadCustomSplashscreenResponse
func (c *ClientWithResponses) UploadCustomSplashscreenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCustomSplashscreenResponse, error) {
	rsp, err := c.UploadCustomSplashscreenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCustomSplashscreenResponse(rsp)
}

// GetChannelsWithResponse request returning *GetChannelsResponse
func (c *ClientWithResponses) GetChannelsWithResponse(ctx context.Context, params *GetChannelsParams, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error) {
	rsp, err := c.GetChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsResponse(rsp)
}

// GetAllChannelFeaturesWithResponse request returning *GetAllChannelFeaturesResponse
func (c *ClientWithResponses) GetAllChannelFeaturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllChannelFeaturesResponse, error) {
	rsp, err := c.GetAllChannelFeatures(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllChannelFeaturesResponse(rsp)
}

// GetLatestChannelItemsWithResponse request returning *GetLatestChannelItemsResponse
func (c *ClientWithResponses) GetLatestChannelItemsWithResponse(ctx context.Context, params *GetLatestChannelItemsParams, reqEditors ...RequestEditorFn) (*GetLatestChannelItemsResponse, error) {
	rsp, err := c.GetLatestChannelItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestChannelItemsResponse(rsp)
}

// GetChannelFeaturesWithResponse request returning *GetChannelFeaturesResponse
func (c *ClientWithResponses) GetChannelFeaturesWithResponse(ctx context.Context, channelId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetChannelFeaturesResponse, error) {
	rsp, err := c.GetChannelFeatures(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelFeaturesResponse(rsp)
}

// GetChannelItemsWithResponse request returning *GetChannelItemsResponse
func (c *ClientWithResponses) GetChannelItemsWithResponse(ctx context.Context, channelId openapi_types.UUID, params *GetChannelItemsParams, reqEditors ...RequestEditorFn) (*GetChannelItemsResponse, error) {
	rsp, err := c.GetChannelItems(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelItemsResponse(rsp)
}

// LogFileWithBodyWithResponse request with arbitrary body returning *LogFileResponse
func (c *ClientWithResponses) LogFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LogFileResponse, error) {
	rsp, err := c.LogFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogFileResponse(rsp)
}

func (c *ClientWithResponses) LogFileWithTextBodyWithResponse(ctx context.Context, body LogFileTextRequestBody, reqEditors ...RequestEditorFn) (*LogFileResponse, error) {
	rsp, err := c.LogFileWithTextBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogFileResponse(rsp)
}

// CreateCollectionWithResponse request returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, params *CreateCollectionParams, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// RemoveFromCollectionWithResponse request returning *RemoveFromCollectionResponse
func (c *ClientWithResponses) RemoveFromCollectionWithResponse(ctx context.Context, collectionId openapi_types.UUID, params *RemoveFromCollectionParams, reqEditors ...RequestEditorFn) (*RemoveFromCollectionResponse, error) {
	rsp, err := c.RemoveFromCollection(ctx, collectionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveFromCollectionResponse(rsp)
}

// AddToCollectionWithResponse request returning *AddToCollectionResponse
func (c *ClientWithResponses) AddToCollectionWithResponse(ctx context.Context, collectionId openapi_types.UUID, params *AddToCollectionParams, reqEditors ...RequestEditorFn) (*AddToCollectionResponse, error) {
	rsp, err := c.AddToCollection(ctx, collectionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToCollectionResponse(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResponse
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, params *DeleteDeviceParams, reqEditors ...RequestEditorFn) (*DeleteDeviceResponse, error) {
	rsp, err := c.DeleteDevice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResponse(rsp)
}

// GetDevicesWithResponse request returning *GetDevicesResponse
func (c *ClientWithResponses) GetDevicesWithResponse(ctx context.Context, params *GetDevicesParams, reqEditors ...RequestEditorFn) (*GetDevicesResponse, error) {
	rsp, err := c.GetDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDevicesResponse(rsp)
}

// GetDeviceInfoWithResponse request returning *GetDeviceInfoResponse
func (c *ClientWithResponses) GetDeviceInfoWithResponse(ctx context.Context, params *GetDeviceInfoParams, reqEditors ...RequestEditorFn) (*GetDeviceInfoResponse, error) {
	rsp, err := c.GetDeviceInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceInfoResponse(rsp)
}

// GetDeviceOptionsWithResponse request returning *GetDeviceOptionsResponse
func (c *ClientWithResponses) GetDeviceOptionsWithResponse(ctx context.Context, params *GetDeviceOptionsParams, reqEditors ...RequestEditorFn) (*GetDeviceOptionsResponse, error) {
	rsp, err := c.GetDeviceOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceOptionsResponse(rsp)
}

// UpdateDeviceOptionsWithBodyWithResponse request with arbitrary body returning *UpdateDeviceOptionsResponse
func (c *ClientWithResponses) UpdateDeviceOptionsWithBodyWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error) {
	rsp, err := c.UpdateDeviceOptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeviceOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeviceOptionsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error) {
	rsp, err := c.UpdateDeviceOptionsWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeviceOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateDeviceOptionsWithResponse(ctx context.Context, params *UpdateDeviceOptionsParams, body UpdateDeviceOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDeviceOptionsResponse, error) {
	rsp, err := c.UpdateDeviceOptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDeviceOptionsResponse(rsp)
}

// GetDisplayPreferencesWithResponse request returning *GetDisplayPreferencesResponse
func (c *ClientWithResponses) GetDisplayPreferencesWithResponse(ctx context.Context, displayPreferencesId string, params *GetDisplayPreferencesParams, reqEditors ...RequestEditorFn) (*GetDisplayPreferencesResponse, error) {
	rsp, err := c.GetDisplayPreferences(ctx, displayPreferencesId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDisplayPreferencesResponse(rsp)
}

// UpdateDisplayPreferencesWithBodyWithResponse request with arbitrary body returning *UpdateDisplayPreferencesResponse
func (c *ClientWithResponses) UpdateDisplayPreferencesWithBodyWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error) {
	rsp, err := c.UpdateDisplayPreferencesWithBody(ctx, displayPreferencesId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDisplayPreferencesResponse(rsp)
}

func (c *ClientWithResponses) UpdateDisplayPreferencesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error) {
	rsp, err := c.UpdateDisplayPreferencesWithApplicationWildcardPlusJSONBody(ctx, displayPreferencesId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDisplayPreferencesResponse(rsp)
}

func (c *ClientWithResponses) UpdateDisplayPreferencesWithResponse(ctx context.Context, displayPreferencesId string, params *UpdateDisplayPreferencesParams, body UpdateDisplayPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDisplayPreferencesResponse, error) {
	rsp, err := c.UpdateDisplayPreferences(ctx, displayPreferencesId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDisplayPreferencesResponse(rsp)
}

// GetProfileInfosWithResponse request returning *GetProfileInfosResponse
func (c *ClientWithResponses) GetProfileInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileInfosResponse, error) {
	rsp, err := c.GetProfileInfos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileInfosResponse(rsp)
}

// CreateProfileWithBodyWithResponse request with arbitrary body returning *CreateProfileResponse
func (c *ClientWithResponses) CreateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error) {
	rsp, err := c.CreateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateProfileWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error) {
	rsp, err := c.CreateProfileWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateProfileWithResponse(ctx context.Context, body CreateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProfileResponse, error) {
	rsp, err := c.CreateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProfileResponse(rsp)
}

// GetDefaultProfileWithResponse request returning *GetDefaultProfileResponse
func (c *ClientWithResponses) GetDefaultProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultProfileResponse, error) {
	rsp, err := c.GetDefaultProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultProfileResponse(rsp)
}

// DeleteProfileWithResponse request returning *DeleteProfileResponse
func (c *ClientWithResponses) DeleteProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*DeleteProfileResponse, error) {
	rsp, err := c.DeleteProfile(ctx, profileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProfileResponse(rsp)
}

// GetProfileWithResponse request returning *GetProfileResponse
func (c *ClientWithResponses) GetProfileWithResponse(ctx context.Context, profileId string, reqEditors ...RequestEditorFn) (*GetProfileResponse, error) {
	rsp, err := c.GetProfile(ctx, profileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileResponse(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, profileId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, profileId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, profileId string, body UpdateProfileApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithApplicationWildcardPlusJSONBody(ctx, profileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, profileId string, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, profileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// GetIconWithResponse request returning *GetIconResponse
func (c *ClientWithResponses) GetIconWithResponse(ctx context.Context, fileName string, reqEditors ...RequestEditorFn) (*GetIconResponse, error) {
	rsp, err := c.GetIcon(ctx, fileName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIconResponse(rsp)
}

// GetConnectionManagerWithResponse request returning *GetConnectionManagerResponse
func (c *ClientWithResponses) GetConnectionManagerWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManagerResponse, error) {
	rsp, err := c.GetConnectionManager(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionManagerResponse(rsp)
}

// GetConnectionManager2WithResponse request returning *GetConnectionManager2Response
func (c *ClientWithResponses) GetConnectionManager2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManager2Response, error) {
	rsp, err := c.GetConnectionManager2(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionManager2Response(rsp)
}

// GetConnectionManager3WithResponse request returning *GetConnectionManager3Response
func (c *ClientWithResponses) GetConnectionManager3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetConnectionManager3Response, error) {
	rsp, err := c.GetConnectionManager3(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionManager3Response(rsp)
}

// ProcessConnectionManagerControlRequestWithResponse request returning *ProcessConnectionManagerControlRequestResponse
func (c *ClientWithResponses) ProcessConnectionManagerControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessConnectionManagerControlRequestResponse, error) {
	rsp, err := c.ProcessConnectionManagerControlRequest(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessConnectionManagerControlRequestResponse(rsp)
}

// GetContentDirectoryWithResponse request returning *GetContentDirectoryResponse
func (c *ClientWithResponses) GetContentDirectoryWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectoryResponse, error) {
	rsp, err := c.GetContentDirectory(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentDirectoryResponse(rsp)
}

// GetContentDirectory2WithResponse request returning *GetContentDirectory2Response
func (c *ClientWithResponses) GetContentDirectory2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectory2Response, error) {
	rsp, err := c.GetContentDirectory2(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentDirectory2Response(rsp)
}

// GetContentDirectory3WithResponse request returning *GetContentDirectory3Response
func (c *ClientWithResponses) GetContentDirectory3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetContentDirectory3Response, error) {
	rsp, err := c.GetContentDirectory3(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContentDirectory3Response(rsp)
}

// ProcessContentDirectoryControlRequestWithResponse request returning *ProcessContentDirectoryControlRequestResponse
func (c *ClientWithResponses) ProcessContentDirectoryControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessContentDirectoryControlRequestResponse, error) {
	rsp, err := c.ProcessContentDirectoryControlRequest(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessContentDirectoryControlRequestResponse(rsp)
}

// GetMediaReceiverRegistrarWithResponse request returning *GetMediaReceiverRegistrarResponse
func (c *ClientWithResponses) GetMediaReceiverRegistrarWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrarResponse, error) {
	rsp, err := c.GetMediaReceiverRegistrar(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaReceiverRegistrarResponse(rsp)
}

// ProcessMediaReceiverRegistrarControlRequestWithResponse request returning *ProcessMediaReceiverRegistrarControlRequestResponse
func (c *ClientWithResponses) ProcessMediaReceiverRegistrarControlRequestWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*ProcessMediaReceiverRegistrarControlRequestResponse, error) {
	rsp, err := c.ProcessMediaReceiverRegistrarControlRequest(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessMediaReceiverRegistrarControlRequestResponse(rsp)
}

// GetMediaReceiverRegistrar2WithResponse request returning *GetMediaReceiverRegistrar2Response
func (c *ClientWithResponses) GetMediaReceiverRegistrar2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrar2Response, error) {
	rsp, err := c.GetMediaReceiverRegistrar2(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaReceiverRegistrar2Response(rsp)
}

// GetMediaReceiverRegistrar3WithResponse request returning *GetMediaReceiverRegistrar3Response
func (c *ClientWithResponses) GetMediaReceiverRegistrar3WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetMediaReceiverRegistrar3Response, error) {
	rsp, err := c.GetMediaReceiverRegistrar3(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaReceiverRegistrar3Response(rsp)
}

// GetDescriptionXmlWithResponse request returning *GetDescriptionXmlResponse
func (c *ClientWithResponses) GetDescriptionXmlWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetDescriptionXmlResponse, error) {
	rsp, err := c.GetDescriptionXml(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDescriptionXmlResponse(rsp)
}

// GetDescriptionXml2WithResponse request returning *GetDescriptionXml2Response
func (c *ClientWithResponses) GetDescriptionXml2WithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetDescriptionXml2Response, error) {
	rsp, err := c.GetDescriptionXml2(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDescriptionXml2Response(rsp)
}

// GetIconIdWithResponse request returning *GetIconIdResponse
func (c *ClientWithResponses) GetIconIdWithResponse(ctx context.Context, serverId string, fileName string, reqEditors ...RequestEditorFn) (*GetIconIdResponse, error) {
	rsp, err := c.GetIconId(ctx, serverId, fileName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIconIdResponse(rsp)
}

// GetDefaultDirectoryBrowserWithResponse request returning *GetDefaultDirectoryBrowserResponse
func (c *ClientWithResponses) GetDefaultDirectoryBrowserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultDirectoryBrowserResponse, error) {
	rsp, err := c.GetDefaultDirectoryBrowser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultDirectoryBrowserResponse(rsp)
}

// GetDirectoryContentsWithResponse request returning *GetDirectoryContentsResponse
func (c *ClientWithResponses) GetDirectoryContentsWithResponse(ctx context.Context, params *GetDirectoryContentsParams, reqEditors ...RequestEditorFn) (*GetDirectoryContentsResponse, error) {
	rsp, err := c.GetDirectoryContents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDirectoryContentsResponse(rsp)
}

// GetDrivesWithResponse request returning *GetDrivesResponse
func (c *ClientWithResponses) GetDrivesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDrivesResponse, error) {
	rsp, err := c.GetDrives(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDrivesResponse(rsp)
}

// GetNetworkSharesWithResponse request returning *GetNetworkSharesResponse
func (c *ClientWithResponses) GetNetworkSharesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNetworkSharesResponse, error) {
	rsp, err := c.GetNetworkShares(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkSharesResponse(rsp)
}

// GetParentPathWithResponse request returning *GetParentPathResponse
func (c *ClientWithResponses) GetParentPathWithResponse(ctx context.Context, params *GetParentPathParams, reqEditors ...RequestEditorFn) (*GetParentPathResponse, error) {
	rsp, err := c.GetParentPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParentPathResponse(rsp)
}

// ValidatePathWithBodyWithResponse request with arbitrary body returning *ValidatePathResponse
func (c *ClientWithResponses) ValidatePathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error) {
	rsp, err := c.ValidatePathWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePathResponse(rsp)
}

func (c *ClientWithResponses) ValidatePathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ValidatePathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error) {
	rsp, err := c.ValidatePathWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePathResponse(rsp)
}

func (c *ClientWithResponses) ValidatePathWithResponse(ctx context.Context, body ValidatePathJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePathResponse, error) {
	rsp, err := c.ValidatePath(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePathResponse(rsp)
}

// GetFallbackFontListWithResponse request returning *GetFallbackFontListResponse
func (c *ClientWithResponses) GetFallbackFontListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFallbackFontListResponse, error) {
	rsp, err := c.GetFallbackFontList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFallbackFontListResponse(rsp)
}

// GetFallbackFontWithResponse request returning *GetFallbackFontResponse
func (c *ClientWithResponses) GetFallbackFontWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetFallbackFontResponse, error) {
	rsp, err := c.GetFallbackFont(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFallbackFontResponse(rsp)
}

// GetGenresWithResponse request returning *GetGenresResponse
func (c *ClientWithResponses) GetGenresWithResponse(ctx context.Context, params *GetGenresParams, reqEditors ...RequestEditorFn) (*GetGenresResponse, error) {
	rsp, err := c.GetGenres(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenresResponse(rsp)
}

// GetGenreWithResponse request returning *GetGenreResponse
func (c *ClientWithResponses) GetGenreWithResponse(ctx context.Context, genreName string, params *GetGenreParams, reqEditors ...RequestEditorFn) (*GetGenreResponse, error) {
	rsp, err := c.GetGenre(ctx, genreName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenreResponse(rsp)
}

// GetGenreImageWithResponse request returning *GetGenreImageResponse
func (c *ClientWithResponses) GetGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetGenreImageParams, reqEditors ...RequestEditorFn) (*GetGenreImageResponse, error) {
	rsp, err := c.GetGenreImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenreImageResponse(rsp)
}

// HeadGenreImageWithResponse request returning *HeadGenreImageResponse
func (c *ClientWithResponses) HeadGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadGenreImageParams, reqEditors ...RequestEditorFn) (*HeadGenreImageResponse, error) {
	rsp, err := c.HeadGenreImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadGenreImageResponse(rsp)
}

// GetGenreImageByIndexWithResponse request returning *GetGenreImageByIndexResponse
func (c *ClientWithResponses) GetGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*GetGenreImageByIndexResponse, error) {
	rsp, err := c.GetGenreImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenreImageByIndexResponse(rsp)
}

// HeadGenreImageByIndexWithResponse request returning *HeadGenreImageByIndexResponse
func (c *ClientWithResponses) HeadGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadGenreImageByIndexResponse, error) {
	rsp, err := c.HeadGenreImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadGenreImageByIndexResponse(rsp)
}

// GetUtcTimeWithResponse request returning *GetUtcTimeResponse
func (c *ClientWithResponses) GetUtcTimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtcTimeResponse, error) {
	rsp, err := c.GetUtcTime(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUtcTimeResponse(rsp)
}

// GetGeneralImagesWithResponse request returning *GetGeneralImagesResponse
func (c *ClientWithResponses) GetGeneralImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGeneralImagesResponse, error) {
	rsp, err := c.GetGeneralImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGeneralImagesResponse(rsp)
}

// GetGeneralImageWithResponse request returning *GetGeneralImageResponse
func (c *ClientWithResponses) GetGeneralImageWithResponse(ctx context.Context, name string, pType string, reqEditors ...RequestEditorFn) (*GetGeneralImageResponse, error) {
	rsp, err := c.GetGeneralImage(ctx, name, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGeneralImageResponse(rsp)
}

// GetMediaInfoImagesWithResponse request returning *GetMediaInfoImagesResponse
func (c *ClientWithResponses) GetMediaInfoImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMediaInfoImagesResponse, error) {
	rsp, err := c.GetMediaInfoImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaInfoImagesResponse(rsp)
}

// GetMediaInfoImageWithResponse request returning *GetMediaInfoImageResponse
func (c *ClientWithResponses) GetMediaInfoImageWithResponse(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*GetMediaInfoImageResponse, error) {
	rsp, err := c.GetMediaInfoImage(ctx, theme, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaInfoImageResponse(rsp)
}

// GetRatingImagesWithResponse request returning *GetRatingImagesResponse
func (c *ClientWithResponses) GetRatingImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRatingImagesResponse, error) {
	rsp, err := c.GetRatingImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRatingImagesResponse(rsp)
}

// GetRatingImageWithResponse request returning *GetRatingImageResponse
func (c *ClientWithResponses) GetRatingImageWithResponse(ctx context.Context, theme string, name string, reqEditors ...RequestEditorFn) (*GetRatingImageResponse, error) {
	rsp, err := c.GetRatingImage(ctx, theme, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRatingImageResponse(rsp)
}

// DeleteItemsWithResponse request returning *DeleteItemsResponse
func (c *ClientWithResponses) DeleteItemsWithResponse(ctx context.Context, params *DeleteItemsParams, reqEditors ...RequestEditorFn) (*DeleteItemsResponse, error) {
	rsp, err := c.DeleteItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemsResponse(rsp)
}

// GetItemsWithResponse request returning *GetItemsResponse
func (c *ClientWithResponses) GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error) {
	rsp, err := c.GetItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsResponse(rsp)
}

// GetItemCountsWithResponse request returning *GetItemCountsResponse
func (c *ClientWithResponses) GetItemCountsWithResponse(ctx context.Context, params *GetItemCountsParams, reqEditors ...RequestEditorFn) (*GetItemCountsResponse, error) {
	rsp, err := c.GetItemCounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemCountsResponse(rsp)
}

// GetQueryFiltersLegacyWithResponse request returning *GetQueryFiltersLegacyResponse
func (c *ClientWithResponses) GetQueryFiltersLegacyWithResponse(ctx context.Context, params *GetQueryFiltersLegacyParams, reqEditors ...RequestEditorFn) (*GetQueryFiltersLegacyResponse, error) {
	rsp, err := c.GetQueryFiltersLegacy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueryFiltersLegacyResponse(rsp)
}

// GetQueryFiltersWithResponse request returning *GetQueryFiltersResponse
func (c *ClientWithResponses) GetQueryFiltersWithResponse(ctx context.Context, params *GetQueryFiltersParams, reqEditors ...RequestEditorFn) (*GetQueryFiltersResponse, error) {
	rsp, err := c.GetQueryFilters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueryFiltersResponse(rsp)
}

// ApplySearchCriteriaWithBodyWithResponse request with arbitrary body returning *ApplySearchCriteriaResponse
func (c *ClientWithResponses) ApplySearchCriteriaWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error) {
	rsp, err := c.ApplySearchCriteriaWithBody(ctx, itemId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplySearchCriteriaResponse(rsp)
}

func (c *ClientWithResponses) ApplySearchCriteriaWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error) {
	rsp, err := c.ApplySearchCriteriaWithApplicationWildcardPlusJSONBody(ctx, itemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplySearchCriteriaResponse(rsp)
}

func (c *ClientWithResponses) ApplySearchCriteriaWithResponse(ctx context.Context, itemId openapi_types.UUID, params *ApplySearchCriteriaParams, body ApplySearchCriteriaJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplySearchCriteriaResponse, error) {
	rsp, err := c.ApplySearchCriteria(ctx, itemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplySearchCriteriaResponse(rsp)
}

// GetBookRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetBookRemoteSearchResultsResponse
func (c *ClientWithResponses) GetBookRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBookRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetBookRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetBookRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBookRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetBookRemoteSearchResultsWithResponse(ctx context.Context, body GetBookRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBookRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBookRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookRemoteSearchResultsResponse(rsp)
}

// GetBoxSetRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetBoxSetRemoteSearchResultsResponse
func (c *ClientWithResponses) GetBoxSetRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBoxSetRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBoxSetRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetBoxSetRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetBoxSetRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBoxSetRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBoxSetRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetBoxSetRemoteSearchResultsWithResponse(ctx context.Context, body GetBoxSetRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBoxSetRemoteSearchResultsResponse, error) {
	rsp, err := c.GetBoxSetRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBoxSetRemoteSearchResultsResponse(rsp)
}

// GetMovieRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetMovieRemoteSearchResultsResponse
func (c *ClientWithResponses) GetMovieRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMovieRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMovieRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMovieRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMovieRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMovieRemoteSearchResultsWithResponse(ctx context.Context, body GetMovieRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMovieRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMovieRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieRemoteSearchResultsResponse(rsp)
}

// GetMusicAlbumRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetMusicAlbumRemoteSearchResultsResponse
func (c *ClientWithResponses) GetMusicAlbumRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicAlbumRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicAlbumRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicAlbumRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicAlbumRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicAlbumRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicAlbumRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicAlbumRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicAlbumRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicAlbumRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicAlbumRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicAlbumRemoteSearchResultsResponse(rsp)
}

// GetMusicArtistRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetMusicArtistRemoteSearchResultsResponse
func (c *ClientWithResponses) GetMusicArtistRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicArtistRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicArtistRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicArtistRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicArtistRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicArtistRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicArtistRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicArtistRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicArtistRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicArtistRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicArtistRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicArtistRemoteSearchResultsResponse(rsp)
}

// GetMusicVideoRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetMusicVideoRemoteSearchResultsResponse
func (c *ClientWithResponses) GetMusicVideoRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicVideoRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicVideoRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicVideoRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetMusicVideoRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicVideoRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicVideoRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetMusicVideoRemoteSearchResultsWithResponse(ctx context.Context, body GetMusicVideoRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetMusicVideoRemoteSearchResultsResponse, error) {
	rsp, err := c.GetMusicVideoRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicVideoRemoteSearchResultsResponse(rsp)
}

// GetPersonRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetPersonRemoteSearchResultsResponse
func (c *ClientWithResponses) GetPersonRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error) {
	rsp, err := c.GetPersonRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetPersonRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetPersonRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error) {
	rsp, err := c.GetPersonRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetPersonRemoteSearchResultsWithResponse(ctx context.Context, body GetPersonRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPersonRemoteSearchResultsResponse, error) {
	rsp, err := c.GetPersonRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonRemoteSearchResultsResponse(rsp)
}

// GetSeriesRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetSeriesRemoteSearchResultsResponse
func (c *ClientWithResponses) GetSeriesRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error) {
	rsp, err := c.GetSeriesRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetSeriesRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetSeriesRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error) {
	rsp, err := c.GetSeriesRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetSeriesRemoteSearchResultsWithResponse(ctx context.Context, body GetSeriesRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSeriesRemoteSearchResultsResponse, error) {
	rsp, err := c.GetSeriesRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesRemoteSearchResultsResponse(rsp)
}

// GetTrailerRemoteSearchResultsWithBodyWithResponse request with arbitrary body returning *GetTrailerRemoteSearchResultsResponse
func (c *ClientWithResponses) GetTrailerRemoteSearchResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error) {
	rsp, err := c.GetTrailerRemoteSearchResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrailerRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetTrailerRemoteSearchResultsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetTrailerRemoteSearchResultsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error) {
	rsp, err := c.GetTrailerRemoteSearchResultsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrailerRemoteSearchResultsResponse(rsp)
}

func (c *ClientWithResponses) GetTrailerRemoteSearchResultsWithResponse(ctx context.Context, body GetTrailerRemoteSearchResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTrailerRemoteSearchResultsResponse, error) {
	rsp, err := c.GetTrailerRemoteSearchResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrailerRemoteSearchResultsResponse(rsp)
}

// GetInstantMixFromItemWithResponse request returning *GetInstantMixFromItemResponse
func (c *ClientWithResponses) GetInstantMixFromItemWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromItemParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromItemResponse, error) {
	rsp, err := c.GetInstantMixFromItem(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromItemResponse(rsp)
}

// DeleteItemWithResponse request returning *DeleteItemResponse
func (c *ClientWithResponses) DeleteItemWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteItemResponse, error) {
	rsp, err := c.DeleteItem(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemResponse(rsp)
}

// UpdateItemWithBodyWithResponse request with arbitrary body returning *UpdateItemResponse
func (c *ClientWithResponses) UpdateItemWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error) {
	rsp, err := c.UpdateItemWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemResponse(rsp)
}

func (c *ClientWithResponses) UpdateItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, body UpdateItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error) {
	rsp, err := c.UpdateItemWithApplicationWildcardPlusJSONBody(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemResponse(rsp)
}

func (c *ClientWithResponses) UpdateItemWithResponse(ctx context.Context, itemId openapi_types.UUID, body UpdateItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemResponse, error) {
	rsp, err := c.UpdateItem(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemResponse(rsp)
}

// GetAncestorsWithResponse request returning *GetAncestorsResponse
func (c *ClientWithResponses) GetAncestorsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAncestorsParams, reqEditors ...RequestEditorFn) (*GetAncestorsResponse, error) {
	rsp, err := c.GetAncestors(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAncestorsResponse(rsp)
}

// UpdateItemContentTypeWithResponse request returning *UpdateItemContentTypeResponse
func (c *ClientWithResponses) UpdateItemContentTypeWithResponse(ctx context.Context, itemId openapi_types.UUID, params *UpdateItemContentTypeParams, reqEditors ...RequestEditorFn) (*UpdateItemContentTypeResponse, error) {
	rsp, err := c.UpdateItemContentType(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemContentTypeResponse(rsp)
}

// GetCriticReviewsWithResponse request returning *GetCriticReviewsResponse
func (c *ClientWithResponses) GetCriticReviewsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetCriticReviewsResponse, error) {
	rsp, err := c.GetCriticReviews(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCriticReviewsResponse(rsp)
}

// GetDownloadWithResponse request returning *GetDownloadResponse
func (c *ClientWithResponses) GetDownloadWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDownloadResponse, error) {
	rsp, err := c.GetDownload(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDownloadResponse(rsp)
}

// GetExternalIdInfosWithResponse request returning *GetExternalIdInfosResponse
func (c *ClientWithResponses) GetExternalIdInfosWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExternalIdInfosResponse, error) {
	rsp, err := c.GetExternalIdInfos(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalIdInfosResponse(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// GetItemImageInfosWithResponse request returning *GetItemImageInfosResponse
func (c *ClientWithResponses) GetItemImageInfosWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemImageInfosResponse, error) {
	rsp, err := c.GetItemImageInfos(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemImageInfosResponse(rsp)
}

// DeleteItemImageWithResponse request returning *DeleteItemImageResponse
func (c *ClientWithResponses) DeleteItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *DeleteItemImageParams, reqEditors ...RequestEditorFn) (*DeleteItemImageResponse, error) {
	rsp, err := c.DeleteItemImage(ctx, itemId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemImageResponse(rsp)
}

// GetItemImageWithResponse request returning *GetItemImageResponse
func (c *ClientWithResponses) GetItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *GetItemImageParams, reqEditors ...RequestEditorFn) (*GetItemImageResponse, error) {
	rsp, err := c.GetItemImage(ctx, itemId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemImageResponse(rsp)
}

// HeadItemImageWithResponse request returning *HeadItemImageResponse
func (c *ClientWithResponses) HeadItemImageWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, params *HeadItemImageParams, reqEditors ...RequestEditorFn) (*HeadItemImageResponse, error) {
	rsp, err := c.HeadItemImage(ctx, itemId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadItemImageResponse(rsp)
}

// SetItemImageWithBodyWithResponse request with arbitrary body returning *SetItemImageResponse
func (c *ClientWithResponses) SetItemImageWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetItemImageResponse, error) {
	rsp, err := c.SetItemImageWithBody(ctx, itemId, imageType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetItemImageResponse(rsp)
}

// DeleteItemImageByIndexWithResponse request returning *DeleteItemImageByIndexResponse
func (c *ClientWithResponses) DeleteItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, reqEditors ...RequestEditorFn) (*DeleteItemImageByIndexResponse, error) {
	rsp, err := c.DeleteItemImageByIndex(ctx, itemId, imageType, imageIndex, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemImageByIndexResponse(rsp)
}

// GetItemImageByIndexWithResponse request returning *GetItemImageByIndexResponse
func (c *ClientWithResponses) GetItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetItemImageByIndexParams, reqEditors ...RequestEditorFn) (*GetItemImageByIndexResponse, error) {
	rsp, err := c.GetItemImageByIndex(ctx, itemId, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemImageByIndexResponse(rsp)
}

// HeadItemImageByIndexWithResponse request returning *HeadItemImageByIndexResponse
func (c *ClientWithResponses) HeadItemImageByIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadItemImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadItemImageByIndexResponse, error) {
	rsp, err := c.HeadItemImageByIndex(ctx, itemId, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadItemImageByIndexResponse(rsp)
}

// SetItemImageByIndexWithBodyWithResponse request with arbitrary body returning *SetItemImageByIndexResponse
func (c *ClientWithResponses) SetItemImageByIndexWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetItemImageByIndexResponse, error) {
	rsp, err := c.SetItemImageByIndexWithBody(ctx, itemId, imageType, imageIndex, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetItemImageByIndexResponse(rsp)
}

// UpdateItemImageIndexWithResponse request returning *UpdateItemImageIndexResponse
func (c *ClientWithResponses) UpdateItemImageIndexWithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, params *UpdateItemImageIndexParams, reqEditors ...RequestEditorFn) (*UpdateItemImageIndexResponse, error) {
	rsp, err := c.UpdateItemImageIndex(ctx, itemId, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemImageIndexResponse(rsp)
}

// GetItemImage2WithResponse request returning *GetItemImage2Response
func (c *ClientWithResponses) GetItemImage2WithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *GetItemImage2Params, reqEditors ...RequestEditorFn) (*GetItemImage2Response, error) {
	rsp, err := c.GetItemImage2(ctx, itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemImage2Response(rsp)
}

// HeadItemImage2WithResponse request returning *HeadItemImage2Response
func (c *ClientWithResponses) HeadItemImage2WithResponse(ctx context.Context, itemId openapi_types.UUID, imageType ImageType, imageIndex int32, tag string, format ImageFormat, maxWidth int32, maxHeight int32, percentPlayed float64, unplayedCount int32, params *HeadItemImage2Params, reqEditors ...RequestEditorFn) (*HeadItemImage2Response, error) {
	rsp, err := c.HeadItemImage2(ctx, itemId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadItemImage2Response(rsp)
}

// GetMetadataEditorInfoWithResponse request returning *GetMetadataEditorInfoResponse
func (c *ClientWithResponses) GetMetadataEditorInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMetadataEditorInfoResponse, error) {
	rsp, err := c.GetMetadataEditorInfo(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetadataEditorInfoResponse(rsp)
}

// GetPlaybackInfoWithResponse request returning *GetPlaybackInfoResponse
func (c *ClientWithResponses) GetPlaybackInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPlaybackInfoParams, reqEditors ...RequestEditorFn) (*GetPlaybackInfoResponse, error) {
	rsp, err := c.GetPlaybackInfo(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaybackInfoResponse(rsp)
}

// GetPostedPlaybackInfoWithBodyWithResponse request with arbitrary body returning *GetPostedPlaybackInfoResponse
func (c *ClientWithResponses) GetPostedPlaybackInfoWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error) {
	rsp, err := c.GetPostedPlaybackInfoWithBody(ctx, itemId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostedPlaybackInfoResponse(rsp)
}

func (c *ClientWithResponses) GetPostedPlaybackInfoWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error) {
	rsp, err := c.GetPostedPlaybackInfoWithApplicationWildcardPlusJSONBody(ctx, itemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostedPlaybackInfoResponse(rsp)
}

func (c *ClientWithResponses) GetPostedPlaybackInfoWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetPostedPlaybackInfoParams, body GetPostedPlaybackInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPostedPlaybackInfoResponse, error) {
	rsp, err := c.GetPostedPlaybackInfo(ctx, itemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostedPlaybackInfoResponse(rsp)
}

// RefreshItemWithResponse request returning *RefreshItemResponse
func (c *ClientWithResponses) RefreshItemWithResponse(ctx context.Context, itemId openapi_types.UUID, params *RefreshItemParams, reqEditors ...RequestEditorFn) (*RefreshItemResponse, error) {
	rsp, err := c.RefreshItem(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshItemResponse(rsp)
}

// GetRemoteImagesWithResponse request returning *GetRemoteImagesResponse
func (c *ClientWithResponses) GetRemoteImagesWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetRemoteImagesParams, reqEditors ...RequestEditorFn) (*GetRemoteImagesResponse, error) {
	rsp, err := c.GetRemoteImages(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteImagesResponse(rsp)
}

// DownloadRemoteImageWithResponse request returning *DownloadRemoteImageResponse
func (c *ClientWithResponses) DownloadRemoteImageWithResponse(ctx context.Context, itemId openapi_types.UUID, params *DownloadRemoteImageParams, reqEditors ...RequestEditorFn) (*DownloadRemoteImageResponse, error) {
	rsp, err := c.DownloadRemoteImage(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadRemoteImageResponse(rsp)
}

// GetRemoteImageProvidersWithResponse request returning *GetRemoteImageProvidersResponse
func (c *ClientWithResponses) GetRemoteImageProvidersWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRemoteImageProvidersResponse, error) {
	rsp, err := c.GetRemoteImageProviders(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteImageProvidersResponse(rsp)
}

// SearchRemoteSubtitlesWithResponse request returning *SearchRemoteSubtitlesResponse
func (c *ClientWithResponses) SearchRemoteSubtitlesWithResponse(ctx context.Context, itemId openapi_types.UUID, language string, params *SearchRemoteSubtitlesParams, reqEditors ...RequestEditorFn) (*SearchRemoteSubtitlesResponse, error) {
	rsp, err := c.SearchRemoteSubtitles(ctx, itemId, language, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRemoteSubtitlesResponse(rsp)
}

// DownloadRemoteSubtitlesWithResponse request returning *DownloadRemoteSubtitlesResponse
func (c *ClientWithResponses) DownloadRemoteSubtitlesWithResponse(ctx context.Context, itemId openapi_types.UUID, subtitleId string, reqEditors ...RequestEditorFn) (*DownloadRemoteSubtitlesResponse, error) {
	rsp, err := c.DownloadRemoteSubtitles(ctx, itemId, subtitleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadRemoteSubtitlesResponse(rsp)
}

// GetSimilarItemsWithResponse request returning *GetSimilarItemsResponse
func (c *ClientWithResponses) GetSimilarItemsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarItemsParams, reqEditors ...RequestEditorFn) (*GetSimilarItemsResponse, error) {
	rsp, err := c.GetSimilarItems(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarItemsResponse(rsp)
}

// GetThemeMediaWithResponse request returning *GetThemeMediaResponse
func (c *ClientWithResponses) GetThemeMediaWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeMediaParams, reqEditors ...RequestEditorFn) (*GetThemeMediaResponse, error) {
	rsp, err := c.GetThemeMedia(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThemeMediaResponse(rsp)
}

// GetThemeSongsWithResponse request returning *GetThemeSongsResponse
func (c *ClientWithResponses) GetThemeSongsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeSongsParams, reqEditors ...RequestEditorFn) (*GetThemeSongsResponse, error) {
	rsp, err := c.GetThemeSongs(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThemeSongsResponse(rsp)
}

// GetThemeVideosWithResponse request returning *GetThemeVideosResponse
func (c *ClientWithResponses) GetThemeVideosWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetThemeVideosParams, reqEditors ...RequestEditorFn) (*GetThemeVideosResponse, error) {
	rsp, err := c.GetThemeVideos(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThemeVideosResponse(rsp)
}

// ValidateLoginInfoWithBodyWithResponse request with arbitrary body returning *ValidateLoginInfoResponse
func (c *ClientWithResponses) ValidateLoginInfoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error) {
	rsp, err := c.ValidateLoginInfoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateLoginInfoResponse(rsp)
}

func (c *ClientWithResponses) ValidateLoginInfoWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ValidateLoginInfoApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error) {
	rsp, err := c.ValidateLoginInfoWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateLoginInfoResponse(rsp)
}

func (c *ClientWithResponses) ValidateLoginInfoWithResponse(ctx context.Context, body ValidateLoginInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateLoginInfoResponse, error) {
	rsp, err := c.ValidateLoginInfo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateLoginInfoResponse(rsp)
}

// GetLibraryOptionsInfoWithResponse request returning *GetLibraryOptionsInfoResponse
func (c *ClientWithResponses) GetLibraryOptionsInfoWithResponse(ctx context.Context, params *GetLibraryOptionsInfoParams, reqEditors ...RequestEditorFn) (*GetLibraryOptionsInfoResponse, error) {
	rsp, err := c.GetLibraryOptionsInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLibraryOptionsInfoResponse(rsp)
}

// PostUpdatedMediaWithBodyWithResponse request with arbitrary body returning *PostUpdatedMediaResponse
func (c *ClientWithResponses) PostUpdatedMediaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error) {
	rsp, err := c.PostUpdatedMediaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUpdatedMediaResponse(rsp)
}

func (c *ClientWithResponses) PostUpdatedMediaWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body PostUpdatedMediaApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error) {
	rsp, err := c.PostUpdatedMediaWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUpdatedMediaResponse(rsp)
}

func (c *ClientWithResponses) PostUpdatedMediaWithResponse(ctx context.Context, body PostUpdatedMediaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUpdatedMediaResponse, error) {
	rsp, err := c.PostUpdatedMedia(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUpdatedMediaResponse(rsp)
}

// GetMediaFoldersWithResponse request returning *GetMediaFoldersResponse
func (c *ClientWithResponses) GetMediaFoldersWithResponse(ctx context.Context, params *GetMediaFoldersParams, reqEditors ...RequestEditorFn) (*GetMediaFoldersResponse, error) {
	rsp, err := c.GetMediaFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMediaFoldersResponse(rsp)
}

// PostAddedMoviesWithResponse request returning *PostAddedMoviesResponse
func (c *ClientWithResponses) PostAddedMoviesWithResponse(ctx context.Context, params *PostAddedMoviesParams, reqEditors ...RequestEditorFn) (*PostAddedMoviesResponse, error) {
	rsp, err := c.PostAddedMovies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAddedMoviesResponse(rsp)
}

// PostUpdatedMoviesWithResponse request returning *PostUpdatedMoviesResponse
func (c *ClientWithResponses) PostUpdatedMoviesWithResponse(ctx context.Context, params *PostUpdatedMoviesParams, reqEditors ...RequestEditorFn) (*PostUpdatedMoviesResponse, error) {
	rsp, err := c.PostUpdatedMovies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUpdatedMoviesResponse(rsp)
}

// GetPhysicalPathsWithResponse request returning *GetPhysicalPathsResponse
func (c *ClientWithResponses) GetPhysicalPathsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPhysicalPathsResponse, error) {
	rsp, err := c.GetPhysicalPaths(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalPathsResponse(rsp)
}

// RefreshLibraryWithResponse request returning *RefreshLibraryResponse
func (c *ClientWithResponses) RefreshLibraryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshLibraryResponse, error) {
	rsp, err := c.RefreshLibrary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshLibraryResponse(rsp)
}

// PostAddedSeriesWithResponse request returning *PostAddedSeriesResponse
func (c *ClientWithResponses) PostAddedSeriesWithResponse(ctx context.Context, params *PostAddedSeriesParams, reqEditors ...RequestEditorFn) (*PostAddedSeriesResponse, error) {
	rsp, err := c.PostAddedSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAddedSeriesResponse(rsp)
}

// PostUpdatedSeriesWithResponse request returning *PostUpdatedSeriesResponse
func (c *ClientWithResponses) PostUpdatedSeriesWithResponse(ctx context.Context, params *PostUpdatedSeriesParams, reqEditors ...RequestEditorFn) (*PostUpdatedSeriesResponse, error) {
	rsp, err := c.PostUpdatedSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUpdatedSeriesResponse(rsp)
}

// RemoveVirtualFolderWithResponse request returning *RemoveVirtualFolderResponse
func (c *ClientWithResponses) RemoveVirtualFolderWithResponse(ctx context.Context, params *RemoveVirtualFolderParams, reqEditors ...RequestEditorFn) (*RemoveVirtualFolderResponse, error) {
	rsp, err := c.RemoveVirtualFolder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveVirtualFolderResponse(rsp)
}

// GetVirtualFoldersWithResponse request returning *GetVirtualFoldersResponse
func (c *ClientWithResponses) GetVirtualFoldersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVirtualFoldersResponse, error) {
	rsp, err := c.GetVirtualFolders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualFoldersResponse(rsp)
}

// AddVirtualFolderWithBodyWithResponse request with arbitrary body returning *AddVirtualFolderResponse
func (c *ClientWithResponses) AddVirtualFolderWithBodyWithResponse(ctx context.Context, params *AddVirtualFolderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error) {
	rsp, err := c.AddVirtualFolderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualFolderResponse(rsp)
}

func (c *ClientWithResponses) AddVirtualFolderWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error) {
	rsp, err := c.AddVirtualFolderWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualFolderResponse(rsp)
}

func (c *ClientWithResponses) AddVirtualFolderWithResponse(ctx context.Context, params *AddVirtualFolderParams, body AddVirtualFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualFolderResponse, error) {
	rsp, err := c.AddVirtualFolder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualFolderResponse(rsp)
}

// UpdateLibraryOptionsWithBodyWithResponse request with arbitrary body returning *UpdateLibraryOptionsResponse
func (c *ClientWithResponses) UpdateLibraryOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error) {
	rsp, err := c.UpdateLibraryOptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLibraryOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateLibraryOptionsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateLibraryOptionsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error) {
	rsp, err := c.UpdateLibraryOptionsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLibraryOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateLibraryOptionsWithResponse(ctx context.Context, body UpdateLibraryOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLibraryOptionsResponse, error) {
	rsp, err := c.UpdateLibraryOptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLibraryOptionsResponse(rsp)
}

// RenameVirtualFolderWithResponse request returning *RenameVirtualFolderResponse
func (c *ClientWithResponses) RenameVirtualFolderWithResponse(ctx context.Context, params *RenameVirtualFolderParams, reqEditors ...RequestEditorFn) (*RenameVirtualFolderResponse, error) {
	rsp, err := c.RenameVirtualFolder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameVirtualFolderResponse(rsp)
}

// RemoveMediaPathWithResponse request returning *RemoveMediaPathResponse
func (c *ClientWithResponses) RemoveMediaPathWithResponse(ctx context.Context, params *RemoveMediaPathParams, reqEditors ...RequestEditorFn) (*RemoveMediaPathResponse, error) {
	rsp, err := c.RemoveMediaPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMediaPathResponse(rsp)
}

// AddMediaPathWithBodyWithResponse request with arbitrary body returning *AddMediaPathResponse
func (c *ClientWithResponses) AddMediaPathWithBodyWithResponse(ctx context.Context, params *AddMediaPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error) {
	rsp, err := c.AddMediaPathWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMediaPathResponse(rsp)
}

func (c *ClientWithResponses) AddMediaPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddMediaPathParams, body AddMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error) {
	rsp, err := c.AddMediaPathWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMediaPathResponse(rsp)
}

func (c *ClientWithResponses) AddMediaPathWithResponse(ctx context.Context, params *AddMediaPathParams, body AddMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMediaPathResponse, error) {
	rsp, err := c.AddMediaPath(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMediaPathResponse(rsp)
}

// UpdateMediaPathWithBodyWithResponse request with arbitrary body returning *UpdateMediaPathResponse
func (c *ClientWithResponses) UpdateMediaPathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error) {
	rsp, err := c.UpdateMediaPathWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaPathResponse(rsp)
}

func (c *ClientWithResponses) UpdateMediaPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateMediaPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error) {
	rsp, err := c.UpdateMediaPathWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaPathResponse(rsp)
}

func (c *ClientWithResponses) UpdateMediaPathWithResponse(ctx context.Context, body UpdateMediaPathJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaPathResponse, error) {
	rsp, err := c.UpdateMediaPath(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaPathResponse(rsp)
}

// CloseLiveStreamWithResponse request returning *CloseLiveStreamResponse
func (c *ClientWithResponses) CloseLiveStreamWithResponse(ctx context.Context, params *CloseLiveStreamParams, reqEditors ...RequestEditorFn) (*CloseLiveStreamResponse, error) {
	rsp, err := c.CloseLiveStream(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseLiveStreamResponse(rsp)
}

// OpenLiveStreamWithBodyWithResponse request with arbitrary body returning *OpenLiveStreamResponse
func (c *ClientWithResponses) OpenLiveStreamWithBodyWithResponse(ctx context.Context, params *OpenLiveStreamParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error) {
	rsp, err := c.OpenLiveStreamWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenLiveStreamResponse(rsp)
}

func (c *ClientWithResponses) OpenLiveStreamWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error) {
	rsp, err := c.OpenLiveStreamWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenLiveStreamResponse(rsp)
}

func (c *ClientWithResponses) OpenLiveStreamWithResponse(ctx context.Context, params *OpenLiveStreamParams, body OpenLiveStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*OpenLiveStreamResponse, error) {
	rsp, err := c.OpenLiveStream(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenLiveStreamResponse(rsp)
}

// GetChannelMappingOptionsWithResponse request returning *GetChannelMappingOptionsResponse
func (c *ClientWithResponses) GetChannelMappingOptionsWithResponse(ctx context.Context, params *GetChannelMappingOptionsParams, reqEditors ...RequestEditorFn) (*GetChannelMappingOptionsResponse, error) {
	rsp, err := c.GetChannelMappingOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelMappingOptionsResponse(rsp)
}

// SetChannelMappingWithBodyWithResponse request with arbitrary body returning *SetChannelMappingResponse
func (c *ClientWithResponses) SetChannelMappingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error) {
	rsp, err := c.SetChannelMappingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetChannelMappingResponse(rsp)
}

func (c *ClientWithResponses) SetChannelMappingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetChannelMappingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error) {
	rsp, err := c.SetChannelMappingWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetChannelMappingResponse(rsp)
}

func (c *ClientWithResponses) SetChannelMappingWithResponse(ctx context.Context, body SetChannelMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetChannelMappingResponse, error) {
	rsp, err := c.SetChannelMapping(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetChannelMappingResponse(rsp)
}

// GetLiveTvChannelsWithResponse request returning *GetLiveTvChannelsResponse
func (c *ClientWithResponses) GetLiveTvChannelsWithResponse(ctx context.Context, params *GetLiveTvChannelsParams, reqEditors ...RequestEditorFn) (*GetLiveTvChannelsResponse, error) {
	rsp, err := c.GetLiveTvChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveTvChannelsResponse(rsp)
}

// GetChannelWithResponse request returning *GetChannelResponse
func (c *ClientWithResponses) GetChannelWithResponse(ctx context.Context, channelId openapi_types.UUID, params *GetChannelParams, reqEditors ...RequestEditorFn) (*GetChannelResponse, error) {
	rsp, err := c.GetChannel(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelResponse(rsp)
}

// GetGuideInfoWithResponse request returning *GetGuideInfoResponse
func (c *ClientWithResponses) GetGuideInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGuideInfoResponse, error) {
	rsp, err := c.GetGuideInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGuideInfoResponse(rsp)
}

// GetLiveTvInfoWithResponse request returning *GetLiveTvInfoResponse
func (c *ClientWithResponses) GetLiveTvInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveTvInfoResponse, error) {
	rsp, err := c.GetLiveTvInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveTvInfoResponse(rsp)
}

// DeleteListingProviderWithResponse request returning *DeleteListingProviderResponse
func (c *ClientWithResponses) DeleteListingProviderWithResponse(ctx context.Context, params *DeleteListingProviderParams, reqEditors ...RequestEditorFn) (*DeleteListingProviderResponse, error) {
	rsp, err := c.DeleteListingProvider(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListingProviderResponse(rsp)
}

// AddListingProviderWithBodyWithResponse request with arbitrary body returning *AddListingProviderResponse
func (c *ClientWithResponses) AddListingProviderWithBodyWithResponse(ctx context.Context, params *AddListingProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error) {
	rsp, err := c.AddListingProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddListingProviderResponse(rsp)
}

func (c *ClientWithResponses) AddListingProviderWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *AddListingProviderParams, body AddListingProviderApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error) {
	rsp, err := c.AddListingProviderWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddListingProviderResponse(rsp)
}

func (c *ClientWithResponses) AddListingProviderWithResponse(ctx context.Context, params *AddListingProviderParams, body AddListingProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddListingProviderResponse, error) {
	rsp, err := c.AddListingProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddListingProviderResponse(rsp)
}

// GetDefaultListingProviderWithResponse request returning *GetDefaultListingProviderResponse
func (c *ClientWithResponses) GetDefaultListingProviderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultListingProviderResponse, error) {
	rsp, err := c.GetDefaultListingProvider(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultListingProviderResponse(rsp)
}

// GetLineupsWithResponse request returning *GetLineupsResponse
func (c *ClientWithResponses) GetLineupsWithResponse(ctx context.Context, params *GetLineupsParams, reqEditors ...RequestEditorFn) (*GetLineupsResponse, error) {
	rsp, err := c.GetLineups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineupsResponse(rsp)
}

// GetSchedulesDirectCountriesWithResponse request returning *GetSchedulesDirectCountriesResponse
func (c *ClientWithResponses) GetSchedulesDirectCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSchedulesDirectCountriesResponse, error) {
	rsp, err := c.GetSchedulesDirectCountries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesDirectCountriesResponse(rsp)
}

// GetLiveRecordingFileWithResponse request returning *GetLiveRecordingFileResponse
func (c *ClientWithResponses) GetLiveRecordingFileWithResponse(ctx context.Context, recordingId string, reqEditors ...RequestEditorFn) (*GetLiveRecordingFileResponse, error) {
	rsp, err := c.GetLiveRecordingFile(ctx, recordingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveRecordingFileResponse(rsp)
}

// GetLiveStreamFileWithResponse request returning *GetLiveStreamFileResponse
func (c *ClientWithResponses) GetLiveStreamFileWithResponse(ctx context.Context, streamId string, container string, reqEditors ...RequestEditorFn) (*GetLiveStreamFileResponse, error) {
	rsp, err := c.GetLiveStreamFile(ctx, streamId, container, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveStreamFileResponse(rsp)
}

// GetLiveTvProgramsWithResponse request returning *GetLiveTvProgramsResponse
func (c *ClientWithResponses) GetLiveTvProgramsWithResponse(ctx context.Context, params *GetLiveTvProgramsParams, reqEditors ...RequestEditorFn) (*GetLiveTvProgramsResponse, error) {
	rsp, err := c.GetLiveTvPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveTvProgramsResponse(rsp)
}

// GetProgramsWithBodyWithResponse request with arbitrary body returning *GetProgramsResponse
func (c *ClientWithResponses) GetProgramsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetProgramsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

func (c *ClientWithResponses) GetProgramsWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body GetProgramsApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetProgramsWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

func (c *ClientWithResponses) GetProgramsWithResponse(ctx context.Context, body GetProgramsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetPrograms(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

// GetRecommendedProgramsWithResponse request returning *GetRecommendedProgramsResponse
func (c *ClientWithResponses) GetRecommendedProgramsWithResponse(ctx context.Context, params *GetRecommendedProgramsParams, reqEditors ...RequestEditorFn) (*GetRecommendedProgramsResponse, error) {
	rsp, err := c.GetRecommendedPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecommendedProgramsResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, programId string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// GetRecordingsWithResponse request returning *GetRecordingsResponse
func (c *ClientWithResponses) GetRecordingsWithResponse(ctx context.Context, params *GetRecordingsParams, reqEditors ...RequestEditorFn) (*GetRecordingsResponse, error) {
	rsp, err := c.GetRecordings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingsResponse(rsp)
}

// GetRecordingFoldersWithResponse request returning *GetRecordingFoldersResponse
func (c *ClientWithResponses) GetRecordingFoldersWithResponse(ctx context.Context, params *GetRecordingFoldersParams, reqEditors ...RequestEditorFn) (*GetRecordingFoldersResponse, error) {
	rsp, err := c.GetRecordingFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingFoldersResponse(rsp)
}

// GetRecordingGroupsWithResponse request returning *GetRecordingGroupsResponse
func (c *ClientWithResponses) GetRecordingGroupsWithResponse(ctx context.Context, params *GetRecordingGroupsParams, reqEditors ...RequestEditorFn) (*GetRecordingGroupsResponse, error) {
	rsp, err := c.GetRecordingGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingGroupsResponse(rsp)
}

// GetRecordingGroupWithResponse request returning *GetRecordingGroupResponse
func (c *ClientWithResponses) GetRecordingGroupWithResponse(ctx context.Context, groupId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRecordingGroupResponse, error) {
	rsp, err := c.GetRecordingGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingGroupResponse(rsp)
}

// GetRecordingsSeriesWithResponse request returning *GetRecordingsSeriesResponse
func (c *ClientWithResponses) GetRecordingsSeriesWithResponse(ctx context.Context, params *GetRecordingsSeriesParams, reqEditors ...RequestEditorFn) (*GetRecordingsSeriesResponse, error) {
	rsp, err := c.GetRecordingsSeries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingsSeriesResponse(rsp)
}

// DeleteRecordingWithResponse request returning *DeleteRecordingResponse
func (c *ClientWithResponses) DeleteRecordingWithResponse(ctx context.Context, recordingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error) {
	rsp, err := c.DeleteRecording(ctx, recordingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordingResponse(rsp)
}

// GetRecordingWithResponse request returning *GetRecordingResponse
func (c *ClientWithResponses) GetRecordingWithResponse(ctx context.Context, recordingId openapi_types.UUID, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error) {
	rsp, err := c.GetRecording(ctx, recordingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingResponse(rsp)
}

// GetSeriesTimersWithResponse request returning *GetSeriesTimersResponse
func (c *ClientWithResponses) GetSeriesTimersWithResponse(ctx context.Context, params *GetSeriesTimersParams, reqEditors ...RequestEditorFn) (*GetSeriesTimersResponse, error) {
	rsp, err := c.GetSeriesTimers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesTimersResponse(rsp)
}

// CreateSeriesTimerWithBodyWithResponse request with arbitrary body returning *CreateSeriesTimerResponse
func (c *ClientWithResponses) CreateSeriesTimerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error) {
	rsp, err := c.CreateSeriesTimerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSeriesTimerResponse(rsp)
}

func (c *ClientWithResponses) CreateSeriesTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error) {
	rsp, err := c.CreateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSeriesTimerResponse(rsp)
}

func (c *ClientWithResponses) CreateSeriesTimerWithResponse(ctx context.Context, body CreateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSeriesTimerResponse, error) {
	rsp, err := c.CreateSeriesTimer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSeriesTimerResponse(rsp)
}

// CancelSeriesTimerWithResponse request returning *CancelSeriesTimerResponse
func (c *ClientWithResponses) CancelSeriesTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*CancelSeriesTimerResponse, error) {
	rsp, err := c.CancelSeriesTimer(ctx, timerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSeriesTimerResponse(rsp)
}

// GetSeriesTimerWithResponse request returning *GetSeriesTimerResponse
func (c *ClientWithResponses) GetSeriesTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*GetSeriesTimerResponse, error) {
	rsp, err := c.GetSeriesTimer(ctx, timerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeriesTimerResponse(rsp)
}

// UpdateSeriesTimerWithBodyWithResponse request with arbitrary body returning *UpdateSeriesTimerResponse
func (c *ClientWithResponses) UpdateSeriesTimerWithBodyWithResponse(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error) {
	rsp, err := c.UpdateSeriesTimerWithBody(ctx, timerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSeriesTimerResponse(rsp)
}

func (c *ClientWithResponses) UpdateSeriesTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, timerId string, body UpdateSeriesTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error) {
	rsp, err := c.UpdateSeriesTimerWithApplicationWildcardPlusJSONBody(ctx, timerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSeriesTimerResponse(rsp)
}

func (c *ClientWithResponses) UpdateSeriesTimerWithResponse(ctx context.Context, timerId string, body UpdateSeriesTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSeriesTimerResponse, error) {
	rsp, err := c.UpdateSeriesTimer(ctx, timerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSeriesTimerResponse(rsp)
}

// GetTimersWithResponse request returning *GetTimersResponse
func (c *ClientWithResponses) GetTimersWithResponse(ctx context.Context, params *GetTimersParams, reqEditors ...RequestEditorFn) (*GetTimersResponse, error) {
	rsp, err := c.GetTimers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimersResponse(rsp)
}

// CreateTimerWithBodyWithResponse request with arbitrary body returning *CreateTimerResponse
func (c *ClientWithResponses) CreateTimerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error) {
	rsp, err := c.CreateTimerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimerResponse(rsp)
}

func (c *ClientWithResponses) CreateTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error) {
	rsp, err := c.CreateTimerWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimerResponse(rsp)
}

func (c *ClientWithResponses) CreateTimerWithResponse(ctx context.Context, body CreateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTimerResponse, error) {
	rsp, err := c.CreateTimer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTimerResponse(rsp)
}

// GetDefaultTimerWithResponse request returning *GetDefaultTimerResponse
func (c *ClientWithResponses) GetDefaultTimerWithResponse(ctx context.Context, params *GetDefaultTimerParams, reqEditors ...RequestEditorFn) (*GetDefaultTimerResponse, error) {
	rsp, err := c.GetDefaultTimer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultTimerResponse(rsp)
}

// CancelTimerWithResponse request returning *CancelTimerResponse
func (c *ClientWithResponses) CancelTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*CancelTimerResponse, error) {
	rsp, err := c.CancelTimer(ctx, timerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelTimerResponse(rsp)
}

// GetTimerWithResponse request returning *GetTimerResponse
func (c *ClientWithResponses) GetTimerWithResponse(ctx context.Context, timerId string, reqEditors ...RequestEditorFn) (*GetTimerResponse, error) {
	rsp, err := c.GetTimer(ctx, timerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimerResponse(rsp)
}

// UpdateTimerWithBodyWithResponse request with arbitrary body returning *UpdateTimerResponse
func (c *ClientWithResponses) UpdateTimerWithBodyWithResponse(ctx context.Context, timerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error) {
	rsp, err := c.UpdateTimerWithBody(ctx, timerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimerResponse(rsp)
}

func (c *ClientWithResponses) UpdateTimerWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, timerId string, body UpdateTimerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error) {
	rsp, err := c.UpdateTimerWithApplicationWildcardPlusJSONBody(ctx, timerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimerResponse(rsp)
}

func (c *ClientWithResponses) UpdateTimerWithResponse(ctx context.Context, timerId string, body UpdateTimerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTimerResponse, error) {
	rsp, err := c.UpdateTimer(ctx, timerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTimerResponse(rsp)
}

// DeleteTunerHostWithResponse request returning *DeleteTunerHostResponse
func (c *ClientWithResponses) DeleteTunerHostWithResponse(ctx context.Context, params *DeleteTunerHostParams, reqEditors ...RequestEditorFn) (*DeleteTunerHostResponse, error) {
	rsp, err := c.DeleteTunerHost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTunerHostResponse(rsp)
}

// AddTunerHostWithBodyWithResponse request with arbitrary body returning *AddTunerHostResponse
func (c *ClientWithResponses) AddTunerHostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error) {
	rsp, err := c.AddTunerHostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTunerHostResponse(rsp)
}

func (c *ClientWithResponses) AddTunerHostWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AddTunerHostApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error) {
	rsp, err := c.AddTunerHostWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTunerHostResponse(rsp)
}

func (c *ClientWithResponses) AddTunerHostWithResponse(ctx context.Context, body AddTunerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTunerHostResponse, error) {
	rsp, err := c.AddTunerHost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTunerHostResponse(rsp)
}

// GetTunerHostTypesWithResponse request returning *GetTunerHostTypesResponse
func (c *ClientWithResponses) GetTunerHostTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTunerHostTypesResponse, error) {
	rsp, err := c.GetTunerHostTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTunerHostTypesResponse(rsp)
}

// DiscoverTunersWithResponse request returning *DiscoverTunersResponse
func (c *ClientWithResponses) DiscoverTunersWithResponse(ctx context.Context, params *DiscoverTunersParams, reqEditors ...RequestEditorFn) (*DiscoverTunersResponse, error) {
	rsp, err := c.DiscoverTuners(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscoverTunersResponse(rsp)
}

// DiscvoverTunersWithResponse request returning *DiscvoverTunersResponse
func (c *ClientWithResponses) DiscvoverTunersWithResponse(ctx context.Context, params *DiscvoverTunersParams, reqEditors ...RequestEditorFn) (*DiscvoverTunersResponse, error) {
	rsp, err := c.DiscvoverTuners(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiscvoverTunersResponse(rsp)
}

// ResetTunerWithResponse request returning *ResetTunerResponse
func (c *ClientWithResponses) ResetTunerWithResponse(ctx context.Context, tunerId string, reqEditors ...RequestEditorFn) (*ResetTunerResponse, error) {
	rsp, err := c.ResetTuner(ctx, tunerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetTunerResponse(rsp)
}

// GetCountriesWithResponse request returning *GetCountriesResponse
func (c *ClientWithResponses) GetCountriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCountriesResponse, error) {
	rsp, err := c.GetCountries(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCountriesResponse(rsp)
}

// GetCulturesWithResponse request returning *GetCulturesResponse
func (c *ClientWithResponses) GetCulturesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCulturesResponse, error) {
	rsp, err := c.GetCultures(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCulturesResponse(rsp)
}

// GetLocalizationOptionsWithResponse request returning *GetLocalizationOptionsResponse
func (c *ClientWithResponses) GetLocalizationOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalizationOptionsResponse, error) {
	rsp, err := c.GetLocalizationOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalizationOptionsResponse(rsp)
}

// GetParentalRatingsWithResponse request returning *GetParentalRatingsResponse
func (c *ClientWithResponses) GetParentalRatingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetParentalRatingsResponse, error) {
	rsp, err := c.GetParentalRatings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParentalRatingsResponse(rsp)
}

// GetMovieRecommendationsWithResponse request returning *GetMovieRecommendationsResponse
func (c *ClientWithResponses) GetMovieRecommendationsWithResponse(ctx context.Context, params *GetMovieRecommendationsParams, reqEditors ...RequestEditorFn) (*GetMovieRecommendationsResponse, error) {
	rsp, err := c.GetMovieRecommendations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieRecommendationsResponse(rsp)
}

// GetSimilarMoviesWithResponse request returning *GetSimilarMoviesResponse
func (c *ClientWithResponses) GetSimilarMoviesWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarMoviesParams, reqEditors ...RequestEditorFn) (*GetSimilarMoviesResponse, error) {
	rsp, err := c.GetSimilarMovies(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarMoviesResponse(rsp)
}

// GetMusicGenresWithResponse request returning *GetMusicGenresResponse
func (c *ClientWithResponses) GetMusicGenresWithResponse(ctx context.Context, params *GetMusicGenresParams, reqEditors ...RequestEditorFn) (*GetMusicGenresResponse, error) {
	rsp, err := c.GetMusicGenres(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicGenresResponse(rsp)
}

// GetInstantMixFromMusicGenreByIdWithResponse request returning *GetInstantMixFromMusicGenreByIdResponse
func (c *ClientWithResponses) GetInstantMixFromMusicGenreByIdWithResponse(ctx context.Context, params *GetInstantMixFromMusicGenreByIdParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromMusicGenreByIdResponse, error) {
	rsp, err := c.GetInstantMixFromMusicGenreById(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromMusicGenreByIdResponse(rsp)
}

// GetMusicGenreWithResponse request returning *GetMusicGenreResponse
func (c *ClientWithResponses) GetMusicGenreWithResponse(ctx context.Context, genreName string, params *GetMusicGenreParams, reqEditors ...RequestEditorFn) (*GetMusicGenreResponse, error) {
	rsp, err := c.GetMusicGenre(ctx, genreName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicGenreResponse(rsp)
}

// GetMusicGenreImageWithResponse request returning *GetMusicGenreImageResponse
func (c *ClientWithResponses) GetMusicGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetMusicGenreImageParams, reqEditors ...RequestEditorFn) (*GetMusicGenreImageResponse, error) {
	rsp, err := c.GetMusicGenreImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicGenreImageResponse(rsp)
}

// HeadMusicGenreImageWithResponse request returning *HeadMusicGenreImageResponse
func (c *ClientWithResponses) HeadMusicGenreImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadMusicGenreImageParams, reqEditors ...RequestEditorFn) (*HeadMusicGenreImageResponse, error) {
	rsp, err := c.HeadMusicGenreImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadMusicGenreImageResponse(rsp)
}

// GetMusicGenreImageByIndexWithResponse request returning *GetMusicGenreImageByIndexResponse
func (c *ClientWithResponses) GetMusicGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*GetMusicGenreImageByIndexResponse, error) {
	rsp, err := c.GetMusicGenreImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMusicGenreImageByIndexResponse(rsp)
}

// HeadMusicGenreImageByIndexWithResponse request returning *HeadMusicGenreImageByIndexResponse
func (c *ClientWithResponses) HeadMusicGenreImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadMusicGenreImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadMusicGenreImageByIndexResponse, error) {
	rsp, err := c.HeadMusicGenreImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadMusicGenreImageByIndexResponse(rsp)
}

// GetInstantMixFromMusicGenreByNameWithResponse request returning *GetInstantMixFromMusicGenreByNameResponse
func (c *ClientWithResponses) GetInstantMixFromMusicGenreByNameWithResponse(ctx context.Context, name string, params *GetInstantMixFromMusicGenreByNameParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromMusicGenreByNameResponse, error) {
	rsp, err := c.GetInstantMixFromMusicGenreByName(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromMusicGenreByNameResponse(rsp)
}

// CreateAdminNotificationWithBodyWithResponse request with arbitrary body returning *CreateAdminNotificationResponse
func (c *ClientWithResponses) CreateAdminNotificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error) {
	rsp, err := c.CreateAdminNotificationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminNotificationResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminNotificationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateAdminNotificationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error) {
	rsp, err := c.CreateAdminNotificationWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminNotificationResponse(rsp)
}

func (c *ClientWithResponses) CreateAdminNotificationWithResponse(ctx context.Context, body CreateAdminNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdminNotificationResponse, error) {
	rsp, err := c.CreateAdminNotification(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdminNotificationResponse(rsp)
}

// GetNotificationServicesWithResponse request returning *GetNotificationServicesResponse
func (c *ClientWithResponses) GetNotificationServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationServicesResponse, error) {
	rsp, err := c.GetNotificationServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationServicesResponse(rsp)
}

// GetNotificationTypesWithResponse request returning *GetNotificationTypesResponse
func (c *ClientWithResponses) GetNotificationTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNotificationTypesResponse, error) {
	rsp, err := c.GetNotificationTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationTypesResponse(rsp)
}

// GetNotificationsWithResponse request returning *GetNotificationsResponse
func (c *ClientWithResponses) GetNotificationsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error) {
	rsp, err := c.GetNotifications(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsResponse(rsp)
}

// SetReadWithResponse request returning *SetReadResponse
func (c *ClientWithResponses) SetReadWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetReadResponse, error) {
	rsp, err := c.SetRead(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetReadResponse(rsp)
}

// GetNotificationsSummaryWithResponse request returning *GetNotificationsSummaryResponse
func (c *ClientWithResponses) GetNotificationsSummaryWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetNotificationsSummaryResponse, error) {
	rsp, err := c.GetNotificationsSummary(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsSummaryResponse(rsp)
}

// SetUnreadWithResponse request returning *SetUnreadResponse
func (c *ClientWithResponses) SetUnreadWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*SetUnreadResponse, error) {
	rsp, err := c.SetUnread(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUnreadResponse(rsp)
}

// GetPackagesWithResponse request returning *GetPackagesResponse
func (c *ClientWithResponses) GetPackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error) {
	rsp, err := c.GetPackages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagesResponse(rsp)
}

// InstallPackageWithResponse request returning *InstallPackageResponse
func (c *ClientWithResponses) InstallPackageWithResponse(ctx context.Context, name string, params *InstallPackageParams, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackage(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

// CancelPackageInstallationWithResponse request returning *CancelPackageInstallationResponse
func (c *ClientWithResponses) CancelPackageInstallationWithResponse(ctx context.Context, packageId openapi_types.UUID, reqEditors ...RequestEditorFn) (*CancelPackageInstallationResponse, error) {
	rsp, err := c.CancelPackageInstallation(ctx, packageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPackageInstallationResponse(rsp)
}

// GetPackageInfoWithResponse request returning *GetPackageInfoResponse
func (c *ClientWithResponses) GetPackageInfoWithResponse(ctx context.Context, name string, params *GetPackageInfoParams, reqEditors ...RequestEditorFn) (*GetPackageInfoResponse, error) {
	rsp, err := c.GetPackageInfo(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageInfoResponse(rsp)
}

// GetPersonsWithResponse request returning *GetPersonsResponse
func (c *ClientWithResponses) GetPersonsWithResponse(ctx context.Context, params *GetPersonsParams, reqEditors ...RequestEditorFn) (*GetPersonsResponse, error) {
	rsp, err := c.GetPersons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonsResponse(rsp)
}

// GetPersonWithResponse request returning *GetPersonResponse
func (c *ClientWithResponses) GetPersonWithResponse(ctx context.Context, name string, params *GetPersonParams, reqEditors ...RequestEditorFn) (*GetPersonResponse, error) {
	rsp, err := c.GetPerson(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonResponse(rsp)
}

// GetPersonImageWithResponse request returning *GetPersonImageResponse
func (c *ClientWithResponses) GetPersonImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetPersonImageParams, reqEditors ...RequestEditorFn) (*GetPersonImageResponse, error) {
	rsp, err := c.GetPersonImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonImageResponse(rsp)
}

// HeadPersonImageWithResponse request returning *HeadPersonImageResponse
func (c *ClientWithResponses) HeadPersonImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadPersonImageParams, reqEditors ...RequestEditorFn) (*HeadPersonImageResponse, error) {
	rsp, err := c.HeadPersonImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadPersonImageResponse(rsp)
}

// GetPersonImageByIndexWithResponse request returning *GetPersonImageByIndexResponse
func (c *ClientWithResponses) GetPersonImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*GetPersonImageByIndexResponse, error) {
	rsp, err := c.GetPersonImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonImageByIndexResponse(rsp)
}

// HeadPersonImageByIndexWithResponse request returning *HeadPersonImageByIndexResponse
func (c *ClientWithResponses) HeadPersonImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadPersonImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadPersonImageByIndexResponse, error) {
	rsp, err := c.HeadPersonImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadPersonImageByIndexResponse(rsp)
}

// GetBitrateTestBytesWithResponse request returning *GetBitrateTestBytesResponse
func (c *ClientWithResponses) GetBitrateTestBytesWithResponse(ctx context.Context, params *GetBitrateTestBytesParams, reqEditors ...RequestEditorFn) (*GetBitrateTestBytesResponse, error) {
	rsp, err := c.GetBitrateTestBytes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBitrateTestBytesResponse(rsp)
}

// CreatePlaylistWithBodyWithResponse request with arbitrary body returning *CreatePlaylistResponse
func (c *ClientWithResponses) CreatePlaylistWithBodyWithResponse(ctx context.Context, params *CreatePlaylistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylistWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaylistWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylistWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaylistWithResponse(ctx context.Context, params *CreatePlaylistParams, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylist(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

// GetInstantMixFromPlaylistWithResponse request returning *GetInstantMixFromPlaylistResponse
func (c *ClientWithResponses) GetInstantMixFromPlaylistWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromPlaylistParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromPlaylistResponse, error) {
	rsp, err := c.GetInstantMixFromPlaylist(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromPlaylistResponse(rsp)
}

// RemoveFromPlaylistWithResponse request returning *RemoveFromPlaylistResponse
func (c *ClientWithResponses) RemoveFromPlaylistWithResponse(ctx context.Context, playlistId string, params *RemoveFromPlaylistParams, reqEditors ...RequestEditorFn) (*RemoveFromPlaylistResponse, error) {
	rsp, err := c.RemoveFromPlaylist(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveFromPlaylistResponse(rsp)
}

// GetPlaylistItemsWithResponse request returning *GetPlaylistItemsResponse
func (c *ClientWithResponses) GetPlaylistItemsWithResponse(ctx context.Context, playlistId openapi_types.UUID, params *GetPlaylistItemsParams, reqEditors ...RequestEditorFn) (*GetPlaylistItemsResponse, error) {
	rsp, err := c.GetPlaylistItems(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistItemsResponse(rsp)
}

// AddToPlaylistWithResponse request returning *AddToPlaylistResponse
func (c *ClientWithResponses) AddToPlaylistWithResponse(ctx context.Context, playlistId openapi_types.UUID, params *AddToPlaylistParams, reqEditors ...RequestEditorFn) (*AddToPlaylistResponse, error) {
	rsp, err := c.AddToPlaylist(ctx, playlistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToPlaylistResponse(rsp)
}

// MoveItemWithResponse request returning *MoveItemResponse
func (c *ClientWithResponses) MoveItemWithResponse(ctx context.Context, playlistId string, itemId string, newIndex int32, reqEditors ...RequestEditorFn) (*MoveItemResponse, error) {
	rsp, err := c.MoveItem(ctx, playlistId, itemId, newIndex, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveItemResponse(rsp)
}

// GetPluginsWithResponse request returning *GetPluginsResponse
func (c *ClientWithResponses) GetPluginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPluginsResponse, error) {
	rsp, err := c.GetPlugins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginsResponse(rsp)
}

// UninstallPluginWithResponse request returning *UninstallPluginResponse
func (c *ClientWithResponses) UninstallPluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UninstallPluginResponse, error) {
	rsp, err := c.UninstallPlugin(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallPluginResponse(rsp)
}

// GetPluginConfigurationWithResponse request returning *GetPluginConfigurationResponse
func (c *ClientWithResponses) GetPluginConfigurationWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPluginConfigurationResponse, error) {
	rsp, err := c.GetPluginConfiguration(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginConfigurationResponse(rsp)
}

// UpdatePluginConfigurationWithResponse request returning *UpdatePluginConfigurationResponse
func (c *ClientWithResponses) UpdatePluginConfigurationWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UpdatePluginConfigurationResponse, error) {
	rsp, err := c.UpdatePluginConfiguration(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginConfigurationResponse(rsp)
}

// GetPluginManifestWithResponse request returning *GetPluginManifestResponse
func (c *ClientWithResponses) GetPluginManifestWithResponse(ctx context.Context, pluginId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPluginManifestResponse, error) {
	rsp, err := c.GetPluginManifest(ctx, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginManifestResponse(rsp)
}

// UninstallPluginByVersionWithResponse request returning *UninstallPluginByVersionResponse
func (c *ClientWithResponses) UninstallPluginByVersionWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*UninstallPluginByVersionResponse, error) {
	rsp, err := c.UninstallPluginByVersion(ctx, pluginId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallPluginByVersionResponse(rsp)
}

// DisablePluginWithResponse request returning *DisablePluginResponse
func (c *ClientWithResponses) DisablePluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*DisablePluginResponse, error) {
	rsp, err := c.DisablePlugin(ctx, pluginId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisablePluginResponse(rsp)
}

// EnablePluginWithResponse request returning *EnablePluginResponse
func (c *ClientWithResponses) EnablePluginWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*EnablePluginResponse, error) {
	rsp, err := c.EnablePlugin(ctx, pluginId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnablePluginResponse(rsp)
}

// GetPluginImageWithResponse request returning *GetPluginImageResponse
func (c *ClientWithResponses) GetPluginImageWithResponse(ctx context.Context, pluginId openapi_types.UUID, version string, reqEditors ...RequestEditorFn) (*GetPluginImageResponse, error) {
	rsp, err := c.GetPluginImage(ctx, pluginId, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginImageResponse(rsp)
}

// GetRemoteSubtitlesWithResponse request returning *GetRemoteSubtitlesResponse
func (c *ClientWithResponses) GetRemoteSubtitlesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRemoteSubtitlesResponse, error) {
	rsp, err := c.GetRemoteSubtitles(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRemoteSubtitlesResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// ConnectWithResponse request returning *ConnectResponse
func (c *ClientWithResponses) ConnectWithResponse(ctx context.Context, params *ConnectParams, reqEditors ...RequestEditorFn) (*ConnectResponse, error) {
	rsp, err := c.Connect(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectResponse(rsp)
}

// GetEnabledWithResponse request returning *GetEnabledResponse
func (c *ClientWithResponses) GetEnabledWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnabledResponse, error) {
	rsp, err := c.GetEnabled(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnabledResponse(rsp)
}

// InitiateWithResponse request returning *InitiateResponse
func (c *ClientWithResponses) InitiateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateResponse, error) {
	rsp, err := c.Initiate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateResponse(rsp)
}

// GetActivityLogsWithResponse request returning *GetActivityLogsResponse
func (c *ClientWithResponses) GetActivityLogsWithResponse(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*GetActivityLogsResponse, error) {
	rsp, err := c.GetActivityLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityLogsResponse(rsp)
}

// GetReportHeadersWithResponse request returning *GetReportHeadersResponse
func (c *ClientWithResponses) GetReportHeadersWithResponse(ctx context.Context, params *GetReportHeadersParams, reqEditors ...RequestEditorFn) (*GetReportHeadersResponse, error) {
	rsp, err := c.GetReportHeaders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportHeadersResponse(rsp)
}

// GetItemReportWithResponse request returning *GetItemReportResponse
func (c *ClientWithResponses) GetItemReportWithResponse(ctx context.Context, params *GetItemReportParams, reqEditors ...RequestEditorFn) (*GetItemReportResponse, error) {
	rsp, err := c.GetItemReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemReportResponse(rsp)
}

// GetReportDownloadWithResponse request returning *GetReportDownloadResponse
func (c *ClientWithResponses) GetReportDownloadWithResponse(ctx context.Context, params *GetReportDownloadParams, reqEditors ...RequestEditorFn) (*GetReportDownloadResponse, error) {
	rsp, err := c.GetReportDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportDownloadResponse(rsp)
}

// GetRepositoriesWithResponse request returning *GetRepositoriesResponse
func (c *ClientWithResponses) GetRepositoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRepositoriesResponse, error) {
	rsp, err := c.GetRepositories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoriesResponse(rsp)
}

// SetRepositoriesWithBodyWithResponse request with arbitrary body returning *SetRepositoriesResponse
func (c *ClientWithResponses) SetRepositoriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error) {
	rsp, err := c.SetRepositoriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoriesResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoriesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetRepositoriesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error) {
	rsp, err := c.SetRepositoriesWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoriesResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoriesWithResponse(ctx context.Context, body SetRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoriesResponse, error) {
	rsp, err := c.SetRepositories(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoriesResponse(rsp)
}

// GetTasksWithResponse request returning *GetTasksResponse
func (c *ClientWithResponses) GetTasksWithResponse(ctx context.Context, params *GetTasksParams, reqEditors ...RequestEditorFn) (*GetTasksResponse, error) {
	rsp, err := c.GetTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTasksResponse(rsp)
}

// StopTaskWithResponse request returning *StopTaskResponse
func (c *ClientWithResponses) StopTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*StopTaskResponse, error) {
	rsp, err := c.StopTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopTaskResponse(rsp)
}

// StartTaskWithResponse request returning *StartTaskResponse
func (c *ClientWithResponses) StartTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*StartTaskResponse, error) {
	rsp, err := c.StartTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTaskResponse(rsp)
}

// GetTaskWithResponse request returning *GetTaskResponse
func (c *ClientWithResponses) GetTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error) {
	rsp, err := c.GetTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskResponse(rsp)
}

// UpdateTaskWithBodyWithResponse request with arbitrary body returning *UpdateTaskResponse
func (c *ClientWithResponses) UpdateTaskWithBodyWithResponse(ctx context.Context, taskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTaskWithBody(ctx, taskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateTaskWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, taskId string, body UpdateTaskApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTaskWithApplicationWildcardPlusJSONBody(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateTaskWithResponse(ctx context.Context, taskId string, body UpdateTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTaskResponse, error) {
	rsp, err := c.UpdateTask(ctx, taskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTaskResponse(rsp)
}

// GetWithResponse request returning *GetResponse
func (c *ClientWithResponses) GetWithResponse(ctx context.Context, params *GetParams, reqEditors ...RequestEditorFn) (*GetResponse, error) {
	rsp, err := c.Get(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResponse(rsp)
}

// GetSessionsWithResponse request returning *GetSessionsResponse
func (c *ClientWithResponses) GetSessionsWithResponse(ctx context.Context, params *GetSessionsParams, reqEditors ...RequestEditorFn) (*GetSessionsResponse, error) {
	rsp, err := c.GetSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionsResponse(rsp)
}

// PostCapabilitiesWithResponse request returning *PostCapabilitiesResponse
func (c *ClientWithResponses) PostCapabilitiesWithResponse(ctx context.Context, params *PostCapabilitiesParams, reqEditors ...RequestEditorFn) (*PostCapabilitiesResponse, error) {
	rsp, err := c.PostCapabilities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCapabilitiesResponse(rsp)
}

// PostFullCapabilitiesWithBodyWithResponse request with arbitrary body returning *PostFullCapabilitiesResponse
func (c *ClientWithResponses) PostFullCapabilitiesWithBodyWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error) {
	rsp, err := c.PostFullCapabilitiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFullCapabilitiesResponse(rsp)
}

func (c *ClientWithResponses) PostFullCapabilitiesWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error) {
	rsp, err := c.PostFullCapabilitiesWithApplicationWildcardPlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFullCapabilitiesResponse(rsp)
}

func (c *ClientWithResponses) PostFullCapabilitiesWithResponse(ctx context.Context, params *PostFullCapabilitiesParams, body PostFullCapabilitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFullCapabilitiesResponse, error) {
	rsp, err := c.PostFullCapabilities(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFullCapabilitiesResponse(rsp)
}

// ReportSessionEndedWithResponse request returning *ReportSessionEndedResponse
func (c *ClientWithResponses) ReportSessionEndedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReportSessionEndedResponse, error) {
	rsp, err := c.ReportSessionEnded(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportSessionEndedResponse(rsp)
}

// ReportPlaybackStartWithBodyWithResponse request with arbitrary body returning *ReportPlaybackStartResponse
func (c *ClientWithResponses) ReportPlaybackStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error) {
	rsp, err := c.ReportPlaybackStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStartResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackStartWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackStartApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error) {
	rsp, err := c.ReportPlaybackStartWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStartResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackStartWithResponse(ctx context.Context, body ReportPlaybackStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStartResponse, error) {
	rsp, err := c.ReportPlaybackStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStartResponse(rsp)
}

// PingPlaybackSessionWithResponse request returning *PingPlaybackSessionResponse
func (c *ClientWithResponses) PingPlaybackSessionWithResponse(ctx context.Context, params *PingPlaybackSessionParams, reqEditors ...RequestEditorFn) (*PingPlaybackSessionResponse, error) {
	rsp, err := c.PingPlaybackSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingPlaybackSessionResponse(rsp)
}

// ReportPlaybackProgressWithBodyWithResponse request with arbitrary body returning *ReportPlaybackProgressResponse
func (c *ClientWithResponses) ReportPlaybackProgressWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error) {
	rsp, err := c.ReportPlaybackProgressWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackProgressResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackProgressWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackProgressApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error) {
	rsp, err := c.ReportPlaybackProgressWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackProgressResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackProgressWithResponse(ctx context.Context, body ReportPlaybackProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackProgressResponse, error) {
	rsp, err := c.ReportPlaybackProgress(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackProgressResponse(rsp)
}

// ReportPlaybackStoppedWithBodyWithResponse request with arbitrary body returning *ReportPlaybackStoppedResponse
func (c *ClientWithResponses) ReportPlaybackStoppedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error) {
	rsp, err := c.ReportPlaybackStoppedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStoppedResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackStoppedWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ReportPlaybackStoppedApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error) {
	rsp, err := c.ReportPlaybackStoppedWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStoppedResponse(rsp)
}

func (c *ClientWithResponses) ReportPlaybackStoppedWithResponse(ctx context.Context, body ReportPlaybackStoppedJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportPlaybackStoppedResponse, error) {
	rsp, err := c.ReportPlaybackStopped(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportPlaybackStoppedResponse(rsp)
}

// ReportViewingWithResponse request returning *ReportViewingResponse
func (c *ClientWithResponses) ReportViewingWithResponse(ctx context.Context, params *ReportViewingParams, reqEditors ...RequestEditorFn) (*ReportViewingResponse, error) {
	rsp, err := c.ReportViewing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportViewingResponse(rsp)
}

// SendFullGeneralCommandWithBodyWithResponse request with arbitrary body returning *SendFullGeneralCommandResponse
func (c *ClientWithResponses) SendFullGeneralCommandWithBodyWithResponse(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error) {
	rsp, err := c.SendFullGeneralCommandWithBody(ctx, sessionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendFullGeneralCommandResponse(rsp)
}

func (c *ClientWithResponses) SendFullGeneralCommandWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, sessionId string, body SendFullGeneralCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error) {
	rsp, err := c.SendFullGeneralCommandWithApplicationWildcardPlusJSONBody(ctx, sessionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendFullGeneralCommandResponse(rsp)
}

func (c *ClientWithResponses) SendFullGeneralCommandWithResponse(ctx context.Context, sessionId string, body SendFullGeneralCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFullGeneralCommandResponse, error) {
	rsp, err := c.SendFullGeneralCommand(ctx, sessionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendFullGeneralCommandResponse(rsp)
}

// SendGeneralCommandWithResponse request returning *SendGeneralCommandResponse
func (c *ClientWithResponses) SendGeneralCommandWithResponse(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*SendGeneralCommandResponse, error) {
	rsp, err := c.SendGeneralCommand(ctx, sessionId, command, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendGeneralCommandResponse(rsp)
}

// SendMessageCommandWithBodyWithResponse request with arbitrary body returning *SendMessageCommandResponse
func (c *ClientWithResponses) SendMessageCommandWithBodyWithResponse(ctx context.Context, sessionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error) {
	rsp, err := c.SendMessageCommandWithBody(ctx, sessionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageCommandResponse(rsp)
}

func (c *ClientWithResponses) SendMessageCommandWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, sessionId string, body SendMessageCommandApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error) {
	rsp, err := c.SendMessageCommandWithApplicationWildcardPlusJSONBody(ctx, sessionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageCommandResponse(rsp)
}

func (c *ClientWithResponses) SendMessageCommandWithResponse(ctx context.Context, sessionId string, body SendMessageCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*SendMessageCommandResponse, error) {
	rsp, err := c.SendMessageCommand(ctx, sessionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendMessageCommandResponse(rsp)
}

// PlayWithResponse request returning *PlayResponse
func (c *ClientWithResponses) PlayWithResponse(ctx context.Context, sessionId string, params *PlayParams, reqEditors ...RequestEditorFn) (*PlayResponse, error) {
	rsp, err := c.Play(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayResponse(rsp)
}

// SendPlaystateCommandWithResponse request returning *SendPlaystateCommandResponse
func (c *ClientWithResponses) SendPlaystateCommandWithResponse(ctx context.Context, sessionId string, command PlaystateCommand, params *SendPlaystateCommandParams, reqEditors ...RequestEditorFn) (*SendPlaystateCommandResponse, error) {
	rsp, err := c.SendPlaystateCommand(ctx, sessionId, command, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPlaystateCommandResponse(rsp)
}

// SendSystemCommandWithResponse request returning *SendSystemCommandResponse
func (c *ClientWithResponses) SendSystemCommandWithResponse(ctx context.Context, sessionId string, command GeneralCommandType, reqEditors ...RequestEditorFn) (*SendSystemCommandResponse, error) {
	rsp, err := c.SendSystemCommand(ctx, sessionId, command, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendSystemCommandResponse(rsp)
}

// RemoveUserFromSessionWithResponse request returning *RemoveUserFromSessionResponse
func (c *ClientWithResponses) RemoveUserFromSessionWithResponse(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RemoveUserFromSessionResponse, error) {
	rsp, err := c.RemoveUserFromSession(ctx, sessionId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromSessionResponse(rsp)
}

// AddUserToSessionWithResponse request returning *AddUserToSessionResponse
func (c *ClientWithResponses) AddUserToSessionWithResponse(ctx context.Context, sessionId string, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AddUserToSessionResponse, error) {
	rsp, err := c.AddUserToSession(ctx, sessionId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToSessionResponse(rsp)
}

// DisplayContentWithResponse request returning *DisplayContentResponse
func (c *ClientWithResponses) DisplayContentWithResponse(ctx context.Context, sessionId string, params *DisplayContentParams, reqEditors ...RequestEditorFn) (*DisplayContentResponse, error) {
	rsp, err := c.DisplayContent(ctx, sessionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisplayContentResponse(rsp)
}

// GetNextUpWithResponse request returning *GetNextUpResponse
func (c *ClientWithResponses) GetNextUpWithResponse(ctx context.Context, params *GetNextUpParams, reqEditors ...RequestEditorFn) (*GetNextUpResponse, error) {
	rsp, err := c.GetNextUp(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNextUpResponse(rsp)
}

// GetUpcomingEpisodesWithResponse request returning *GetUpcomingEpisodesResponse
func (c *ClientWithResponses) GetUpcomingEpisodesWithResponse(ctx context.Context, params *GetUpcomingEpisodesParams, reqEditors ...RequestEditorFn) (*GetUpcomingEpisodesResponse, error) {
	rsp, err := c.GetUpcomingEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpcomingEpisodesResponse(rsp)
}

// GetSimilarShowsWithResponse request returning *GetSimilarShowsResponse
func (c *ClientWithResponses) GetSimilarShowsWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarShowsParams, reqEditors ...RequestEditorFn) (*GetSimilarShowsResponse, error) {
	rsp, err := c.GetSimilarShows(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarShowsResponse(rsp)
}

// GetEpisodesWithResponse request returning *GetEpisodesResponse
func (c *ClientWithResponses) GetEpisodesWithResponse(ctx context.Context, seriesId openapi_types.UUID, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*GetEpisodesResponse, error) {
	rsp, err := c.GetEpisodes(ctx, seriesId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodesResponse(rsp)
}

// GetSeasonsWithResponse request returning *GetSeasonsResponse
func (c *ClientWithResponses) GetSeasonsWithResponse(ctx context.Context, seriesId openapi_types.UUID, params *GetSeasonsParams, reqEditors ...RequestEditorFn) (*GetSeasonsResponse, error) {
	rsp, err := c.GetSeasons(ctx, seriesId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonsResponse(rsp)
}

// GetInstantMixFromSongWithResponse request returning *GetInstantMixFromSongResponse
func (c *ClientWithResponses) GetInstantMixFromSongWithResponse(ctx context.Context, id openapi_types.UUID, params *GetInstantMixFromSongParams, reqEditors ...RequestEditorFn) (*GetInstantMixFromSongResponse, error) {
	rsp, err := c.GetInstantMixFromSong(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstantMixFromSongResponse(rsp)
}

// CompleteWizardWithResponse request returning *CompleteWizardResponse
func (c *ClientWithResponses) CompleteWizardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CompleteWizardResponse, error) {
	rsp, err := c.CompleteWizard(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteWizardResponse(rsp)
}

// GetStartupConfigurationWithResponse request returning *GetStartupConfigurationResponse
func (c *ClientWithResponses) GetStartupConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStartupConfigurationResponse, error) {
	rsp, err := c.GetStartupConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStartupConfigurationResponse(rsp)
}

// UpdateInitialConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateInitialConfigurationResponse
func (c *ClientWithResponses) UpdateInitialConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error) {
	rsp, err := c.UpdateInitialConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInitialConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateInitialConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateInitialConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error) {
	rsp, err := c.UpdateInitialConfigurationWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInitialConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateInitialConfigurationWithResponse(ctx context.Context, body UpdateInitialConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInitialConfigurationResponse, error) {
	rsp, err := c.UpdateInitialConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInitialConfigurationResponse(rsp)
}

// GetFirstUser2WithResponse request returning *GetFirstUser2Response
func (c *ClientWithResponses) GetFirstUser2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirstUser2Response, error) {
	rsp, err := c.GetFirstUser2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFirstUser2Response(rsp)
}

// SetRemoteAccessWithBodyWithResponse request with arbitrary body returning *SetRemoteAccessResponse
func (c *ClientWithResponses) SetRemoteAccessWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error) {
	rsp, err := c.SetRemoteAccessWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRemoteAccessResponse(rsp)
}

func (c *ClientWithResponses) SetRemoteAccessWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SetRemoteAccessApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error) {
	rsp, err := c.SetRemoteAccessWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRemoteAccessResponse(rsp)
}

func (c *ClientWithResponses) SetRemoteAccessWithResponse(ctx context.Context, body SetRemoteAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRemoteAccessResponse, error) {
	rsp, err := c.SetRemoteAccess(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRemoteAccessResponse(rsp)
}

// GetFirstUserWithResponse request returning *GetFirstUserResponse
func (c *ClientWithResponses) GetFirstUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFirstUserResponse, error) {
	rsp, err := c.GetFirstUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFirstUserResponse(rsp)
}

// UpdateStartupUserWithBodyWithResponse request with arbitrary body returning *UpdateStartupUserResponse
func (c *ClientWithResponses) UpdateStartupUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error) {
	rsp, err := c.UpdateStartupUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStartupUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateStartupUserWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateStartupUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error) {
	rsp, err := c.UpdateStartupUserWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStartupUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateStartupUserWithResponse(ctx context.Context, body UpdateStartupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStartupUserResponse, error) {
	rsp, err := c.UpdateStartupUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStartupUserResponse(rsp)
}

// GetStudiosWithResponse request returning *GetStudiosResponse
func (c *ClientWithResponses) GetStudiosWithResponse(ctx context.Context, params *GetStudiosParams, reqEditors ...RequestEditorFn) (*GetStudiosResponse, error) {
	rsp, err := c.GetStudios(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudiosResponse(rsp)
}

// GetStudioWithResponse request returning *GetStudioResponse
func (c *ClientWithResponses) GetStudioWithResponse(ctx context.Context, name string, params *GetStudioParams, reqEditors ...RequestEditorFn) (*GetStudioResponse, error) {
	rsp, err := c.GetStudio(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudioResponse(rsp)
}

// GetStudioImageWithResponse request returning *GetStudioImageResponse
func (c *ClientWithResponses) GetStudioImageWithResponse(ctx context.Context, name string, imageType ImageType, params *GetStudioImageParams, reqEditors ...RequestEditorFn) (*GetStudioImageResponse, error) {
	rsp, err := c.GetStudioImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudioImageResponse(rsp)
}

// HeadStudioImageWithResponse request returning *HeadStudioImageResponse
func (c *ClientWithResponses) HeadStudioImageWithResponse(ctx context.Context, name string, imageType ImageType, params *HeadStudioImageParams, reqEditors ...RequestEditorFn) (*HeadStudioImageResponse, error) {
	rsp, err := c.HeadStudioImage(ctx, name, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadStudioImageResponse(rsp)
}

// GetStudioImageByIndexWithResponse request returning *GetStudioImageByIndexResponse
func (c *ClientWithResponses) GetStudioImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *GetStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*GetStudioImageByIndexResponse, error) {
	rsp, err := c.GetStudioImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStudioImageByIndexResponse(rsp)
}

// HeadStudioImageByIndexWithResponse request returning *HeadStudioImageByIndexResponse
func (c *ClientWithResponses) HeadStudioImageByIndexWithResponse(ctx context.Context, name string, imageType ImageType, imageIndex int32, params *HeadStudioImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadStudioImageByIndexResponse, error) {
	rsp, err := c.HeadStudioImageByIndex(ctx, name, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadStudioImageByIndexResponse(rsp)
}

// SyncPlayBufferingWithBodyWithResponse request with arbitrary body returning *SyncPlayBufferingResponse
func (c *ClientWithResponses) SyncPlayBufferingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error) {
	rsp, err := c.SyncPlayBufferingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayBufferingResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayBufferingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayBufferingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error) {
	rsp, err := c.SyncPlayBufferingWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayBufferingResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayBufferingWithResponse(ctx context.Context, body SyncPlayBufferingJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayBufferingResponse, error) {
	rsp, err := c.SyncPlayBuffering(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayBufferingResponse(rsp)
}

// SyncPlayJoinGroupWithBodyWithResponse request with arbitrary body returning *SyncPlayJoinGroupResponse
func (c *ClientWithResponses) SyncPlayJoinGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error) {
	rsp, err := c.SyncPlayJoinGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayJoinGroupResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayJoinGroupWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayJoinGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error) {
	rsp, err := c.SyncPlayJoinGroupWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayJoinGroupResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayJoinGroupWithResponse(ctx context.Context, body SyncPlayJoinGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayJoinGroupResponse, error) {
	rsp, err := c.SyncPlayJoinGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayJoinGroupResponse(rsp)
}

// SyncPlayLeaveGroupWithResponse request returning *SyncPlayLeaveGroupResponse
func (c *ClientWithResponses) SyncPlayLeaveGroupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayLeaveGroupResponse, error) {
	rsp, err := c.SyncPlayLeaveGroup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayLeaveGroupResponse(rsp)
}

// SyncPlayGetGroupsWithResponse request returning *SyncPlayGetGroupsResponse
func (c *ClientWithResponses) SyncPlayGetGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayGetGroupsResponse, error) {
	rsp, err := c.SyncPlayGetGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayGetGroupsResponse(rsp)
}

// SyncPlayMovePlaylistItemWithBodyWithResponse request with arbitrary body returning *SyncPlayMovePlaylistItemResponse
func (c *ClientWithResponses) SyncPlayMovePlaylistItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error) {
	rsp, err := c.SyncPlayMovePlaylistItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayMovePlaylistItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayMovePlaylistItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayMovePlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error) {
	rsp, err := c.SyncPlayMovePlaylistItemWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayMovePlaylistItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayMovePlaylistItemWithResponse(ctx context.Context, body SyncPlayMovePlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayMovePlaylistItemResponse, error) {
	rsp, err := c.SyncPlayMovePlaylistItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayMovePlaylistItemResponse(rsp)
}

// SyncPlayCreateGroupWithBodyWithResponse request with arbitrary body returning *SyncPlayCreateGroupResponse
func (c *ClientWithResponses) SyncPlayCreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error) {
	rsp, err := c.SyncPlayCreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayCreateGroupWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayCreateGroupApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error) {
	rsp, err := c.SyncPlayCreateGroupWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayCreateGroupWithResponse(ctx context.Context, body SyncPlayCreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayCreateGroupResponse, error) {
	rsp, err := c.SyncPlayCreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayCreateGroupResponse(rsp)
}

// SyncPlayNextItemWithBodyWithResponse request with arbitrary body returning *SyncPlayNextItemResponse
func (c *ClientWithResponses) SyncPlayNextItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error) {
	rsp, err := c.SyncPlayNextItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayNextItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayNextItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayNextItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error) {
	rsp, err := c.SyncPlayNextItemWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayNextItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayNextItemWithResponse(ctx context.Context, body SyncPlayNextItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayNextItemResponse, error) {
	rsp, err := c.SyncPlayNextItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayNextItemResponse(rsp)
}

// SyncPlayPauseWithResponse request returning *SyncPlayPauseResponse
func (c *ClientWithResponses) SyncPlayPauseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayPauseResponse, error) {
	rsp, err := c.SyncPlayPause(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPauseResponse(rsp)
}

// SyncPlayPingWithBodyWithResponse request with arbitrary body returning *SyncPlayPingResponse
func (c *ClientWithResponses) SyncPlayPingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error) {
	rsp, err := c.SyncPlayPingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPingResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayPingWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayPingApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error) {
	rsp, err := c.SyncPlayPingWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPingResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayPingWithResponse(ctx context.Context, body SyncPlayPingJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPingResponse, error) {
	rsp, err := c.SyncPlayPing(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPingResponse(rsp)
}

// SyncPlayPreviousItemWithBodyWithResponse request with arbitrary body returning *SyncPlayPreviousItemResponse
func (c *ClientWithResponses) SyncPlayPreviousItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error) {
	rsp, err := c.SyncPlayPreviousItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPreviousItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayPreviousItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayPreviousItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error) {
	rsp, err := c.SyncPlayPreviousItemWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPreviousItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayPreviousItemWithResponse(ctx context.Context, body SyncPlayPreviousItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayPreviousItemResponse, error) {
	rsp, err := c.SyncPlayPreviousItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayPreviousItemResponse(rsp)
}

// SyncPlayQueueWithBodyWithResponse request with arbitrary body returning *SyncPlayQueueResponse
func (c *ClientWithResponses) SyncPlayQueueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error) {
	rsp, err := c.SyncPlayQueueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayQueueResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayQueueWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error) {
	rsp, err := c.SyncPlayQueueWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayQueueResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayQueueWithResponse(ctx context.Context, body SyncPlayQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayQueueResponse, error) {
	rsp, err := c.SyncPlayQueue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayQueueResponse(rsp)
}

// SyncPlayReadyWithBodyWithResponse request with arbitrary body returning *SyncPlayReadyResponse
func (c *ClientWithResponses) SyncPlayReadyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error) {
	rsp, err := c.SyncPlayReadyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayReadyResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayReadyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayReadyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error) {
	rsp, err := c.SyncPlayReadyWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayReadyResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayReadyWithResponse(ctx context.Context, body SyncPlayReadyJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayReadyResponse, error) {
	rsp, err := c.SyncPlayReady(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayReadyResponse(rsp)
}

// SyncPlayRemoveFromPlaylistWithBodyWithResponse request with arbitrary body returning *SyncPlayRemoveFromPlaylistResponse
func (c *ClientWithResponses) SyncPlayRemoveFromPlaylistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error) {
	rsp, err := c.SyncPlayRemoveFromPlaylistWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayRemoveFromPlaylistResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayRemoveFromPlaylistWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlayRemoveFromPlaylistApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error) {
	rsp, err := c.SyncPlayRemoveFromPlaylistWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayRemoveFromPlaylistResponse(rsp)
}

func (c *ClientWithResponses) SyncPlayRemoveFromPlaylistWithResponse(ctx context.Context, body SyncPlayRemoveFromPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlayRemoveFromPlaylistResponse, error) {
	rsp, err := c.SyncPlayRemoveFromPlaylist(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayRemoveFromPlaylistResponse(rsp)
}

// SyncPlaySeekWithBodyWithResponse request with arbitrary body returning *SyncPlaySeekResponse
func (c *ClientWithResponses) SyncPlaySeekWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error) {
	rsp, err := c.SyncPlaySeekWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySeekResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySeekWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySeekApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error) {
	rsp, err := c.SyncPlaySeekWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySeekResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySeekWithResponse(ctx context.Context, body SyncPlaySeekJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySeekResponse, error) {
	rsp, err := c.SyncPlaySeek(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySeekResponse(rsp)
}

// SyncPlaySetIgnoreWaitWithBodyWithResponse request with arbitrary body returning *SyncPlaySetIgnoreWaitResponse
func (c *ClientWithResponses) SyncPlaySetIgnoreWaitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error) {
	rsp, err := c.SyncPlaySetIgnoreWaitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetIgnoreWaitResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetIgnoreWaitWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetIgnoreWaitApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error) {
	rsp, err := c.SyncPlaySetIgnoreWaitWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetIgnoreWaitResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetIgnoreWaitWithResponse(ctx context.Context, body SyncPlaySetIgnoreWaitJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetIgnoreWaitResponse, error) {
	rsp, err := c.SyncPlaySetIgnoreWait(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetIgnoreWaitResponse(rsp)
}

// SyncPlaySetNewQueueWithBodyWithResponse request with arbitrary body returning *SyncPlaySetNewQueueResponse
func (c *ClientWithResponses) SyncPlaySetNewQueueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error) {
	rsp, err := c.SyncPlaySetNewQueueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetNewQueueResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetNewQueueWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetNewQueueApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error) {
	rsp, err := c.SyncPlaySetNewQueueWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetNewQueueResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetNewQueueWithResponse(ctx context.Context, body SyncPlaySetNewQueueJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetNewQueueResponse, error) {
	rsp, err := c.SyncPlaySetNewQueue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetNewQueueResponse(rsp)
}

// SyncPlaySetPlaylistItemWithBodyWithResponse request with arbitrary body returning *SyncPlaySetPlaylistItemResponse
func (c *ClientWithResponses) SyncPlaySetPlaylistItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error) {
	rsp, err := c.SyncPlaySetPlaylistItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetPlaylistItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetPlaylistItemWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetPlaylistItemApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error) {
	rsp, err := c.SyncPlaySetPlaylistItemWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetPlaylistItemResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetPlaylistItemWithResponse(ctx context.Context, body SyncPlaySetPlaylistItemJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetPlaylistItemResponse, error) {
	rsp, err := c.SyncPlaySetPlaylistItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetPlaylistItemResponse(rsp)
}

// SyncPlaySetRepeatModeWithBodyWithResponse request with arbitrary body returning *SyncPlaySetRepeatModeResponse
func (c *ClientWithResponses) SyncPlaySetRepeatModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error) {
	rsp, err := c.SyncPlaySetRepeatModeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetRepeatModeResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetRepeatModeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetRepeatModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error) {
	rsp, err := c.SyncPlaySetRepeatModeWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetRepeatModeResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetRepeatModeWithResponse(ctx context.Context, body SyncPlaySetRepeatModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetRepeatModeResponse, error) {
	rsp, err := c.SyncPlaySetRepeatMode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetRepeatModeResponse(rsp)
}

// SyncPlaySetShuffleModeWithBodyWithResponse request with arbitrary body returning *SyncPlaySetShuffleModeResponse
func (c *ClientWithResponses) SyncPlaySetShuffleModeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error) {
	rsp, err := c.SyncPlaySetShuffleModeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetShuffleModeResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetShuffleModeWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body SyncPlaySetShuffleModeApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error) {
	rsp, err := c.SyncPlaySetShuffleModeWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetShuffleModeResponse(rsp)
}

func (c *ClientWithResponses) SyncPlaySetShuffleModeWithResponse(ctx context.Context, body SyncPlaySetShuffleModeJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncPlaySetShuffleModeResponse, error) {
	rsp, err := c.SyncPlaySetShuffleMode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlaySetShuffleModeResponse(rsp)
}

// SyncPlayStopWithResponse request returning *SyncPlayStopResponse
func (c *ClientWithResponses) SyncPlayStopWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayStopResponse, error) {
	rsp, err := c.SyncPlayStop(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayStopResponse(rsp)
}

// SyncPlayUnpauseWithResponse request returning *SyncPlayUnpauseResponse
func (c *ClientWithResponses) SyncPlayUnpauseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SyncPlayUnpauseResponse, error) {
	rsp, err := c.SyncPlayUnpause(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncPlayUnpauseResponse(rsp)
}

// GetLogEntriesWithResponse request returning *GetLogEntriesResponse
func (c *ClientWithResponses) GetLogEntriesWithResponse(ctx context.Context, params *GetLogEntriesParams, reqEditors ...RequestEditorFn) (*GetLogEntriesResponse, error) {
	rsp, err := c.GetLogEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogEntriesResponse(rsp)
}

// GetConfigurationWithResponse request returning *GetConfigurationResponse
func (c *ClientWithResponses) GetConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationResponse, error) {
	rsp, err := c.GetConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationResponse(rsp)
}

// UpdateConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateConfigurationResponse
func (c *ClientWithResponses) UpdateConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error) {
	rsp, err := c.UpdateConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error) {
	rsp, err := c.UpdateConfigurationWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigurationWithResponse(ctx context.Context, body UpdateConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigurationResponse, error) {
	rsp, err := c.UpdateConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigurationResponse(rsp)
}

// GetDefaultMetadataOptionsWithResponse request returning *GetDefaultMetadataOptionsResponse
func (c *ClientWithResponses) GetDefaultMetadataOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultMetadataOptionsResponse, error) {
	rsp, err := c.GetDefaultMetadataOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultMetadataOptionsResponse(rsp)
}

// GetNamedConfigurationWithResponse request returning *GetNamedConfigurationResponse
func (c *ClientWithResponses) GetNamedConfigurationWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*GetNamedConfigurationResponse, error) {
	rsp, err := c.GetNamedConfiguration(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNamedConfigurationResponse(rsp)
}

// UpdateNamedConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateNamedConfigurationResponse
func (c *ClientWithResponses) UpdateNamedConfigurationWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error) {
	rsp, err := c.UpdateNamedConfigurationWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNamedConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateNamedConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, key string, body UpdateNamedConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error) {
	rsp, err := c.UpdateNamedConfigurationWithApplicationWildcardPlusJSONBody(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNamedConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateNamedConfigurationWithResponse(ctx context.Context, key string, body UpdateNamedConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNamedConfigurationResponse, error) {
	rsp, err := c.UpdateNamedConfiguration(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNamedConfigurationResponse(rsp)
}

// GetEndpointInfoWithResponse request returning *GetEndpointInfoResponse
func (c *ClientWithResponses) GetEndpointInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEndpointInfoResponse, error) {
	rsp, err := c.GetEndpointInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndpointInfoResponse(rsp)
}

// GetSystemInfoWithResponse request returning *GetSystemInfoResponse
func (c *ClientWithResponses) GetSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInfoResponse, error) {
	rsp, err := c.GetSystemInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInfoResponse(rsp)
}

// GetPublicSystemInfoWithResponse request returning *GetPublicSystemInfoResponse
func (c *ClientWithResponses) GetPublicSystemInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublicSystemInfoResponse, error) {
	rsp, err := c.GetPublicSystemInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicSystemInfoResponse(rsp)
}

// GetServerLogsWithResponse request returning *GetServerLogsResponse
func (c *ClientWithResponses) GetServerLogsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServerLogsResponse, error) {
	rsp, err := c.GetServerLogs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerLogsResponse(rsp)
}

// GetLogFileWithResponse request returning *GetLogFileResponse
func (c *ClientWithResponses) GetLogFileWithResponse(ctx context.Context, params *GetLogFileParams, reqEditors ...RequestEditorFn) (*GetLogFileResponse, error) {
	rsp, err := c.GetLogFile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogFileResponse(rsp)
}

// UpdateMediaEncoderPathWithBodyWithResponse request with arbitrary body returning *UpdateMediaEncoderPathResponse
func (c *ClientWithResponses) UpdateMediaEncoderPathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error) {
	rsp, err := c.UpdateMediaEncoderPathWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaEncoderPathResponse(rsp)
}

func (c *ClientWithResponses) UpdateMediaEncoderPathWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body UpdateMediaEncoderPathApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error) {
	rsp, err := c.UpdateMediaEncoderPathWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaEncoderPathResponse(rsp)
}

func (c *ClientWithResponses) UpdateMediaEncoderPathWithResponse(ctx context.Context, body UpdateMediaEncoderPathJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMediaEncoderPathResponse, error) {
	rsp, err := c.UpdateMediaEncoderPath(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMediaEncoderPathResponse(rsp)
}

// GetPingSystemWithResponse request returning *GetPingSystemResponse
func (c *ClientWithResponses) GetPingSystemWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingSystemResponse, error) {
	rsp, err := c.GetPingSystem(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPingSystemResponse(rsp)
}

// PostPingSystemWithResponse request returning *PostPingSystemResponse
func (c *ClientWithResponses) PostPingSystemWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostPingSystemResponse, error) {
	rsp, err := c.PostPingSystem(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPingSystemResponse(rsp)
}

// RestartApplicationWithResponse request returning *RestartApplicationResponse
func (c *ClientWithResponses) RestartApplicationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RestartApplicationResponse, error) {
	rsp, err := c.RestartApplication(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartApplicationResponse(rsp)
}

// ShutdownApplicationWithResponse request returning *ShutdownApplicationResponse
func (c *ClientWithResponses) ShutdownApplicationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShutdownApplicationResponse, error) {
	rsp, err := c.ShutdownApplication(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShutdownApplicationResponse(rsp)
}

// GetWakeOnLanInfoWithResponse request returning *GetWakeOnLanInfoResponse
func (c *ClientWithResponses) GetWakeOnLanInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWakeOnLanInfoResponse, error) {
	rsp, err := c.GetWakeOnLanInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWakeOnLanInfoResponse(rsp)
}

// TmdbClientConfigurationWithResponse request returning *TmdbClientConfigurationResponse
func (c *ClientWithResponses) TmdbClientConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TmdbClientConfigurationResponse, error) {
	rsp, err := c.TmdbClientConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTmdbClientConfigurationResponse(rsp)
}

// GetTrailersWithResponse request returning *GetTrailersResponse
func (c *ClientWithResponses) GetTrailersWithResponse(ctx context.Context, params *GetTrailersParams, reqEditors ...RequestEditorFn) (*GetTrailersResponse, error) {
	rsp, err := c.GetTrailers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrailersResponse(rsp)
}

// GetSimilarTrailersWithResponse request returning *GetSimilarTrailersResponse
func (c *ClientWithResponses) GetSimilarTrailersWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetSimilarTrailersParams, reqEditors ...RequestEditorFn) (*GetSimilarTrailersResponse, error) {
	rsp, err := c.GetSimilarTrailers(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimilarTrailersResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// AuthenticateUserByNameWithBodyWithResponse request with arbitrary body returning *AuthenticateUserByNameResponse
func (c *ClientWithResponses) AuthenticateUserByNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error) {
	rsp, err := c.AuthenticateUserByNameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserByNameResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateUserByNameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AuthenticateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error) {
	rsp, err := c.AuthenticateUserByNameWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserByNameResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateUserByNameWithResponse(ctx context.Context, body AuthenticateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateUserByNameResponse, error) {
	rsp, err := c.AuthenticateUserByName(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserByNameResponse(rsp)
}

// AuthenticateWithQuickConnectWithBodyWithResponse request with arbitrary body returning *AuthenticateWithQuickConnectResponse
func (c *ClientWithResponses) AuthenticateWithQuickConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error) {
	rsp, err := c.AuthenticateWithQuickConnectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateWithQuickConnectResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateWithQuickConnectWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body AuthenticateWithQuickConnectApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error) {
	rsp, err := c.AuthenticateWithQuickConnectWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateWithQuickConnectResponse(rsp)
}

func (c *ClientWithResponses) AuthenticateWithQuickConnectWithResponse(ctx context.Context, body AuthenticateWithQuickConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithQuickConnectResponse, error) {
	rsp, err := c.AuthenticateWithQuickConnect(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateWithQuickConnectResponse(rsp)
}

// ForgotPasswordWithBodyWithResponse request with arbitrary body returning *ForgotPasswordResponse
func (c *ClientWithResponses) ForgotPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error) {
	rsp, err := c.ForgotPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordResponse(rsp)
}

func (c *ClientWithResponses) ForgotPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ForgotPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error) {
	rsp, err := c.ForgotPasswordWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordResponse(rsp)
}

func (c *ClientWithResponses) ForgotPasswordWithResponse(ctx context.Context, body ForgotPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordResponse, error) {
	rsp, err := c.ForgotPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordResponse(rsp)
}

// ForgotPasswordPinWithBodyWithResponse request with arbitrary body returning *ForgotPasswordPinResponse
func (c *ClientWithResponses) ForgotPasswordPinWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error) {
	rsp, err := c.ForgotPasswordPinWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordPinResponse(rsp)
}

func (c *ClientWithResponses) ForgotPasswordPinWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body ForgotPasswordPinApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error) {
	rsp, err := c.ForgotPasswordPinWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordPinResponse(rsp)
}

func (c *ClientWithResponses) ForgotPasswordPinWithResponse(ctx context.Context, body ForgotPasswordPinJSONRequestBody, reqEditors ...RequestEditorFn) (*ForgotPasswordPinResponse, error) {
	rsp, err := c.ForgotPasswordPin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForgotPasswordPinResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// CreateUserByNameWithBodyWithResponse request with arbitrary body returning *CreateUserByNameResponse
func (c *ClientWithResponses) CreateUserByNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error) {
	rsp, err := c.CreateUserByNameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserByNameResponse(rsp)
}

func (c *ClientWithResponses) CreateUserByNameWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CreateUserByNameApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error) {
	rsp, err := c.CreateUserByNameWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserByNameResponse(rsp)
}

func (c *ClientWithResponses) CreateUserByNameWithResponse(ctx context.Context, body CreateUserByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserByNameResponse, error) {
	rsp, err := c.CreateUserByName(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserByNameResponse(rsp)
}

// GetPublicUsersWithResponse request returning *GetPublicUsersResponse
func (c *ClientWithResponses) GetPublicUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublicUsersResponse, error) {
	rsp, err := c.GetPublicUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicUsersResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserByIdWithResponse request returning *GetUserByIdResponse
func (c *ClientWithResponses) GetUserByIdWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error) {
	rsp, err := c.GetUserById(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByIdResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithApplicationWildcardPlusJSONBody(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// AuthenticateUserWithResponse request returning *AuthenticateUserResponse
func (c *ClientWithResponses) AuthenticateUserWithResponse(ctx context.Context, userId openapi_types.UUID, params *AuthenticateUserParams, reqEditors ...RequestEditorFn) (*AuthenticateUserResponse, error) {
	rsp, err := c.AuthenticateUser(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateUserResponse(rsp)
}

// UpdateUserConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateUserConfigurationResponse
func (c *ClientWithResponses) UpdateUserConfigurationWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error) {
	rsp, err := c.UpdateUserConfigurationWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserConfigurationWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error) {
	rsp, err := c.UpdateUserConfigurationWithApplicationWildcardPlusJSONBody(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserConfigurationWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserConfigurationResponse, error) {
	rsp, err := c.UpdateUserConfiguration(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserConfigurationResponse(rsp)
}

// UpdateUserEasyPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserEasyPasswordResponse
func (c *ClientWithResponses) UpdateUserEasyPasswordWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error) {
	rsp, err := c.UpdateUserEasyPasswordWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserEasyPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserEasyPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error) {
	rsp, err := c.UpdateUserEasyPasswordWithApplicationWildcardPlusJSONBody(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserEasyPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserEasyPasswordWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserEasyPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserEasyPasswordResponse, error) {
	rsp, err := c.UpdateUserEasyPassword(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserEasyPasswordResponse(rsp)
}

// UnmarkFavoriteItemWithResponse request returning *UnmarkFavoriteItemResponse
func (c *ClientWithResponses) UnmarkFavoriteItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UnmarkFavoriteItemResponse, error) {
	rsp, err := c.UnmarkFavoriteItem(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnmarkFavoriteItemResponse(rsp)
}

// MarkFavoriteItemWithResponse request returning *MarkFavoriteItemResponse
func (c *ClientWithResponses) MarkFavoriteItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkFavoriteItemResponse, error) {
	rsp, err := c.MarkFavoriteItem(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkFavoriteItemResponse(rsp)
}

// GetGroupingOptionsWithResponse request returning *GetGroupingOptionsResponse
func (c *ClientWithResponses) GetGroupingOptionsWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetGroupingOptionsResponse, error) {
	rsp, err := c.GetGroupingOptions(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupingOptionsResponse(rsp)
}

// DeleteUserImageWithResponse request returning *DeleteUserImageResponse
func (c *ClientWithResponses) DeleteUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *DeleteUserImageParams, reqEditors ...RequestEditorFn) (*DeleteUserImageResponse, error) {
	rsp, err := c.DeleteUserImage(ctx, userId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserImageResponse(rsp)
}

// GetUserImageWithResponse request returning *GetUserImageResponse
func (c *ClientWithResponses) GetUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *GetUserImageParams, reqEditors ...RequestEditorFn) (*GetUserImageResponse, error) {
	rsp, err := c.GetUserImage(ctx, userId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserImageResponse(rsp)
}

// HeadUserImageWithResponse request returning *HeadUserImageResponse
func (c *ClientWithResponses) HeadUserImageWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *HeadUserImageParams, reqEditors ...RequestEditorFn) (*HeadUserImageResponse, error) {
	rsp, err := c.HeadUserImage(ctx, userId, imageType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadUserImageResponse(rsp)
}

// PostUserImageWithBodyWithResponse request with arbitrary body returning *PostUserImageResponse
func (c *ClientWithResponses) PostUserImageWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, params *PostUserImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserImageResponse, error) {
	rsp, err := c.PostUserImageWithBody(ctx, userId, imageType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserImageResponse(rsp)
}

// GetUserImageByIndexWithResponse request returning *GetUserImageByIndexResponse
func (c *ClientWithResponses) GetUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *GetUserImageByIndexParams, reqEditors ...RequestEditorFn) (*GetUserImageByIndexResponse, error) {
	rsp, err := c.GetUserImageByIndex(ctx, userId, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserImageByIndexResponse(rsp)
}

// HeadUserImageByIndexWithResponse request returning *HeadUserImageByIndexResponse
func (c *ClientWithResponses) HeadUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, imageIndex int32, params *HeadUserImageByIndexParams, reqEditors ...RequestEditorFn) (*HeadUserImageByIndexResponse, error) {
	rsp, err := c.HeadUserImageByIndex(ctx, userId, imageType, imageIndex, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadUserImageByIndexResponse(rsp)
}

// DeleteUserImageByIndexWithResponse request returning *DeleteUserImageByIndexResponse
func (c *ClientWithResponses) DeleteUserImageByIndexWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, reqEditors ...RequestEditorFn) (*DeleteUserImageByIndexResponse, error) {
	rsp, err := c.DeleteUserImageByIndex(ctx, userId, imageType, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserImageByIndexResponse(rsp)
}

// PostUserImageByIndexWithBodyWithResponse request with arbitrary body returning *PostUserImageByIndexResponse
func (c *ClientWithResponses) PostUserImageByIndexWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, imageType ImageType, index int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUserImageByIndexResponse, error) {
	rsp, err := c.PostUserImageByIndexWithBody(ctx, userId, imageType, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserImageByIndexResponse(rsp)
}

// GetItemsByUserIdWithResponse request returning *GetItemsByUserIdResponse
func (c *ClientWithResponses) GetItemsByUserIdWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetItemsByUserIdParams, reqEditors ...RequestEditorFn) (*GetItemsByUserIdResponse, error) {
	rsp, err := c.GetItemsByUserId(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsByUserIdResponse(rsp)
}

// GetLatestMediaWithResponse request returning *GetLatestMediaResponse
func (c *ClientWithResponses) GetLatestMediaWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetLatestMediaParams, reqEditors ...RequestEditorFn) (*GetLatestMediaResponse, error) {
	rsp, err := c.GetLatestMedia(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestMediaResponse(rsp)
}

// GetResumeItemsWithResponse request returning *GetResumeItemsResponse
func (c *ClientWithResponses) GetResumeItemsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetResumeItemsParams, reqEditors ...RequestEditorFn) (*GetResumeItemsResponse, error) {
	rsp, err := c.GetResumeItems(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResumeItemsResponse(rsp)
}

// GetRootFolderWithResponse request returning *GetRootFolderResponse
func (c *ClientWithResponses) GetRootFolderWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetRootFolderResponse, error) {
	rsp, err := c.GetRootFolder(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootFolderResponse(rsp)
}

// GetItemWithResponse request returning *GetItemResponse
func (c *ClientWithResponses) GetItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetItemResponse, error) {
	rsp, err := c.GetItem(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemResponse(rsp)
}

// GetIntrosWithResponse request returning *GetIntrosResponse
func (c *ClientWithResponses) GetIntrosWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetIntrosResponse, error) {
	rsp, err := c.GetIntros(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntrosResponse(rsp)
}

// GetLocalTrailersWithResponse request returning *GetLocalTrailersResponse
func (c *ClientWithResponses) GetLocalTrailersWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetLocalTrailersResponse, error) {
	rsp, err := c.GetLocalTrailers(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalTrailersResponse(rsp)
}

// DeleteUserItemRatingWithResponse request returning *DeleteUserItemRatingResponse
func (c *ClientWithResponses) DeleteUserItemRatingWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserItemRatingResponse, error) {
	rsp, err := c.DeleteUserItemRating(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserItemRatingResponse(rsp)
}

// UpdateUserItemRatingWithResponse request returning *UpdateUserItemRatingResponse
func (c *ClientWithResponses) UpdateUserItemRatingWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *UpdateUserItemRatingParams, reqEditors ...RequestEditorFn) (*UpdateUserItemRatingResponse, error) {
	rsp, err := c.UpdateUserItemRating(ctx, userId, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserItemRatingResponse(rsp)
}

// GetSpecialFeaturesWithResponse request returning *GetSpecialFeaturesResponse
func (c *ClientWithResponses) GetSpecialFeaturesWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSpecialFeaturesResponse, error) {
	rsp, err := c.GetSpecialFeatures(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpecialFeaturesResponse(rsp)
}

// UpdateUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserPasswordResponse
func (c *ClientWithResponses) UpdateUserPasswordWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithApplicationWildcardPlusJSONBody(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPassword(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

// MarkUnplayedItemWithResponse request returning *MarkUnplayedItemResponse
func (c *ClientWithResponses) MarkUnplayedItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*MarkUnplayedItemResponse, error) {
	rsp, err := c.MarkUnplayedItem(ctx, userId, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkUnplayedItemResponse(rsp)
}

// MarkPlayedItemWithResponse request returning *MarkPlayedItemResponse
func (c *ClientWithResponses) MarkPlayedItemWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *MarkPlayedItemParams, reqEditors ...RequestEditorFn) (*MarkPlayedItemResponse, error) {
	rsp, err := c.MarkPlayedItem(ctx, userId, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPlayedItemResponse(rsp)
}

// OnPlaybackStoppedWithResponse request returning *OnPlaybackStoppedResponse
func (c *ClientWithResponses) OnPlaybackStoppedWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStoppedParams, reqEditors ...RequestEditorFn) (*OnPlaybackStoppedResponse, error) {
	rsp, err := c.OnPlaybackStopped(ctx, userId, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOnPlaybackStoppedResponse(rsp)
}

// OnPlaybackStartWithResponse request returning *OnPlaybackStartResponse
func (c *ClientWithResponses) OnPlaybackStartWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackStartParams, reqEditors ...RequestEditorFn) (*OnPlaybackStartResponse, error) {
	rsp, err := c.OnPlaybackStart(ctx, userId, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOnPlaybackStartResponse(rsp)
}

// OnPlaybackProgressWithResponse request returning *OnPlaybackProgressResponse
func (c *ClientWithResponses) OnPlaybackProgressWithResponse(ctx context.Context, userId openapi_types.UUID, itemId openapi_types.UUID, params *OnPlaybackProgressParams, reqEditors ...RequestEditorFn) (*OnPlaybackProgressResponse, error) {
	rsp, err := c.OnPlaybackProgress(ctx, userId, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOnPlaybackProgressResponse(rsp)
}

// UpdateUserPolicyWithBodyWithResponse request with arbitrary body returning *UpdateUserPolicyResponse
func (c *ClientWithResponses) UpdateUserPolicyWithBodyWithResponse(ctx context.Context, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error) {
	rsp, err := c.UpdateUserPolicyWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPolicyWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error) {
	rsp, err := c.UpdateUserPolicyWithApplicationWildcardPlusJSONBody(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPolicyWithResponse(ctx context.Context, userId openapi_types.UUID, body UpdateUserPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPolicyResponse, error) {
	rsp, err := c.UpdateUserPolicy(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPolicyResponse(rsp)
}

// GetSuggestionsWithResponse request returning *GetSuggestionsResponse
func (c *ClientWithResponses) GetSuggestionsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetSuggestionsParams, reqEditors ...RequestEditorFn) (*GetSuggestionsResponse, error) {
	rsp, err := c.GetSuggestions(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSuggestionsResponse(rsp)
}

// GetUserViewsWithResponse request returning *GetUserViewsResponse
func (c *ClientWithResponses) GetUserViewsWithResponse(ctx context.Context, userId openapi_types.UUID, params *GetUserViewsParams, reqEditors ...RequestEditorFn) (*GetUserViewsResponse, error) {
	rsp, err := c.GetUserViews(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserViewsResponse(rsp)
}

// StopEncodingProcessWithResponse request returning *StopEncodingProcessResponse
func (c *ClientWithResponses) StopEncodingProcessWithResponse(ctx context.Context, params *StopEncodingProcessParams, reqEditors ...RequestEditorFn) (*StopEncodingProcessResponse, error) {
	rsp, err := c.StopEncodingProcess(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopEncodingProcessResponse(rsp)
}

// MergeVersionsWithResponse request returning *MergeVersionsResponse
func (c *ClientWithResponses) MergeVersionsWithResponse(ctx context.Context, params *MergeVersionsParams, reqEditors ...RequestEditorFn) (*MergeVersionsResponse, error) {
	rsp, err := c.MergeVersions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeVersionsResponse(rsp)
}

// GetAdditionalPartWithResponse request returning *GetAdditionalPartResponse
func (c *ClientWithResponses) GetAdditionalPartWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetAdditionalPartParams, reqEditors ...RequestEditorFn) (*GetAdditionalPartResponse, error) {
	rsp, err := c.GetAdditionalPart(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdditionalPartResponse(rsp)
}

// DeleteAlternateSourcesWithResponse request returning *DeleteAlternateSourcesResponse
func (c *ClientWithResponses) DeleteAlternateSourcesWithResponse(ctx context.Context, itemId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAlternateSourcesResponse, error) {
	rsp, err := c.DeleteAlternateSources(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAlternateSourcesResponse(rsp)
}

// UploadSubtitleWithBodyWithResponse request with arbitrary body returning *UploadSubtitleResponse
func (c *ClientWithResponses) UploadSubtitleWithBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error) {
	rsp, err := c.UploadSubtitleWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSubtitleResponse(rsp)
}

func (c *ClientWithResponses) UploadSubtitleWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error) {
	rsp, err := c.UploadSubtitleWithApplicationWildcardPlusJSONBody(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSubtitleResponse(rsp)
}

func (c *ClientWithResponses) UploadSubtitleWithResponse(ctx context.Context, itemId openapi_types.UUID, body UploadSubtitleJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadSubtitleResponse, error) {
	rsp, err := c.UploadSubtitle(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSubtitleResponse(rsp)
}

// DeleteSubtitleWithResponse request returning *DeleteSubtitleResponse
func (c *ClientWithResponses) DeleteSubtitleWithResponse(ctx context.Context, itemId openapi_types.UUID, index int32, reqEditors ...RequestEditorFn) (*DeleteSubtitleResponse, error) {
	rsp, err := c.DeleteSubtitle(ctx, itemId, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubtitleResponse(rsp)
}

// GetHlsPlaylistLegacyWithResponse request returning *GetHlsPlaylistLegacyResponse
func (c *ClientWithResponses) GetHlsPlaylistLegacyWithResponse(ctx context.Context, itemId string, playlistId string, reqEditors ...RequestEditorFn) (*GetHlsPlaylistLegacyResponse, error) {
	rsp, err := c.GetHlsPlaylistLegacy(ctx, itemId, playlistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsPlaylistLegacyResponse(rsp)
}

// GetHlsVideoSegmentLegacyWithResponse request returning *GetHlsVideoSegmentLegacyResponse
func (c *ClientWithResponses) GetHlsVideoSegmentLegacyWithResponse(ctx context.Context, itemId string, playlistId string, segmentId string, segmentContainer string, reqEditors ...RequestEditorFn) (*GetHlsVideoSegmentLegacyResponse, error) {
	rsp, err := c.GetHlsVideoSegmentLegacy(ctx, itemId, playlistId, segmentId, segmentContainer, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsVideoSegmentLegacyResponse(rsp)
}

// GetHlsVideoSegmentWithResponse request returning *GetHlsVideoSegmentResponse
func (c *ClientWithResponses) GetHlsVideoSegmentWithResponse(ctx context.Context, itemId openapi_types.UUID, playlistId string, segmentId int32, container string, params *GetHlsVideoSegmentParams, reqEditors ...RequestEditorFn) (*GetHlsVideoSegmentResponse, error) {
	rsp, err := c.GetHlsVideoSegment(ctx, itemId, playlistId, segmentId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHlsVideoSegmentResponse(rsp)
}

// GetLiveHlsStreamWithResponse request returning *GetLiveHlsStreamResponse
func (c *ClientWithResponses) GetLiveHlsStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetLiveHlsStreamParams, reqEditors ...RequestEditorFn) (*GetLiveHlsStreamResponse, error) {
	rsp, err := c.GetLiveHlsStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveHlsStreamResponse(rsp)
}

// GetVariantHlsVideoPlaylistWithResponse request returning *GetVariantHlsVideoPlaylistResponse
func (c *ClientWithResponses) GetVariantHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVariantHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*GetVariantHlsVideoPlaylistResponse, error) {
	rsp, err := c.GetVariantHlsVideoPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariantHlsVideoPlaylistResponse(rsp)
}

// GetMasterHlsVideoPlaylistWithResponse request returning *GetMasterHlsVideoPlaylistResponse
func (c *ClientWithResponses) GetMasterHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*GetMasterHlsVideoPlaylistResponse, error) {
	rsp, err := c.GetMasterHlsVideoPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMasterHlsVideoPlaylistResponse(rsp)
}

// HeadMasterHlsVideoPlaylistWithResponse request returning *HeadMasterHlsVideoPlaylistResponse
func (c *ClientWithResponses) HeadMasterHlsVideoPlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadMasterHlsVideoPlaylistParams, reqEditors ...RequestEditorFn) (*HeadMasterHlsVideoPlaylistResponse, error) {
	rsp, err := c.HeadMasterHlsVideoPlaylist(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadMasterHlsVideoPlaylistResponse(rsp)
}

// GetVideoStreamWithResponse request returning *GetVideoStreamResponse
func (c *ClientWithResponses) GetVideoStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *GetVideoStreamParams, reqEditors ...RequestEditorFn) (*GetVideoStreamResponse, error) {
	rsp, err := c.GetVideoStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideoStreamResponse(rsp)
}

// HeadVideoStreamWithResponse request returning *HeadVideoStreamResponse
func (c *ClientWithResponses) HeadVideoStreamWithResponse(ctx context.Context, itemId openapi_types.UUID, params *HeadVideoStreamParams, reqEditors ...RequestEditorFn) (*HeadVideoStreamResponse, error) {
	rsp, err := c.HeadVideoStream(ctx, itemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadVideoStreamResponse(rsp)
}

// GetVideoStreamByContainerWithResponse request returning *GetVideoStreamByContainerResponse
func (c *ClientWithResponses) GetVideoStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *GetVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*GetVideoStreamByContainerResponse, error) {
	rsp, err := c.GetVideoStreamByContainer(ctx, itemId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideoStreamByContainerResponse(rsp)
}

// HeadVideoStreamByContainerWithResponse request returning *HeadVideoStreamByContainerResponse
func (c *ClientWithResponses) HeadVideoStreamByContainerWithResponse(ctx context.Context, itemId openapi_types.UUID, container string, params *HeadVideoStreamByContainerParams, reqEditors ...RequestEditorFn) (*HeadVideoStreamByContainerResponse, error) {
	rsp, err := c.HeadVideoStreamByContainer(ctx, itemId, container, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadVideoStreamByContainerResponse(rsp)
}

// GetSubtitlePlaylistWithResponse request returning *GetSubtitlePlaylistResponse
func (c *ClientWithResponses) GetSubtitlePlaylistWithResponse(ctx context.Context, itemId openapi_types.UUID, mediaSourceId string, index int32, params *GetSubtitlePlaylistParams, reqEditors ...RequestEditorFn) (*GetSubtitlePlaylistResponse, error) {
	rsp, err := c.GetSubtitlePlaylist(ctx, itemId, mediaSourceId, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubtitlePlaylistResponse(rsp)
}

// GetSubtitleWithResponse request returning *GetSubtitleResponse
func (c *ClientWithResponses) GetSubtitleWithResponse(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeFormat string, params *GetSubtitleParams, reqEditors ...RequestEditorFn) (*GetSubtitleResponse, error) {
	rsp, err := c.GetSubtitle(ctx, routeItemId, routeMediaSourceId, routeIndex, routeFormat, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubtitleResponse(rsp)
}

// GetSubtitleWithTicksWithResponse request returning *GetSubtitleWithTicksResponse
func (c *ClientWithResponses) GetSubtitleWithTicksWithResponse(ctx context.Context, routeItemId openapi_types.UUID, routeMediaSourceId string, routeIndex int32, routeStartPositionTicks int64, routeFormat string, params *GetSubtitleWithTicksParams, reqEditors ...RequestEditorFn) (*GetSubtitleWithTicksResponse, error) {
	rsp, err := c.GetSubtitleWithTicks(ctx, routeItemId, routeMediaSourceId, routeIndex, routeStartPositionTicks, routeFormat, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubtitleWithTicksResponse(rsp)
}

// GetAttachmentWithResponse request returning *GetAttachmentResponse
func (c *ClientWithResponses) GetAttachmentWithResponse(ctx context.Context, videoId openapi_types.UUID, mediaSourceId string, index int32, reqEditors ...RequestEditorFn) (*GetAttachmentResponse, error) {
	rsp, err := c.GetAttachment(ctx, videoId, mediaSourceId, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentResponse(rsp)
}

// GetYearsWithResponse request returning *GetYearsResponse
func (c *ClientWithResponses) GetYearsWithResponse(ctx context.Context, params *GetYearsParams, reqEditors ...RequestEditorFn) (*GetYearsResponse, error) {
	rsp, err := c.GetYears(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetYearsResponse(rsp)
}

// GetYearWithResponse request returning *GetYearResponse
func (c *ClientWithResponses) GetYearWithResponse(ctx context.Context, year int32, params *GetYearParams, reqEditors ...RequestEditorFn) (*GetYearResponse, error) {
	rsp, err := c.GetYear(ctx, year, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetYearResponse(rsp)
}

// GetDurationHistogramReportWithResponse request returning *GetDurationHistogramReportResponse
func (c *ClientWithResponses) GetDurationHistogramReportWithResponse(ctx context.Context, params *GetDurationHistogramReportParams, reqEditors ...RequestEditorFn) (*GetDurationHistogramReportResponse, error) {
	rsp, err := c.GetDurationHistogramReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDurationHistogramReportResponse(rsp)
}

// GetTvShowsReportWithResponse request returning *GetTvShowsReportResponse
func (c *ClientWithResponses) GetTvShowsReportWithResponse(ctx context.Context, params *GetTvShowsReportParams, reqEditors ...RequestEditorFn) (*GetTvShowsReportResponse, error) {
	rsp, err := c.GetTvShowsReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTvShowsReportResponse(rsp)
}

// GetHourlyReportWithResponse request returning *GetHourlyReportResponse
func (c *ClientWithResponses) GetHourlyReportWithResponse(ctx context.Context, params *GetHourlyReportParams, reqEditors ...RequestEditorFn) (*GetHourlyReportResponse, error) {
	rsp, err := c.GetHourlyReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHourlyReportResponse(rsp)
}

// GetMovieReportWithResponse request returning *GetMovieReportResponse
func (c *ClientWithResponses) GetMovieReportWithResponse(ctx context.Context, params *GetMovieReportParams, reqEditors ...RequestEditorFn) (*GetMovieReportResponse, error) {
	rsp, err := c.GetMovieReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMovieReportResponse(rsp)
}

// GetUsageStatsWithResponse request returning *GetUsageStatsResponse
func (c *ClientWithResponses) GetUsageStatsWithResponse(ctx context.Context, params *GetUsageStatsParams, reqEditors ...RequestEditorFn) (*GetUsageStatsResponse, error) {
	rsp, err := c.GetUsageStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageStatsResponse(rsp)
}

// LoadBackupWithResponse request returning *LoadBackupResponse
func (c *ClientWithResponses) LoadBackupWithResponse(ctx context.Context, params *LoadBackupParams, reqEditors ...RequestEditorFn) (*LoadBackupResponse, error) {
	rsp, err := c.LoadBackup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBackupResponse(rsp)
}

// SaveBackupWithResponse request returning *SaveBackupResponse
func (c *ClientWithResponses) SaveBackupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SaveBackupResponse, error) {
	rsp, err := c.SaveBackup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveBackupResponse(rsp)
}

// CustomQueryWithBodyWithResponse request with arbitrary body returning *CustomQueryResponse
func (c *ClientWithResponses) CustomQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error) {
	rsp, err := c.CustomQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomQueryResponse(rsp)
}

func (c *ClientWithResponses) CustomQueryWithApplicationWildcardPlusJSONBodyWithResponse(ctx context.Context, body CustomQueryApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error) {
	rsp, err := c.CustomQueryWithApplicationWildcardPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomQueryResponse(rsp)
}

func (c *ClientWithResponses) CustomQueryWithResponse(ctx context.Context, body CustomQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*CustomQueryResponse, error) {
	rsp, err := c.CustomQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomQueryResponse(rsp)
}

// GetTypeFilterListWithResponse request returning *GetTypeFilterListResponse
func (c *ClientWithResponses) GetTypeFilterListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypeFilterListResponse, error) {
	rsp, err := c.GetTypeFilterList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypeFilterListResponse(rsp)
}

// GetUserReportWithResponse request returning *GetUserReportResponse
func (c *ClientWithResponses) GetUserReportWithResponse(ctx context.Context, params *GetUserReportParams, reqEditors ...RequestEditorFn) (*GetUserReportResponse, error) {
	rsp, err := c.GetUserReport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserReportResponse(rsp)
}

// GetJellyfinUsersWithResponse request returning *GetJellyfinUsersResponse
func (c *ClientWithResponses) GetJellyfinUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJellyfinUsersResponse, error) {
	rsp, err := c.GetJellyfinUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJellyfinUsersResponse(rsp)
}

// IgnoreListAddWithResponse request returning *IgnoreListAddResponse
func (c *ClientWithResponses) IgnoreListAddWithResponse(ctx context.Context, params *IgnoreListAddParams, reqEditors ...RequestEditorFn) (*IgnoreListAddResponse, error) {
	rsp, err := c.IgnoreListAdd(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIgnoreListAddResponse(rsp)
}

// PruneUnknownUsersWithResponse request returning *PruneUnknownUsersResponse
func (c *ClientWithResponses) PruneUnknownUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PruneUnknownUsersResponse, error) {
	rsp, err := c.PruneUnknownUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePruneUnknownUsersResponse(rsp)
}

// IgnoreListRemoveWithResponse request returning *IgnoreListRemoveResponse
func (c *ClientWithResponses) IgnoreListRemoveWithResponse(ctx context.Context, params *IgnoreListRemoveParams, reqEditors ...RequestEditorFn) (*IgnoreListRemoveResponse, error) {
	rsp, err := c.IgnoreListRemove(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIgnoreListRemoveResponse(rsp)
}

// GetBreakdownReportWithResponse request returning *GetBreakdownReportResponse
func (c *ClientWithResponses) GetBreakdownReportWithResponse(ctx context.Context, breakdownType string, params *GetBreakdownReportParams, reqEditors ...RequestEditorFn) (*GetBreakdownReportResponse, error) {
	rsp, err := c.GetBreakdownReport(ctx, breakdownType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBreakdownReportResponse(rsp)
}

// GetUserReportDataWithResponse request returning *GetUserReportDataResponse
func (c *ClientWithResponses) GetUserReportDataWithResponse(ctx context.Context, userId string, date string, params *GetUserReportDataParams, reqEditors ...RequestEditorFn) (*GetUserReportDataResponse, error) {
	rsp, err := c.GetUserReportData(ctx, userId, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserReportDataResponse(rsp)
}

// GetDashboardConfigurationPageWithResponse request returning *GetDashboardConfigurationPageResponse
func (c *ClientWithResponses) GetDashboardConfigurationPageWithResponse(ctx context.Context, params *GetDashboardConfigurationPageParams, reqEditors ...RequestEditorFn) (*GetDashboardConfigurationPageResponse, error) {
	rsp, err := c.GetDashboardConfigurationPage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDashboardConfigurationPageResponse(rsp)
}

// GetConfigurationPagesWithResponse request returning *GetConfigurationPagesResponse
func (c *ClientWithResponses) GetConfigurationPagesWithResponse(ctx context.Context, params *GetConfigurationPagesParams, reqEditors ...RequestEditorFn) (*GetConfigurationPagesResponse, error) {
	rsp, err := c.GetConfigurationPages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationPagesResponse(rsp)
}

// ParseGetInstantMixFromAlbumResponse parses an HTTP response from a GetInstantMixFromAlbumWithResponse call
func ParseGetInstantMixFromAlbumResponse(rsp *http.Response) (*GetInstantMixFromAlbumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromAlbumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSimilarAlbumsResponse parses an HTTP response from a GetSimilarAlbumsWithResponse call
func ParseGetSimilarAlbumsResponse(rsp *http.Response) (*GetSimilarAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetArtistsResponse parses an HTTP response from a GetArtistsWithResponse call
func ParseGetArtistsResponse(rsp *http.Response) (*GetArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetAlbumArtistsResponse parses an HTTP response from a GetAlbumArtistsWithResponse call
func ParseGetAlbumArtistsResponse(rsp *http.Response) (*GetAlbumArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlbumArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromArtists2Response parses an HTTP response from a GetInstantMixFromArtists2WithResponse call
func ParseGetInstantMixFromArtists2Response(rsp *http.Response) (*GetInstantMixFromArtists2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromArtists2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromArtistsResponse parses an HTTP response from a GetInstantMixFromArtistsWithResponse call
func ParseGetInstantMixFromArtistsResponse(rsp *http.Response) (*GetInstantMixFromArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSimilarArtistsResponse parses an HTTP response from a GetSimilarArtistsWithResponse call
func ParseGetSimilarArtistsResponse(rsp *http.Response) (*GetSimilarArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetArtistByNameResponse parses an HTTP response from a GetArtistByNameWithResponse call
func ParseGetArtistByNameResponse(rsp *http.Response) (*GetArtistByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtistByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetArtistImageResponse parses an HTTP response from a GetArtistImageWithResponse call
func ParseGetArtistImageResponse(rsp *http.Response) (*GetArtistImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtistImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadArtistImageResponse parses an HTTP response from a HeadArtistImageWithResponse call
func ParseHeadArtistImageResponse(rsp *http.Response) (*HeadArtistImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadArtistImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetHlsAudioSegmentLegacyAacResponse parses an HTTP response from a GetHlsAudioSegmentLegacyAacWithResponse call
func ParseGetHlsAudioSegmentLegacyAacResponse(rsp *http.Response) (*GetHlsAudioSegmentLegacyAacResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsAudioSegmentLegacyAacResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHlsAudioSegmentLegacyMp3Response parses an HTTP response from a GetHlsAudioSegmentLegacyMp3WithResponse call
func ParseGetHlsAudioSegmentLegacyMp3Response(rsp *http.Response) (*GetHlsAudioSegmentLegacyMp3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsAudioSegmentLegacyMp3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHlsAudioSegmentResponse parses an HTTP response from a GetHlsAudioSegmentWithResponse call
func ParseGetHlsAudioSegmentResponse(rsp *http.Response) (*GetHlsAudioSegmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsAudioSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVariantHlsAudioPlaylistResponse parses an HTTP response from a GetVariantHlsAudioPlaylistWithResponse call
func ParseGetVariantHlsAudioPlaylistResponse(rsp *http.Response) (*GetVariantHlsAudioPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariantHlsAudioPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMasterHlsAudioPlaylistResponse parses an HTTP response from a GetMasterHlsAudioPlaylistWithResponse call
func ParseGetMasterHlsAudioPlaylistResponse(rsp *http.Response) (*GetMasterHlsAudioPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterHlsAudioPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadMasterHlsAudioPlaylistResponse parses an HTTP response from a HeadMasterHlsAudioPlaylistWithResponse call
func ParseHeadMasterHlsAudioPlaylistResponse(rsp *http.Response) (*HeadMasterHlsAudioPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadMasterHlsAudioPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAudioStreamResponse parses an HTTP response from a GetAudioStreamWithResponse call
func ParseGetAudioStreamResponse(rsp *http.Response) (*GetAudioStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadAudioStreamResponse parses an HTTP response from a HeadAudioStreamWithResponse call
func ParseHeadAudioStreamResponse(rsp *http.Response) (*HeadAudioStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadAudioStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAudioStreamByContainerResponse parses an HTTP response from a GetAudioStreamByContainerWithResponse call
func ParseGetAudioStreamByContainerResponse(rsp *http.Response) (*GetAudioStreamByContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioStreamByContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadAudioStreamByContainerResponse parses an HTTP response from a HeadAudioStreamByContainerWithResponse call
func ParseHeadAudioStreamByContainerResponse(rsp *http.Response) (*HeadAudioStreamByContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadAudioStreamByContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUniversalAudioStreamResponse parses an HTTP response from a GetUniversalAudioStreamWithResponse call
func ParseGetUniversalAudioStreamResponse(rsp *http.Response) (*GetUniversalAudioStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUniversalAudioStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadUniversalAudioStreamResponse parses an HTTP response from a HeadUniversalAudioStreamWithResponse call
func ParseHeadUniversalAudioStreamResponse(rsp *http.Response) (*HeadUniversalAudioStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadUniversalAudioStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetKeysResponse parses an HTTP response from a GetKeysWithResponse call
func ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationInfoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateKeyResponse parses an HTTP response from a CreateKeyWithResponse call
func ParseCreateKeyResponse(rsp *http.Response) (*CreateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRevokeKeyResponse parses an HTTP response from a RevokeKeyWithResponse call
func ParseRevokeKeyResponse(rsp *http.Response) (*RevokeKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPasswordResetProvidersResponse parses an HTTP response from a GetPasswordResetProvidersWithResponse call
func ParseGetPasswordResetProvidersResponse(rsp *http.Response) (*GetPasswordResetProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPasswordResetProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NameIdPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetAuthProvidersResponse parses an HTTP response from a GetAuthProvidersWithResponse call
func ParseGetAuthProvidersResponse(rsp *http.Response) (*GetAuthProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NameIdPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetBrandingOptionsResponse parses an HTTP response from a GetBrandingOptionsWithResponse call
func ParseGetBrandingOptionsResponse(rsp *http.Response) (*GetBrandingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrandingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandingOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetBrandingCssResponse parses an HTTP response from a GetBrandingCssWithResponse call
func ParseGetBrandingCssResponse(rsp *http.Response) (*GetBrandingCssResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrandingCssResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/css) unsupported

	}

	return response, nil
}

// ParseGetBrandingCss2Response parses an HTTP response from a GetBrandingCss2WithResponse call
func ParseGetBrandingCss2Response(rsp *http.Response) (*GetBrandingCss2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBrandingCss2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/css) unsupported

	}

	return response, nil
}

// ParseDeleteCustomSplashscreenResponse parses an HTTP response from a DeleteCustomSplashscreenWithResponse call
func ParseDeleteCustomSplashscreenResponse(rsp *http.Response) (*DeleteCustomSplashscreenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomSplashscreenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSplashscreenResponse parses an HTTP response from a GetSplashscreenWithResponse call
func ParseGetSplashscreenResponse(rsp *http.Response) (*GetSplashscreenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSplashscreenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadCustomSplashscreenResponse parses an HTTP response from a UploadCustomSplashscreenWithResponse call
func ParseUploadCustomSplashscreenResponse(rsp *http.Response) (*UploadCustomSplashscreenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCustomSplashscreenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetChannelsResponse parses an HTTP response from a GetChannelsWithResponse call
func ParseGetChannelsResponse(rsp *http.Response) (*GetChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetAllChannelFeaturesResponse parses an HTTP response from a GetAllChannelFeaturesWithResponse call
func ParseGetAllChannelFeaturesResponse(rsp *http.Response) (*GetAllChannelFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllChannelFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelFeatures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLatestChannelItemsResponse parses an HTTP response from a GetLatestChannelItemsWithResponse call
func ParseGetLatestChannelItemsResponse(rsp *http.Response) (*GetLatestChannelItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestChannelItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetChannelFeaturesResponse parses an HTTP response from a GetChannelFeaturesWithResponse call
func ParseGetChannelFeaturesResponse(rsp *http.Response) (*GetChannelFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelFeatures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetChannelItemsResponse parses an HTTP response from a GetChannelItemsWithResponse call
func ParseGetChannelItemsResponse(rsp *http.Response) (*GetChannelItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseLogFileResponse parses an HTTP response from a LogFileWithResponse call
func ParseLogFileResponse(rsp *http.Response) (*LogFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientLogDocumentResponseDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 413:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionCreationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRemoveFromCollectionResponse parses an HTTP response from a RemoveFromCollectionWithResponse call
func ParseRemoveFromCollectionResponse(rsp *http.Response) (*RemoveFromCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveFromCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddToCollectionResponse parses an HTTP response from a AddToCollectionWithResponse call
func ParseAddToCollectionResponse(rsp *http.Response) (*AddToCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddToCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDeviceResponse parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResponse(rsp *http.Response) (*DeleteDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDevicesResponse parses an HTTP response from a GetDevicesWithResponse call
func ParseGetDevicesResponse(rsp *http.Response) (*GetDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceInfoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDeviceInfoResponse parses an HTTP response from a GetDeviceInfoWithResponse call
func ParseGetDeviceInfoResponse(rsp *http.Response) (*GetDeviceInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDeviceOptionsResponse parses an HTTP response from a GetDeviceOptionsWithResponse call
func ParseGetDeviceOptionsResponse(rsp *http.Response) (*GetDeviceOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateDeviceOptionsResponse parses an HTTP response from a UpdateDeviceOptionsWithResponse call
func ParseUpdateDeviceOptionsResponse(rsp *http.Response) (*UpdateDeviceOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDeviceOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDisplayPreferencesResponse parses an HTTP response from a GetDisplayPreferencesWithResponse call
func ParseGetDisplayPreferencesResponse(rsp *http.Response) (*GetDisplayPreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDisplayPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DisplayPreferencesDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateDisplayPreferencesResponse parses an HTTP response from a UpdateDisplayPreferencesWithResponse call
func ParseUpdateDisplayPreferencesResponse(rsp *http.Response) (*UpdateDisplayPreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDisplayPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProfileInfosResponse parses an HTTP response from a GetProfileInfosWithResponse call
func ParseGetProfileInfosResponse(rsp *http.Response) (*GetProfileInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeviceProfileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateProfileResponse parses an HTTP response from a CreateProfileWithResponse call
func ParseCreateProfileResponse(rsp *http.Response) (*CreateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultProfileResponse parses an HTTP response from a GetDefaultProfileWithResponse call
func ParseGetDefaultProfileResponse(rsp *http.Response) (*GetDefaultProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteProfileResponse parses an HTTP response from a DeleteProfileWithResponse call
func ParseDeleteProfileResponse(rsp *http.Response) (*DeleteProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetProfileResponse parses an HTTP response from a GetProfileWithResponse call
func ParseGetProfileResponse(rsp *http.Response) (*GetProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetIconResponse parses an HTTP response from a GetIconWithResponse call
func ParseGetIconResponse(rsp *http.Response) (*GetIconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetConnectionManagerResponse parses an HTTP response from a GetConnectionManagerWithResponse call
func ParseGetConnectionManagerResponse(rsp *http.Response) (*GetConnectionManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetConnectionManager2Response parses an HTTP response from a GetConnectionManager2WithResponse call
func ParseGetConnectionManager2Response(rsp *http.Response) (*GetConnectionManager2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionManager2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetConnectionManager3Response parses an HTTP response from a GetConnectionManager3WithResponse call
func ParseGetConnectionManager3Response(rsp *http.Response) (*GetConnectionManager3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionManager3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseProcessConnectionManagerControlRequestResponse parses an HTTP response from a ProcessConnectionManagerControlRequestWithResponse call
func ParseProcessConnectionManagerControlRequestResponse(rsp *http.Response) (*ProcessConnectionManagerControlRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessConnectionManagerControlRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetContentDirectoryResponse parses an HTTP response from a GetContentDirectoryWithResponse call
func ParseGetContentDirectoryResponse(rsp *http.Response) (*GetContentDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetContentDirectory2Response parses an HTTP response from a GetContentDirectory2WithResponse call
func ParseGetContentDirectory2Response(rsp *http.Response) (*GetContentDirectory2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentDirectory2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetContentDirectory3Response parses an HTTP response from a GetContentDirectory3WithResponse call
func ParseGetContentDirectory3Response(rsp *http.Response) (*GetContentDirectory3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContentDirectory3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseProcessContentDirectoryControlRequestResponse parses an HTTP response from a ProcessContentDirectoryControlRequestWithResponse call
func ParseProcessContentDirectoryControlRequestResponse(rsp *http.Response) (*ProcessContentDirectoryControlRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessContentDirectoryControlRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetMediaReceiverRegistrarResponse parses an HTTP response from a GetMediaReceiverRegistrarWithResponse call
func ParseGetMediaReceiverRegistrarResponse(rsp *http.Response) (*GetMediaReceiverRegistrarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaReceiverRegistrarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseProcessMediaReceiverRegistrarControlRequestResponse parses an HTTP response from a ProcessMediaReceiverRegistrarControlRequestWithResponse call
func ParseProcessMediaReceiverRegistrarControlRequestResponse(rsp *http.Response) (*ProcessMediaReceiverRegistrarControlRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessMediaReceiverRegistrarControlRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetMediaReceiverRegistrar2Response parses an HTTP response from a GetMediaReceiverRegistrar2WithResponse call
func ParseGetMediaReceiverRegistrar2Response(rsp *http.Response) (*GetMediaReceiverRegistrar2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaReceiverRegistrar2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetMediaReceiverRegistrar3Response parses an HTTP response from a GetMediaReceiverRegistrar3WithResponse call
func ParseGetMediaReceiverRegistrar3Response(rsp *http.Response) (*GetMediaReceiverRegistrar3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaReceiverRegistrar3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetDescriptionXmlResponse parses an HTTP response from a GetDescriptionXmlWithResponse call
func ParseGetDescriptionXmlResponse(rsp *http.Response) (*GetDescriptionXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDescriptionXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetDescriptionXml2Response parses an HTTP response from a GetDescriptionXml2WithResponse call
func ParseGetDescriptionXml2Response(rsp *http.Response) (*GetDescriptionXml2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDescriptionXml2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetIconIdResponse parses an HTTP response from a GetIconIdWithResponse call
func ParseGetIconIdResponse(rsp *http.Response) (*GetIconIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIconIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDefaultDirectoryBrowserResponse parses an HTTP response from a GetDefaultDirectoryBrowserWithResponse call
func ParseGetDefaultDirectoryBrowserResponse(rsp *http.Response) (*GetDefaultDirectoryBrowserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultDirectoryBrowserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefaultDirectoryBrowserInfoDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDirectoryContentsResponse parses an HTTP response from a GetDirectoryContentsWithResponse call
func ParseGetDirectoryContentsResponse(rsp *http.Response) (*GetDirectoryContentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDirectoryContentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FileSystemEntryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDrivesResponse parses an HTTP response from a GetDrivesWithResponse call
func ParseGetDrivesResponse(rsp *http.Response) (*GetDrivesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDrivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FileSystemEntryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetNetworkSharesResponse parses an HTTP response from a GetNetworkSharesWithResponse call
func ParseGetNetworkSharesResponse(rsp *http.Response) (*GetNetworkSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FileSystemEntryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetParentPathResponse parses an HTTP response from a GetParentPathWithResponse call
func ParseGetParentPathResponse(rsp *http.Response) (*GetParentPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParentPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseValidatePathResponse parses an HTTP response from a ValidatePathWithResponse call
func ParseValidatePathResponse(rsp *http.Response) (*ValidatePathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidatePathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetFallbackFontListResponse parses an HTTP response from a GetFallbackFontListWithResponse call
func ParseGetFallbackFontListResponse(rsp *http.Response) (*GetFallbackFontListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFallbackFontListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FontFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetFallbackFontResponse parses an HTTP response from a GetFallbackFontWithResponse call
func ParseGetFallbackFontResponse(rsp *http.Response) (*GetFallbackFontResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFallbackFontResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGenresResponse parses an HTTP response from a GetGenresWithResponse call
func ParseGetGenresResponse(rsp *http.Response) (*GetGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGenreResponse parses an HTTP response from a GetGenreWithResponse call
func ParseGetGenreResponse(rsp *http.Response) (*GetGenreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGenreImageResponse parses an HTTP response from a GetGenreImageWithResponse call
func ParseGetGenreImageResponse(rsp *http.Response) (*GetGenreImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenreImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadGenreImageResponse parses an HTTP response from a HeadGenreImageWithResponse call
func ParseHeadGenreImageResponse(rsp *http.Response) (*HeadGenreImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadGenreImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGenreImageByIndexResponse parses an HTTP response from a GetGenreImageByIndexWithResponse call
func ParseGetGenreImageByIndexResponse(rsp *http.Response) (*GetGenreImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenreImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadGenreImageByIndexResponse parses an HTTP response from a HeadGenreImageByIndexWithResponse call
func ParseHeadGenreImageByIndexResponse(rsp *http.Response) (*HeadGenreImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadGenreImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUtcTimeResponse parses an HTTP response from a GetUtcTimeWithResponse call
func ParseGetUtcTimeResponse(rsp *http.Response) (*GetUtcTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUtcTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UtcTimeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGeneralImagesResponse parses an HTTP response from a GetGeneralImagesWithResponse call
func ParseGetGeneralImagesResponse(rsp *http.Response) (*GetGeneralImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGeneralImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImageByNameInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGeneralImageResponse parses an HTTP response from a GetGeneralImageWithResponse call
func ParseGetGeneralImageResponse(rsp *http.Response) (*GetGeneralImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGeneralImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/octet-stream) unsupported

	}

	return response, nil
}

// ParseGetMediaInfoImagesResponse parses an HTTP response from a GetMediaInfoImagesWithResponse call
func ParseGetMediaInfoImagesResponse(rsp *http.Response) (*GetMediaInfoImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaInfoImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImageByNameInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMediaInfoImageResponse parses an HTTP response from a GetMediaInfoImageWithResponse call
func ParseGetMediaInfoImageResponse(rsp *http.Response) (*GetMediaInfoImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaInfoImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/octet-stream) unsupported

	}

	return response, nil
}

// ParseGetRatingImagesResponse parses an HTTP response from a GetRatingImagesWithResponse call
func ParseGetRatingImagesResponse(rsp *http.Response) (*GetRatingImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRatingImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImageByNameInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRatingImageResponse parses an HTTP response from a GetRatingImageWithResponse call
func ParseGetRatingImageResponse(rsp *http.Response) (*GetRatingImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRatingImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/octet-stream) unsupported

	}

	return response, nil
}

// ParseDeleteItemsResponse parses an HTTP response from a DeleteItemsWithResponse call
func ParseDeleteItemsResponse(rsp *http.Response) (*DeleteItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.StatusCode == 401:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemsResponse parses an HTTP response from a GetItemsWithResponse call
func ParseGetItemsResponse(rsp *http.Response) (*GetItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemCountsResponse parses an HTTP response from a GetItemCountsWithResponse call
func ParseGetItemCountsResponse(rsp *http.Response) (*GetItemCountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemCountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemCounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetQueryFiltersLegacyResponse parses an HTTP response from a GetQueryFiltersLegacyWithResponse call
func ParseGetQueryFiltersLegacyResponse(rsp *http.Response) (*GetQueryFiltersLegacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueryFiltersLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryFiltersLegacy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetQueryFiltersResponse parses an HTTP response from a GetQueryFiltersWithResponse call
func ParseGetQueryFiltersResponse(rsp *http.Response) (*GetQueryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryFilters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseApplySearchCriteriaResponse parses an HTTP response from a ApplySearchCriteriaWithResponse call
func ParseApplySearchCriteriaResponse(rsp *http.Response) (*ApplySearchCriteriaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplySearchCriteriaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBookRemoteSearchResultsResponse parses an HTTP response from a GetBookRemoteSearchResultsWithResponse call
func ParseGetBookRemoteSearchResultsResponse(rsp *http.Response) (*GetBookRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetBoxSetRemoteSearchResultsResponse parses an HTTP response from a GetBoxSetRemoteSearchResultsWithResponse call
func ParseGetBoxSetRemoteSearchResultsResponse(rsp *http.Response) (*GetBoxSetRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBoxSetRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMovieRemoteSearchResultsResponse parses an HTTP response from a GetMovieRemoteSearchResultsWithResponse call
func ParseGetMovieRemoteSearchResultsResponse(rsp *http.Response) (*GetMovieRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicAlbumRemoteSearchResultsResponse parses an HTTP response from a GetMusicAlbumRemoteSearchResultsWithResponse call
func ParseGetMusicAlbumRemoteSearchResultsResponse(rsp *http.Response) (*GetMusicAlbumRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicAlbumRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicArtistRemoteSearchResultsResponse parses an HTTP response from a GetMusicArtistRemoteSearchResultsWithResponse call
func ParseGetMusicArtistRemoteSearchResultsResponse(rsp *http.Response) (*GetMusicArtistRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicArtistRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicVideoRemoteSearchResultsResponse parses an HTTP response from a GetMusicVideoRemoteSearchResultsWithResponse call
func ParseGetMusicVideoRemoteSearchResultsResponse(rsp *http.Response) (*GetMusicVideoRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicVideoRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPersonRemoteSearchResultsResponse parses an HTTP response from a GetPersonRemoteSearchResultsWithResponse call
func ParseGetPersonRemoteSearchResultsResponse(rsp *http.Response) (*GetPersonRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSeriesRemoteSearchResultsResponse parses an HTTP response from a GetSeriesRemoteSearchResultsWithResponse call
func ParseGetSeriesRemoteSearchResultsResponse(rsp *http.Response) (*GetSeriesRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetTrailerRemoteSearchResultsResponse parses an HTTP response from a GetTrailerRemoteSearchResultsWithResponse call
func ParseGetTrailerRemoteSearchResultsResponse(rsp *http.Response) (*GetTrailerRemoteSearchResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrailerRemoteSearchResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromItemResponse parses an HTTP response from a GetInstantMixFromItemWithResponse call
func ParseGetInstantMixFromItemResponse(rsp *http.Response) (*GetInstantMixFromItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteItemResponse parses an HTTP response from a DeleteItemWithResponse call
func ParseDeleteItemResponse(rsp *http.Response) (*DeleteItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case rsp.StatusCode == 401:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateItemResponse parses an HTTP response from a UpdateItemWithResponse call
func ParseUpdateItemResponse(rsp *http.Response) (*UpdateItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetAncestorsResponse parses an HTTP response from a GetAncestorsWithResponse call
func ParseGetAncestorsResponse(rsp *http.Response) (*GetAncestorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAncestorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateItemContentTypeResponse parses an HTTP response from a UpdateItemContentTypeWithResponse call
func ParseUpdateItemContentTypeResponse(rsp *http.Response) (*UpdateItemContentTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemContentTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetCriticReviewsResponse parses an HTTP response from a GetCriticReviewsWithResponse call
func ParseGetCriticReviewsResponse(rsp *http.Response) (*GetCriticReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCriticReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDownloadResponse parses an HTTP response from a GetDownloadWithResponse call
func ParseGetDownloadResponse(rsp *http.Response) (*GetDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetExternalIdInfosResponse parses an HTTP response from a GetExternalIdInfosWithResponse call
func ParseGetExternalIdInfosResponse(rsp *http.Response) (*GetExternalIdInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExternalIdInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ExternalIdInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemImageInfosResponse parses an HTTP response from a GetItemImageInfosWithResponse call
func ParseGetItemImageInfosResponse(rsp *http.Response) (*GetItemImageInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemImageInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteItemImageResponse parses an HTTP response from a DeleteItemImageWithResponse call
func ParseDeleteItemImageResponse(rsp *http.Response) (*DeleteItemImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemImageResponse parses an HTTP response from a GetItemImageWithResponse call
func ParseGetItemImageResponse(rsp *http.Response) (*GetItemImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadItemImageResponse parses an HTTP response from a HeadItemImageWithResponse call
func ParseHeadItemImageResponse(rsp *http.Response) (*HeadItemImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadItemImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetItemImageResponse parses an HTTP response from a SetItemImageWithResponse call
func ParseSetItemImageResponse(rsp *http.Response) (*SetItemImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetItemImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteItemImageByIndexResponse parses an HTTP response from a DeleteItemImageByIndexWithResponse call
func ParseDeleteItemImageByIndexResponse(rsp *http.Response) (*DeleteItemImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemImageByIndexResponse parses an HTTP response from a GetItemImageByIndexWithResponse call
func ParseGetItemImageByIndexResponse(rsp *http.Response) (*GetItemImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadItemImageByIndexResponse parses an HTTP response from a HeadItemImageByIndexWithResponse call
func ParseHeadItemImageByIndexResponse(rsp *http.Response) (*HeadItemImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadItemImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetItemImageByIndexResponse parses an HTTP response from a SetItemImageByIndexWithResponse call
func ParseSetItemImageByIndexResponse(rsp *http.Response) (*SetItemImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetItemImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateItemImageIndexResponse parses an HTTP response from a UpdateItemImageIndexWithResponse call
func ParseUpdateItemImageIndexResponse(rsp *http.Response) (*UpdateItemImageIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemImageIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemImage2Response parses an HTTP response from a GetItemImage2WithResponse call
func ParseGetItemImage2Response(rsp *http.Response) (*GetItemImage2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemImage2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadItemImage2Response parses an HTTP response from a HeadItemImage2WithResponse call
func ParseHeadItemImage2Response(rsp *http.Response) (*HeadItemImage2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadItemImage2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMetadataEditorInfoResponse parses an HTTP response from a GetMetadataEditorInfoWithResponse call
func ParseGetMetadataEditorInfoResponse(rsp *http.Response) (*GetMetadataEditorInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetadataEditorInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataEditorInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPlaybackInfoResponse parses an HTTP response from a GetPlaybackInfoWithResponse call
func ParseGetPlaybackInfoResponse(rsp *http.Response) (*GetPlaybackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaybackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybackInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPostedPlaybackInfoResponse parses an HTTP response from a GetPostedPlaybackInfoWithResponse call
func ParseGetPostedPlaybackInfoResponse(rsp *http.Response) (*GetPostedPlaybackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostedPlaybackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaybackInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRefreshItemResponse parses an HTTP response from a RefreshItemWithResponse call
func ParseRefreshItemResponse(rsp *http.Response) (*RefreshItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRemoteImagesResponse parses an HTTP response from a GetRemoteImagesWithResponse call
func ParseGetRemoteImagesResponse(rsp *http.Response) (*GetRemoteImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteImageResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDownloadRemoteImageResponse parses an HTTP response from a DownloadRemoteImageWithResponse call
func ParseDownloadRemoteImageResponse(rsp *http.Response) (*DownloadRemoteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadRemoteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRemoteImageProvidersResponse parses an HTTP response from a GetRemoteImageProvidersWithResponse call
func ParseGetRemoteImageProvidersResponse(rsp *http.Response) (*GetRemoteImageProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteImageProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImageProviderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSearchRemoteSubtitlesResponse parses an HTTP response from a SearchRemoteSubtitlesWithResponse call
func ParseSearchRemoteSubtitlesResponse(rsp *http.Response) (*SearchRemoteSubtitlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRemoteSubtitlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RemoteSubtitleInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDownloadRemoteSubtitlesResponse parses an HTTP response from a DownloadRemoteSubtitlesWithResponse call
func ParseDownloadRemoteSubtitlesResponse(rsp *http.Response) (*DownloadRemoteSubtitlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadRemoteSubtitlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSimilarItemsResponse parses an HTTP response from a GetSimilarItemsWithResponse call
func ParseGetSimilarItemsResponse(rsp *http.Response) (*GetSimilarItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetThemeMediaResponse parses an HTTP response from a GetThemeMediaWithResponse call
func ParseGetThemeMediaResponse(rsp *http.Response) (*GetThemeMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThemeMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllThemeMediaResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetThemeSongsResponse parses an HTTP response from a GetThemeSongsWithResponse call
func ParseGetThemeSongsResponse(rsp *http.Response) (*GetThemeSongsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThemeSongsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThemeMediaResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetThemeVideosResponse parses an HTTP response from a GetThemeVideosWithResponse call
func ParseGetThemeVideosResponse(rsp *http.Response) (*GetThemeVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThemeVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThemeMediaResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseValidateLoginInfoResponse parses an HTTP response from a ValidateLoginInfoWithResponse call
func ParseValidateLoginInfoResponse(rsp *http.Response) (*ValidateLoginInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateLoginInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLibraryOptionsInfoResponse parses an HTTP response from a GetLibraryOptionsInfoWithResponse call
func ParseGetLibraryOptionsInfoResponse(rsp *http.Response) (*GetLibraryOptionsInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLibraryOptionsInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LibraryOptionsResultDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostUpdatedMediaResponse parses an HTTP response from a PostUpdatedMediaWithResponse call
func ParsePostUpdatedMediaResponse(rsp *http.Response) (*PostUpdatedMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUpdatedMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMediaFoldersResponse parses an HTTP response from a GetMediaFoldersWithResponse call
func ParseGetMediaFoldersResponse(rsp *http.Response) (*GetMediaFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMediaFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostAddedMoviesResponse parses an HTTP response from a PostAddedMoviesWithResponse call
func ParsePostAddedMoviesResponse(rsp *http.Response) (*PostAddedMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAddedMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostUpdatedMoviesResponse parses an HTTP response from a PostUpdatedMoviesWithResponse call
func ParsePostUpdatedMoviesResponse(rsp *http.Response) (*PostUpdatedMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUpdatedMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPhysicalPathsResponse parses an HTTP response from a GetPhysicalPathsWithResponse call
func ParseGetPhysicalPathsResponse(rsp *http.Response) (*GetPhysicalPathsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRefreshLibraryResponse parses an HTTP response from a RefreshLibraryWithResponse call
func ParseRefreshLibraryResponse(rsp *http.Response) (*RefreshLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostAddedSeriesResponse parses an HTTP response from a PostAddedSeriesWithResponse call
func ParsePostAddedSeriesResponse(rsp *http.Response) (*PostAddedSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAddedSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostUpdatedSeriesResponse parses an HTTP response from a PostUpdatedSeriesWithResponse call
func ParsePostUpdatedSeriesResponse(rsp *http.Response) (*PostUpdatedSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUpdatedSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveVirtualFolderResponse parses an HTTP response from a RemoveVirtualFolderWithResponse call
func ParseRemoveVirtualFolderResponse(rsp *http.Response) (*RemoveVirtualFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveVirtualFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVirtualFoldersResponse parses an HTTP response from a GetVirtualFoldersWithResponse call
func ParseGetVirtualFoldersResponse(rsp *http.Response) (*GetVirtualFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VirtualFolderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseAddVirtualFolderResponse parses an HTTP response from a AddVirtualFolderWithResponse call
func ParseAddVirtualFolderResponse(rsp *http.Response) (*AddVirtualFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateLibraryOptionsResponse parses an HTTP response from a UpdateLibraryOptionsWithResponse call
func ParseUpdateLibraryOptionsResponse(rsp *http.Response) (*UpdateLibraryOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLibraryOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRenameVirtualFolderResponse parses an HTTP response from a RenameVirtualFolderWithResponse call
func ParseRenameVirtualFolderResponse(rsp *http.Response) (*RenameVirtualFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameVirtualFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case rsp.StatusCode == 404:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 409:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRemoveMediaPathResponse parses an HTTP response from a RemoveMediaPathWithResponse call
func ParseRemoveMediaPathResponse(rsp *http.Response) (*RemoveMediaPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMediaPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMediaPathResponse parses an HTTP response from a AddMediaPathWithResponse call
func ParseAddMediaPathResponse(rsp *http.Response) (*AddMediaPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMediaPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMediaPathResponse parses an HTTP response from a UpdateMediaPathWithResponse call
func ParseUpdateMediaPathResponse(rsp *http.Response) (*UpdateMediaPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMediaPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCloseLiveStreamResponse parses an HTTP response from a CloseLiveStreamWithResponse call
func ParseCloseLiveStreamResponse(rsp *http.Response) (*CloseLiveStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseLiveStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOpenLiveStreamResponse parses an HTTP response from a OpenLiveStreamWithResponse call
func ParseOpenLiveStreamResponse(rsp *http.Response) (*OpenLiveStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenLiveStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LiveStreamResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetChannelMappingOptionsResponse parses an HTTP response from a GetChannelMappingOptionsWithResponse call
func ParseGetChannelMappingOptionsResponse(rsp *http.Response) (*GetChannelMappingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelMappingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelMappingOptionsDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetChannelMappingResponse parses an HTTP response from a SetChannelMappingWithResponse call
func ParseSetChannelMappingResponse(rsp *http.Response) (*SetChannelMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetChannelMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TunerChannelMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLiveTvChannelsResponse parses an HTTP response from a GetLiveTvChannelsWithResponse call
func ParseGetLiveTvChannelsResponse(rsp *http.Response) (*GetLiveTvChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveTvChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetChannelResponse parses an HTTP response from a GetChannelWithResponse call
func ParseGetChannelResponse(rsp *http.Response) (*GetChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGuideInfoResponse parses an HTTP response from a GetGuideInfoWithResponse call
func ParseGetGuideInfoResponse(rsp *http.Response) (*GetGuideInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGuideInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GuideInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLiveTvInfoResponse parses an HTTP response from a GetLiveTvInfoWithResponse call
func ParseGetLiveTvInfoResponse(rsp *http.Response) (*GetLiveTvInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveTvInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LiveTvInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteListingProviderResponse parses an HTTP response from a DeleteListingProviderWithResponse call
func ParseDeleteListingProviderResponse(rsp *http.Response) (*DeleteListingProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListingProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddListingProviderResponse parses an HTTP response from a AddListingProviderWithResponse call
func ParseAddListingProviderResponse(rsp *http.Response) (*AddListingProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddListingProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsProviderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDefaultListingProviderResponse parses an HTTP response from a GetDefaultListingProviderWithResponse call
func ParseGetDefaultListingProviderResponse(rsp *http.Response) (*GetDefaultListingProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultListingProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListingsProviderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLineupsResponse parses an HTTP response from a GetLineupsWithResponse call
func ParseGetLineupsResponse(rsp *http.Response) (*GetLineupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NameIdPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSchedulesDirectCountriesResponse parses an HTTP response from a GetSchedulesDirectCountriesWithResponse call
func ParseGetSchedulesDirectCountriesResponse(rsp *http.Response) (*GetSchedulesDirectCountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesDirectCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLiveRecordingFileResponse parses an HTTP response from a GetLiveRecordingFileWithResponse call
func ParseGetLiveRecordingFileResponse(rsp *http.Response) (*GetLiveRecordingFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveRecordingFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLiveStreamFileResponse parses an HTTP response from a GetLiveStreamFileWithResponse call
func ParseGetLiveStreamFileResponse(rsp *http.Response) (*GetLiveStreamFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveStreamFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLiveTvProgramsResponse parses an HTTP response from a GetLiveTvProgramsWithResponse call
func ParseGetLiveTvProgramsResponse(rsp *http.Response) (*GetLiveTvProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveTvProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetProgramsResponse parses an HTTP response from a GetProgramsWithResponse call
func ParseGetProgramsResponse(rsp *http.Response) (*GetProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecommendedProgramsResponse parses an HTTP response from a GetRecommendedProgramsWithResponse call
func ParseGetRecommendedProgramsResponse(rsp *http.Response) (*GetRecommendedProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecommendedProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingsResponse parses an HTTP response from a GetRecordingsWithResponse call
func ParseGetRecordingsResponse(rsp *http.Response) (*GetRecordingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingFoldersResponse parses an HTTP response from a GetRecordingFoldersWithResponse call
func ParseGetRecordingFoldersResponse(rsp *http.Response) (*GetRecordingFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingGroupsResponse parses an HTTP response from a GetRecordingGroupsWithResponse call
func ParseGetRecordingGroupsResponse(rsp *http.Response) (*GetRecordingGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingGroupResponse parses an HTTP response from a GetRecordingGroupWithResponse call
func ParseGetRecordingGroupResponse(rsp *http.Response) (*GetRecordingGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingsSeriesResponse parses an HTTP response from a GetRecordingsSeriesWithResponse call
func ParseGetRecordingsSeriesResponse(rsp *http.Response) (*GetRecordingsSeriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingsSeriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteRecordingResponse parses an HTTP response from a DeleteRecordingWithResponse call
func ParseDeleteRecordingResponse(rsp *http.Response) (*DeleteRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRecordingResponse parses an HTTP response from a GetRecordingWithResponse call
func ParseGetRecordingResponse(rsp *http.Response) (*GetRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSeriesTimersResponse parses an HTTP response from a GetSeriesTimersWithResponse call
func ParseGetSeriesTimersResponse(rsp *http.Response) (*GetSeriesTimersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesTimersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesTimerInfoDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateSeriesTimerResponse parses an HTTP response from a CreateSeriesTimerWithResponse call
func ParseCreateSeriesTimerResponse(rsp *http.Response) (*CreateSeriesTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSeriesTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSeriesTimerResponse parses an HTTP response from a CancelSeriesTimerWithResponse call
func ParseCancelSeriesTimerResponse(rsp *http.Response) (*CancelSeriesTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSeriesTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSeriesTimerResponse parses an HTTP response from a GetSeriesTimerWithResponse call
func ParseGetSeriesTimerResponse(rsp *http.Response) (*GetSeriesTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeriesTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesTimerInfoDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateSeriesTimerResponse parses an HTTP response from a UpdateSeriesTimerWithResponse call
func ParseUpdateSeriesTimerResponse(rsp *http.Response) (*UpdateSeriesTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSeriesTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTimersResponse parses an HTTP response from a GetTimersWithResponse call
func ParseGetTimersResponse(rsp *http.Response) (*GetTimersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimerInfoDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateTimerResponse parses an HTTP response from a CreateTimerWithResponse call
func ParseCreateTimerResponse(rsp *http.Response) (*CreateTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultTimerResponse parses an HTTP response from a GetDefaultTimerWithResponse call
func ParseGetDefaultTimerResponse(rsp *http.Response) (*GetDefaultTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SeriesTimerInfoDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCancelTimerResponse parses an HTTP response from a CancelTimerWithResponse call
func ParseCancelTimerResponse(rsp *http.Response) (*CancelTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTimerResponse parses an HTTP response from a GetTimerWithResponse call
func ParseGetTimerResponse(rsp *http.Response) (*GetTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimerInfoDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateTimerResponse parses an HTTP response from a UpdateTimerWithResponse call
func ParseUpdateTimerResponse(rsp *http.Response) (*UpdateTimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTunerHostResponse parses an HTTP response from a DeleteTunerHostWithResponse call
func ParseDeleteTunerHostResponse(rsp *http.Response) (*DeleteTunerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTunerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddTunerHostResponse parses an HTTP response from a AddTunerHostWithResponse call
func ParseAddTunerHostResponse(rsp *http.Response) (*AddTunerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTunerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TunerHostInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetTunerHostTypesResponse parses an HTTP response from a GetTunerHostTypesWithResponse call
func ParseGetTunerHostTypesResponse(rsp *http.Response) (*GetTunerHostTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTunerHostTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NameIdPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDiscoverTunersResponse parses an HTTP response from a DiscoverTunersWithResponse call
func ParseDiscoverTunersResponse(rsp *http.Response) (*DiscoverTunersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscoverTunersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TunerHostInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDiscvoverTunersResponse parses an HTTP response from a DiscvoverTunersWithResponse call
func ParseDiscvoverTunersResponse(rsp *http.Response) (*DiscvoverTunersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DiscvoverTunersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TunerHostInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseResetTunerResponse parses an HTTP response from a ResetTunerWithResponse call
func ParseResetTunerResponse(rsp *http.Response) (*ResetTunerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetTunerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCountriesResponse parses an HTTP response from a GetCountriesWithResponse call
func ParseGetCountriesResponse(rsp *http.Response) (*GetCountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CountryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetCulturesResponse parses an HTTP response from a GetCulturesWithResponse call
func ParseGetCulturesResponse(rsp *http.Response) (*GetCulturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCulturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CultureDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLocalizationOptionsResponse parses an HTTP response from a GetLocalizationOptionsWithResponse call
func ParseGetLocalizationOptionsResponse(rsp *http.Response) (*GetLocalizationOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalizationOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LocalizationOption
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetParentalRatingsResponse parses an HTTP response from a GetParentalRatingsWithResponse call
func ParseGetParentalRatingsResponse(rsp *http.Response) (*GetParentalRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParentalRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ParentalRating
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMovieRecommendationsResponse parses an HTTP response from a GetMovieRecommendationsWithResponse call
func ParseGetMovieRecommendationsResponse(rsp *http.Response) (*GetMovieRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RecommendationDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSimilarMoviesResponse parses an HTTP response from a GetSimilarMoviesWithResponse call
func ParseGetSimilarMoviesResponse(rsp *http.Response) (*GetSimilarMoviesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarMoviesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicGenresResponse parses an HTTP response from a GetMusicGenresWithResponse call
func ParseGetMusicGenresResponse(rsp *http.Response) (*GetMusicGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromMusicGenreByIdResponse parses an HTTP response from a GetInstantMixFromMusicGenreByIdWithResponse call
func ParseGetInstantMixFromMusicGenreByIdResponse(rsp *http.Response) (*GetInstantMixFromMusicGenreByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromMusicGenreByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicGenreResponse parses an HTTP response from a GetMusicGenreWithResponse call
func ParseGetMusicGenreResponse(rsp *http.Response) (*GetMusicGenreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicGenreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicGenreImageResponse parses an HTTP response from a GetMusicGenreImageWithResponse call
func ParseGetMusicGenreImageResponse(rsp *http.Response) (*GetMusicGenreImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicGenreImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadMusicGenreImageResponse parses an HTTP response from a HeadMusicGenreImageWithResponse call
func ParseHeadMusicGenreImageResponse(rsp *http.Response) (*HeadMusicGenreImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadMusicGenreImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetMusicGenreImageByIndexResponse parses an HTTP response from a GetMusicGenreImageByIndexWithResponse call
func ParseGetMusicGenreImageByIndexResponse(rsp *http.Response) (*GetMusicGenreImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMusicGenreImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadMusicGenreImageByIndexResponse parses an HTTP response from a HeadMusicGenreImageByIndexWithResponse call
func ParseHeadMusicGenreImageByIndexResponse(rsp *http.Response) (*HeadMusicGenreImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadMusicGenreImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromMusicGenreByNameResponse parses an HTTP response from a GetInstantMixFromMusicGenreByNameWithResponse call
func ParseGetInstantMixFromMusicGenreByNameResponse(rsp *http.Response) (*GetInstantMixFromMusicGenreByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromMusicGenreByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateAdminNotificationResponse parses an HTTP response from a CreateAdminNotificationWithResponse call
func ParseCreateAdminNotificationResponse(rsp *http.Response) (*CreateAdminNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdminNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNotificationServicesResponse parses an HTTP response from a GetNotificationServicesWithResponse call
func ParseGetNotificationServicesResponse(rsp *http.Response) (*GetNotificationServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NameIdPair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetNotificationTypesResponse parses an HTTP response from a GetNotificationTypesWithResponse call
func ParseGetNotificationTypesResponse(rsp *http.Response) (*GetNotificationTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NotificationTypeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetNotificationsResponse parses an HTTP response from a GetNotificationsWithResponse call
func ParseGetNotificationsResponse(rsp *http.Response) (*GetNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationResultDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetReadResponse parses an HTTP response from a SetReadWithResponse call
func ParseSetReadResponse(rsp *http.Response) (*SetReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNotificationsSummaryResponse parses an HTTP response from a GetNotificationsSummaryWithResponse call
func ParseGetNotificationsSummaryResponse(rsp *http.Response) (*GetNotificationsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationsSummaryDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetUnreadResponse parses an HTTP response from a SetUnreadWithResponse call
func ParseSetUnreadResponse(rsp *http.Response) (*SetUnreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetUnreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPackagesResponse parses an HTTP response from a GetPackagesWithResponse call
func ParseGetPackagesResponse(rsp *http.Response) (*GetPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseInstallPackageResponse parses an HTTP response from a InstallPackageWithResponse call
func ParseInstallPackageResponse(rsp *http.Response) (*InstallPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCancelPackageInstallationResponse parses an HTTP response from a CancelPackageInstallationWithResponse call
func ParseCancelPackageInstallationResponse(rsp *http.Response) (*CancelPackageInstallationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPackageInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPackageInfoResponse parses an HTTP response from a GetPackageInfoWithResponse call
func ParseGetPackageInfoResponse(rsp *http.Response) (*GetPackageInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPersonsResponse parses an HTTP response from a GetPersonsWithResponse call
func ParseGetPersonsResponse(rsp *http.Response) (*GetPersonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPersonResponse parses an HTTP response from a GetPersonWithResponse call
func ParseGetPersonResponse(rsp *http.Response) (*GetPersonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPersonImageResponse parses an HTTP response from a GetPersonImageWithResponse call
func ParseGetPersonImageResponse(rsp *http.Response) (*GetPersonImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadPersonImageResponse parses an HTTP response from a HeadPersonImageWithResponse call
func ParseHeadPersonImageResponse(rsp *http.Response) (*HeadPersonImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadPersonImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPersonImageByIndexResponse parses an HTTP response from a GetPersonImageByIndexWithResponse call
func ParseGetPersonImageByIndexResponse(rsp *http.Response) (*GetPersonImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadPersonImageByIndexResponse parses an HTTP response from a HeadPersonImageByIndexWithResponse call
func ParseHeadPersonImageByIndexResponse(rsp *http.Response) (*HeadPersonImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadPersonImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetBitrateTestBytesResponse parses an HTTP response from a GetBitrateTestBytesWithResponse call
func ParseGetBitrateTestBytesResponse(rsp *http.Response) (*GetBitrateTestBytesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBitrateTestBytesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePlaylistResponse parses an HTTP response from a CreatePlaylistWithResponse call
func ParseCreatePlaylistResponse(rsp *http.Response) (*CreatePlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlaylistCreationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromPlaylistResponse parses an HTTP response from a GetInstantMixFromPlaylistWithResponse call
func ParseGetInstantMixFromPlaylistResponse(rsp *http.Response) (*GetInstantMixFromPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRemoveFromPlaylistResponse parses an HTTP response from a RemoveFromPlaylistWithResponse call
func ParseRemoveFromPlaylistResponse(rsp *http.Response) (*RemoveFromPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveFromPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlaylistItemsResponse parses an HTTP response from a GetPlaylistItemsWithResponse call
func ParseGetPlaylistItemsResponse(rsp *http.Response) (*GetPlaylistItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseAddToPlaylistResponse parses an HTTP response from a AddToPlaylistWithResponse call
func ParseAddToPlaylistResponse(rsp *http.Response) (*AddToPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddToPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMoveItemResponse parses an HTTP response from a MoveItemWithResponse call
func ParseMoveItemResponse(rsp *http.Response) (*MoveItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPluginsResponse parses an HTTP response from a GetPluginsWithResponse call
func ParseGetPluginsResponse(rsp *http.Response) (*GetPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PluginInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUninstallPluginResponse parses an HTTP response from a UninstallPluginWithResponse call
func ParseUninstallPluginResponse(rsp *http.Response) (*UninstallPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPluginConfigurationResponse parses an HTTP response from a GetPluginConfigurationWithResponse call
func ParseGetPluginConfigurationResponse(rsp *http.Response) (*GetPluginConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BasePluginConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdatePluginConfigurationResponse parses an HTTP response from a UpdatePluginConfigurationWithResponse call
func ParseUpdatePluginConfigurationResponse(rsp *http.Response) (*UpdatePluginConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPluginManifestResponse parses an HTTP response from a GetPluginManifestWithResponse call
func ParseGetPluginManifestResponse(rsp *http.Response) (*GetPluginManifestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUninstallPluginByVersionResponse parses an HTTP response from a UninstallPluginByVersionWithResponse call
func ParseUninstallPluginByVersionResponse(rsp *http.Response) (*UninstallPluginByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallPluginByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDisablePluginResponse parses an HTTP response from a DisablePluginWithResponse call
func ParseDisablePluginResponse(rsp *http.Response) (*DisablePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisablePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseEnablePluginResponse parses an HTTP response from a EnablePluginWithResponse call
func ParseEnablePluginResponse(rsp *http.Response) (*EnablePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnablePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPluginImageResponse parses an HTTP response from a GetPluginImageWithResponse call
func ParseGetPluginImageResponse(rsp *http.Response) (*GetPluginImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRemoteSubtitlesResponse parses an HTTP response from a GetRemoteSubtitlesWithResponse call
func ParseGetRemoteSubtitlesResponse(rsp *http.Response) (*GetRemoteSubtitlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRemoteSubtitlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseConnectResponse parses an HTTP response from a ConnectWithResponse call
func ParseConnectResponse(rsp *http.Response) (*ConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuickConnectResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetEnabledResponse parses an HTTP response from a GetEnabledWithResponse call
func ParseGetEnabledResponse(rsp *http.Response) (*GetEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseInitiateResponse parses an HTTP response from a InitiateWithResponse call
func ParseInitiateResponse(rsp *http.Response) (*InitiateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuickConnectResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetActivityLogsResponse parses an HTTP response from a GetActivityLogsWithResponse call
func ParseGetActivityLogsResponse(rsp *http.Response) (*GetActivityLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReportHeadersResponse parses an HTTP response from a GetReportHeadersWithResponse call
func ParseGetReportHeadersResponse(rsp *http.Response) (*GetReportHeadersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportHeadersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemReportResponse parses an HTTP response from a GetItemReportWithResponse call
func ParseGetItemReportResponse(rsp *http.Response) (*GetItemReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReportDownloadResponse parses an HTTP response from a GetReportDownloadWithResponse call
func ParseGetReportDownloadResponse(rsp *http.Response) (*GetReportDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRepositoriesResponse parses an HTTP response from a GetRepositoriesWithResponse call
func ParseGetRepositoriesResponse(rsp *http.Response) (*GetRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RepositoryInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetRepositoriesResponse parses an HTTP response from a SetRepositoriesWithResponse call
func ParseSetRepositoriesResponse(rsp *http.Response) (*SetRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTasksResponse parses an HTTP response from a GetTasksWithResponse call
func ParseGetTasksResponse(rsp *http.Response) (*GetTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseStopTaskResponse parses an HTTP response from a StopTaskWithResponse call
func ParseStopTaskResponse(rsp *http.Response) (*StopTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseStartTaskResponse parses an HTTP response from a StartTaskWithResponse call
func ParseStartTaskResponse(rsp *http.Response) (*StartTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetTaskResponse parses an HTTP response from a GetTaskWithResponse call
func ParseGetTaskResponse(rsp *http.Response) (*GetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateTaskResponse parses an HTTP response from a UpdateTaskWithResponse call
func ParseUpdateTaskResponse(rsp *http.Response) (*UpdateTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetResponse parses an HTTP response from a GetWithResponse call
func ParseGetResponse(rsp *http.Response) (*GetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchHintResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSessionsResponse parses an HTTP response from a GetSessionsWithResponse call
func ParseGetSessionsResponse(rsp *http.Response) (*GetSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SessionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostCapabilitiesResponse parses an HTTP response from a PostCapabilitiesWithResponse call
func ParsePostCapabilitiesResponse(rsp *http.Response) (*PostCapabilitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostFullCapabilitiesResponse parses an HTTP response from a PostFullCapabilitiesWithResponse call
func ParsePostFullCapabilitiesResponse(rsp *http.Response) (*PostFullCapabilitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFullCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReportSessionEndedResponse parses an HTTP response from a ReportSessionEndedWithResponse call
func ParseReportSessionEndedResponse(rsp *http.Response) (*ReportSessionEndedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportSessionEndedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReportPlaybackStartResponse parses an HTTP response from a ReportPlaybackStartWithResponse call
func ParseReportPlaybackStartResponse(rsp *http.Response) (*ReportPlaybackStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportPlaybackStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePingPlaybackSessionResponse parses an HTTP response from a PingPlaybackSessionWithResponse call
func ParsePingPlaybackSessionResponse(rsp *http.Response) (*PingPlaybackSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingPlaybackSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReportPlaybackProgressResponse parses an HTTP response from a ReportPlaybackProgressWithResponse call
func ParseReportPlaybackProgressResponse(rsp *http.Response) (*ReportPlaybackProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportPlaybackProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReportPlaybackStoppedResponse parses an HTTP response from a ReportPlaybackStoppedWithResponse call
func ParseReportPlaybackStoppedResponse(rsp *http.Response) (*ReportPlaybackStoppedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportPlaybackStoppedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReportViewingResponse parses an HTTP response from a ReportViewingWithResponse call
func ParseReportViewingResponse(rsp *http.Response) (*ReportViewingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportViewingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendFullGeneralCommandResponse parses an HTTP response from a SendFullGeneralCommandWithResponse call
func ParseSendFullGeneralCommandResponse(rsp *http.Response) (*SendFullGeneralCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendFullGeneralCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendGeneralCommandResponse parses an HTTP response from a SendGeneralCommandWithResponse call
func ParseSendGeneralCommandResponse(rsp *http.Response) (*SendGeneralCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendGeneralCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendMessageCommandResponse parses an HTTP response from a SendMessageCommandWithResponse call
func ParseSendMessageCommandResponse(rsp *http.Response) (*SendMessageCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendMessageCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePlayResponse parses an HTTP response from a PlayWithResponse call
func ParsePlayResponse(rsp *http.Response) (*PlayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendPlaystateCommandResponse parses an HTTP response from a SendPlaystateCommandWithResponse call
func ParseSendPlaystateCommandResponse(rsp *http.Response) (*SendPlaystateCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPlaystateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendSystemCommandResponse parses an HTTP response from a SendSystemCommandWithResponse call
func ParseSendSystemCommandResponse(rsp *http.Response) (*SendSystemCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendSystemCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveUserFromSessionResponse parses an HTTP response from a RemoveUserFromSessionWithResponse call
func ParseRemoveUserFromSessionResponse(rsp *http.Response) (*RemoveUserFromSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddUserToSessionResponse parses an HTTP response from a AddUserToSessionWithResponse call
func ParseAddUserToSessionResponse(rsp *http.Response) (*AddUserToSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisplayContentResponse parses an HTTP response from a DisplayContentWithResponse call
func ParseDisplayContentResponse(rsp *http.Response) (*DisplayContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisplayContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNextUpResponse parses an HTTP response from a GetNextUpWithResponse call
func ParseGetNextUpResponse(rsp *http.Response) (*GetNextUpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNextUpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUpcomingEpisodesResponse parses an HTTP response from a GetUpcomingEpisodesWithResponse call
func ParseGetUpcomingEpisodesResponse(rsp *http.Response) (*GetUpcomingEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpcomingEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSimilarShowsResponse parses an HTTP response from a GetSimilarShowsWithResponse call
func ParseGetSimilarShowsResponse(rsp *http.Response) (*GetSimilarShowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarShowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetEpisodesResponse parses an HTTP response from a GetEpisodesWithResponse call
func ParseGetEpisodesResponse(rsp *http.Response) (*GetEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSeasonsResponse parses an HTTP response from a GetSeasonsWithResponse call
func ParseGetSeasonsResponse(rsp *http.Response) (*GetSeasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetInstantMixFromSongResponse parses an HTTP response from a GetInstantMixFromSongWithResponse call
func ParseGetInstantMixFromSongResponse(rsp *http.Response) (*GetInstantMixFromSongResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstantMixFromSongResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCompleteWizardResponse parses an HTTP response from a CompleteWizardWithResponse call
func ParseCompleteWizardResponse(rsp *http.Response) (*CompleteWizardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteWizardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStartupConfigurationResponse parses an HTTP response from a GetStartupConfigurationWithResponse call
func ParseGetStartupConfigurationResponse(rsp *http.Response) (*GetStartupConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStartupConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartupConfigurationDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateInitialConfigurationResponse parses an HTTP response from a UpdateInitialConfigurationWithResponse call
func ParseUpdateInitialConfigurationResponse(rsp *http.Response) (*UpdateInitialConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInitialConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFirstUser2Response parses an HTTP response from a GetFirstUser2WithResponse call
func ParseGetFirstUser2Response(rsp *http.Response) (*GetFirstUser2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFirstUser2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartupUserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSetRemoteAccessResponse parses an HTTP response from a SetRemoteAccessWithResponse call
func ParseSetRemoteAccessResponse(rsp *http.Response) (*SetRemoteAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRemoteAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFirstUserResponse parses an HTTP response from a GetFirstUserWithResponse call
func ParseGetFirstUserResponse(rsp *http.Response) (*GetFirstUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFirstUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartupUserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateStartupUserResponse parses an HTTP response from a UpdateStartupUserWithResponse call
func ParseUpdateStartupUserResponse(rsp *http.Response) (*UpdateStartupUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStartupUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStudiosResponse parses an HTTP response from a GetStudiosWithResponse call
func ParseGetStudiosResponse(rsp *http.Response) (*GetStudiosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudiosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetStudioResponse parses an HTTP response from a GetStudioWithResponse call
func ParseGetStudioResponse(rsp *http.Response) (*GetStudioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetStudioImageResponse parses an HTTP response from a GetStudioImageWithResponse call
func ParseGetStudioImageResponse(rsp *http.Response) (*GetStudioImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudioImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadStudioImageResponse parses an HTTP response from a HeadStudioImageWithResponse call
func ParseHeadStudioImageResponse(rsp *http.Response) (*HeadStudioImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadStudioImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetStudioImageByIndexResponse parses an HTTP response from a GetStudioImageByIndexWithResponse call
func ParseGetStudioImageByIndexResponse(rsp *http.Response) (*GetStudioImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStudioImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadStudioImageByIndexResponse parses an HTTP response from a HeadStudioImageByIndexWithResponse call
func ParseHeadStudioImageByIndexResponse(rsp *http.Response) (*HeadStudioImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadStudioImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSyncPlayBufferingResponse parses an HTTP response from a SyncPlayBufferingWithResponse call
func ParseSyncPlayBufferingResponse(rsp *http.Response) (*SyncPlayBufferingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayBufferingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayJoinGroupResponse parses an HTTP response from a SyncPlayJoinGroupWithResponse call
func ParseSyncPlayJoinGroupResponse(rsp *http.Response) (*SyncPlayJoinGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayJoinGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayLeaveGroupResponse parses an HTTP response from a SyncPlayLeaveGroupWithResponse call
func ParseSyncPlayLeaveGroupResponse(rsp *http.Response) (*SyncPlayLeaveGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayLeaveGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayGetGroupsResponse parses an HTTP response from a SyncPlayGetGroupsWithResponse call
func ParseSyncPlayGetGroupsResponse(rsp *http.Response) (*SyncPlayGetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayGetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GroupInfoDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseSyncPlayMovePlaylistItemResponse parses an HTTP response from a SyncPlayMovePlaylistItemWithResponse call
func ParseSyncPlayMovePlaylistItemResponse(rsp *http.Response) (*SyncPlayMovePlaylistItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayMovePlaylistItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayCreateGroupResponse parses an HTTP response from a SyncPlayCreateGroupWithResponse call
func ParseSyncPlayCreateGroupResponse(rsp *http.Response) (*SyncPlayCreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayCreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayNextItemResponse parses an HTTP response from a SyncPlayNextItemWithResponse call
func ParseSyncPlayNextItemResponse(rsp *http.Response) (*SyncPlayNextItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayNextItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayPauseResponse parses an HTTP response from a SyncPlayPauseWithResponse call
func ParseSyncPlayPauseResponse(rsp *http.Response) (*SyncPlayPauseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayPauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayPingResponse parses an HTTP response from a SyncPlayPingWithResponse call
func ParseSyncPlayPingResponse(rsp *http.Response) (*SyncPlayPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayPreviousItemResponse parses an HTTP response from a SyncPlayPreviousItemWithResponse call
func ParseSyncPlayPreviousItemResponse(rsp *http.Response) (*SyncPlayPreviousItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayPreviousItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayQueueResponse parses an HTTP response from a SyncPlayQueueWithResponse call
func ParseSyncPlayQueueResponse(rsp *http.Response) (*SyncPlayQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayReadyResponse parses an HTTP response from a SyncPlayReadyWithResponse call
func ParseSyncPlayReadyResponse(rsp *http.Response) (*SyncPlayReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayRemoveFromPlaylistResponse parses an HTTP response from a SyncPlayRemoveFromPlaylistWithResponse call
func ParseSyncPlayRemoveFromPlaylistResponse(rsp *http.Response) (*SyncPlayRemoveFromPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayRemoveFromPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySeekResponse parses an HTTP response from a SyncPlaySeekWithResponse call
func ParseSyncPlaySeekResponse(rsp *http.Response) (*SyncPlaySeekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySeekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySetIgnoreWaitResponse parses an HTTP response from a SyncPlaySetIgnoreWaitWithResponse call
func ParseSyncPlaySetIgnoreWaitResponse(rsp *http.Response) (*SyncPlaySetIgnoreWaitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySetIgnoreWaitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySetNewQueueResponse parses an HTTP response from a SyncPlaySetNewQueueWithResponse call
func ParseSyncPlaySetNewQueueResponse(rsp *http.Response) (*SyncPlaySetNewQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySetNewQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySetPlaylistItemResponse parses an HTTP response from a SyncPlaySetPlaylistItemWithResponse call
func ParseSyncPlaySetPlaylistItemResponse(rsp *http.Response) (*SyncPlaySetPlaylistItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySetPlaylistItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySetRepeatModeResponse parses an HTTP response from a SyncPlaySetRepeatModeWithResponse call
func ParseSyncPlaySetRepeatModeResponse(rsp *http.Response) (*SyncPlaySetRepeatModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySetRepeatModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlaySetShuffleModeResponse parses an HTTP response from a SyncPlaySetShuffleModeWithResponse call
func ParseSyncPlaySetShuffleModeResponse(rsp *http.Response) (*SyncPlaySetShuffleModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlaySetShuffleModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayStopResponse parses an HTTP response from a SyncPlayStopWithResponse call
func ParseSyncPlayStopResponse(rsp *http.Response) (*SyncPlayStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSyncPlayUnpauseResponse parses an HTTP response from a SyncPlayUnpauseWithResponse call
func ParseSyncPlayUnpauseResponse(rsp *http.Response) (*SyncPlayUnpauseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncPlayUnpauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogEntriesResponse parses an HTTP response from a GetLogEntriesWithResponse call
func ParseGetLogEntriesResponse(rsp *http.Response) (*GetLogEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityLogEntryQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetConfigurationResponse parses an HTTP response from a GetConfigurationWithResponse call
func ParseGetConfigurationResponse(rsp *http.Response) (*GetConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateConfigurationResponse parses an HTTP response from a UpdateConfigurationWithResponse call
func ParseUpdateConfigurationResponse(rsp *http.Response) (*UpdateConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultMetadataOptionsResponse parses an HTTP response from a GetDefaultMetadataOptionsWithResponse call
func ParseGetDefaultMetadataOptionsResponse(rsp *http.Response) (*GetDefaultMetadataOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultMetadataOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetadataOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetNamedConfigurationResponse parses an HTTP response from a GetNamedConfigurationWithResponse call
func ParseGetNamedConfigurationResponse(rsp *http.Response) (*GetNamedConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNamedConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateNamedConfigurationResponse parses an HTTP response from a UpdateNamedConfigurationWithResponse call
func ParseUpdateNamedConfigurationResponse(rsp *http.Response) (*UpdateNamedConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNamedConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEndpointInfoResponse parses an HTTP response from a GetEndpointInfoWithResponse call
func ParseGetEndpointInfoResponse(rsp *http.Response) (*GetEndpointInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndpointInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndPointInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSystemInfoResponse parses an HTTP response from a GetSystemInfoWithResponse call
func ParseGetSystemInfoResponse(rsp *http.Response) (*GetSystemInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPublicSystemInfoResponse parses an HTTP response from a GetPublicSystemInfoWithResponse call
func ParseGetPublicSystemInfoResponse(rsp *http.Response) (*GetPublicSystemInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicSystemInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicSystemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetServerLogsResponse parses an HTTP response from a GetServerLogsWithResponse call
func ParseGetServerLogsResponse(rsp *http.Response) (*GetServerLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LogFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLogFileResponse parses an HTTP response from a GetLogFileWithResponse call
func ParseGetLogFileResponse(rsp *http.Response) (*GetLogFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMediaEncoderPathResponse parses an HTTP response from a UpdateMediaEncoderPathWithResponse call
func ParseUpdateMediaEncoderPathResponse(rsp *http.Response) (*UpdateMediaEncoderPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMediaEncoderPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPingSystemResponse parses an HTTP response from a GetPingSystemWithResponse call
func ParseGetPingSystemResponse(rsp *http.Response) (*GetPingSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPingSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostPingSystemResponse parses an HTTP response from a PostPingSystemWithResponse call
func ParsePostPingSystemResponse(rsp *http.Response) (*PostPingSystemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPingSystemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseRestartApplicationResponse parses an HTTP response from a RestartApplicationWithResponse call
func ParseRestartApplicationResponse(rsp *http.Response) (*RestartApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseShutdownApplicationResponse parses an HTTP response from a ShutdownApplicationWithResponse call
func ParseShutdownApplicationResponse(rsp *http.Response) (*ShutdownApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShutdownApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWakeOnLanInfoResponse parses an HTTP response from a GetWakeOnLanInfoWithResponse call
func ParseGetWakeOnLanInfoResponse(rsp *http.Response) (*GetWakeOnLanInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWakeOnLanInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WakeOnLanInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseTmdbClientConfigurationResponse parses an HTTP response from a TmdbClientConfigurationWithResponse call
func ParseTmdbClientConfigurationResponse(rsp *http.Response) (*TmdbClientConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TmdbClientConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigImageTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTrailersResponse parses an HTTP response from a GetTrailersWithResponse call
func ParseGetTrailersResponse(rsp *http.Response) (*GetTrailersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrailersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSimilarTrailersResponse parses an HTTP response from a GetSimilarTrailersWithResponse call
func ParseGetSimilarTrailersResponse(rsp *http.Response) (*GetSimilarTrailersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimilarTrailersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseAuthenticateUserByNameResponse parses an HTTP response from a AuthenticateUserByNameWithResponse call
func ParseAuthenticateUserByNameResponse(rsp *http.Response) (*AuthenticateUserByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateUserByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseAuthenticateWithQuickConnectResponse parses an HTTP response from a AuthenticateWithQuickConnectWithResponse call
func ParseAuthenticateWithQuickConnectResponse(rsp *http.Response) (*AuthenticateWithQuickConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateWithQuickConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseForgotPasswordResponse parses an HTTP response from a ForgotPasswordWithResponse call
func ParseForgotPasswordResponse(rsp *http.Response) (*ForgotPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForgotPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForgotPasswordResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseForgotPasswordPinResponse parses an HTTP response from a ForgotPasswordPinWithResponse call
func ParseForgotPasswordPinResponse(rsp *http.Response) (*ForgotPasswordPinResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForgotPasswordPinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PinRedeemResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 400:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseCreateUserByNameResponse parses an HTTP response from a CreateUserByNameWithResponse call
func ParseCreateUserByNameResponse(rsp *http.Response) (*CreateUserByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetPublicUsersResponse parses an HTTP response from a GetPublicUsersWithResponse call
func ParseGetPublicUsersResponse(rsp *http.Response) (*GetPublicUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUserByIdResponse parses an HTTP response from a GetUserByIdWithResponse call
func ParseGetUserByIdResponse(rsp *http.Response) (*GetUserByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseAuthenticateUserResponse parses an HTTP response from a AuthenticateUserWithResponse call
func ParseAuthenticateUserResponse(rsp *http.Response) (*AuthenticateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateUserConfigurationResponse parses an HTTP response from a UpdateUserConfigurationWithResponse call
func ParseUpdateUserConfigurationResponse(rsp *http.Response) (*UpdateUserConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateUserEasyPasswordResponse parses an HTTP response from a UpdateUserEasyPasswordWithResponse call
func ParseUpdateUserEasyPasswordResponse(rsp *http.Response) (*UpdateUserEasyPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserEasyPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 403:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUnmarkFavoriteItemResponse parses an HTTP response from a UnmarkFavoriteItemWithResponse call
func ParseUnmarkFavoriteItemResponse(rsp *http.Response) (*UnmarkFavoriteItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnmarkFavoriteItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseMarkFavoriteItemResponse parses an HTTP response from a MarkFavoriteItemWithResponse call
func ParseMarkFavoriteItemResponse(rsp *http.Response) (*MarkFavoriteItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkFavoriteItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetGroupingOptionsResponse parses an HTTP response from a GetGroupingOptionsWithResponse call
func ParseGetGroupingOptionsResponse(rsp *http.Response) (*GetGroupingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SpecialViewOptionDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteUserImageResponse parses an HTTP response from a DeleteUserImageWithResponse call
func ParseDeleteUserImageResponse(rsp *http.Response) (*DeleteUserImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUserImageResponse parses an HTTP response from a GetUserImageWithResponse call
func ParseGetUserImageResponse(rsp *http.Response) (*GetUserImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadUserImageResponse parses an HTTP response from a HeadUserImageWithResponse call
func ParseHeadUserImageResponse(rsp *http.Response) (*HeadUserImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadUserImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostUserImageResponse parses an HTTP response from a PostUserImageWithResponse call
func ParsePostUserImageResponse(rsp *http.Response) (*PostUserImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUserImageByIndexResponse parses an HTTP response from a GetUserImageByIndexWithResponse call
func ParseGetUserImageByIndexResponse(rsp *http.Response) (*GetUserImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseHeadUserImageByIndexResponse parses an HTTP response from a HeadUserImageByIndexWithResponse call
func ParseHeadUserImageByIndexResponse(rsp *http.Response) (*HeadUserImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadUserImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteUserImageByIndexResponse parses an HTTP response from a DeleteUserImageByIndexWithResponse call
func ParseDeleteUserImageByIndexResponse(rsp *http.Response) (*DeleteUserImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParsePostUserImageByIndexResponse parses an HTTP response from a PostUserImageByIndexWithResponse call
func ParsePostUserImageByIndexResponse(rsp *http.Response) (*PostUserImageByIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserImageByIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemsByUserIdResponse parses an HTTP response from a GetItemsByUserIdWithResponse call
func ParseGetItemsByUserIdResponse(rsp *http.Response) (*GetItemsByUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsByUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLatestMediaResponse parses an HTTP response from a GetLatestMediaWithResponse call
func ParseGetLatestMediaResponse(rsp *http.Response) (*GetLatestMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetResumeItemsResponse parses an HTTP response from a GetResumeItemsWithResponse call
func ParseGetResumeItemsResponse(rsp *http.Response) (*GetResumeItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResumeItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetRootFolderResponse parses an HTTP response from a GetRootFolderWithResponse call
func ParseGetRootFolderResponse(rsp *http.Response) (*GetRootFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetItemResponse parses an HTTP response from a GetItemWithResponse call
func ParseGetItemResponse(rsp *http.Response) (*GetItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetIntrosResponse parses an HTTP response from a GetIntrosWithResponse call
func ParseGetIntrosResponse(rsp *http.Response) (*GetIntrosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntrosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetLocalTrailersResponse parses an HTTP response from a GetLocalTrailersWithResponse call
func ParseGetLocalTrailersResponse(rsp *http.Response) (*GetLocalTrailersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalTrailersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteUserItemRatingResponse parses an HTTP response from a DeleteUserItemRatingWithResponse call
func ParseDeleteUserItemRatingResponse(rsp *http.Response) (*DeleteUserItemRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserItemRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateUserItemRatingResponse parses an HTTP response from a UpdateUserItemRatingWithResponse call
func ParseUpdateUserItemRatingResponse(rsp *http.Response) (*UpdateUserItemRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserItemRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSpecialFeaturesResponse parses an HTTP response from a GetSpecialFeaturesWithResponse call
func ParseGetSpecialFeaturesResponse(rsp *http.Response) (*GetSpecialFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpecialFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUpdateUserPasswordResponse parses an HTTP response from a UpdateUserPasswordWithResponse call
func ParseUpdateUserPasswordResponse(rsp *http.Response) (*UpdateUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 403:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseMarkUnplayedItemResponse parses an HTTP response from a MarkUnplayedItemWithResponse call
func ParseMarkUnplayedItemResponse(rsp *http.Response) (*MarkUnplayedItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkUnplayedItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseMarkPlayedItemResponse parses an HTTP response from a MarkPlayedItemWithResponse call
func ParseMarkPlayedItemResponse(rsp *http.Response) (*MarkPlayedItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkPlayedItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserItemDataDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseOnPlaybackStoppedResponse parses an HTTP response from a OnPlaybackStoppedWithResponse call
func ParseOnPlaybackStoppedResponse(rsp *http.Response) (*OnPlaybackStoppedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OnPlaybackStoppedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOnPlaybackStartResponse parses an HTTP response from a OnPlaybackStartWithResponse call
func ParseOnPlaybackStartResponse(rsp *http.Response) (*OnPlaybackStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OnPlaybackStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOnPlaybackProgressResponse parses an HTTP response from a OnPlaybackProgressWithResponse call
func ParseOnPlaybackProgressResponse(rsp *http.Response) (*OnPlaybackProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OnPlaybackProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateUserPolicyResponse parses an HTTP response from a UpdateUserPolicyWithResponse call
func ParseUpdateUserPolicyResponse(rsp *http.Response) (*UpdateUserPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 403:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetSuggestionsResponse parses an HTTP response from a GetSuggestionsWithResponse call
func ParseGetSuggestionsResponse(rsp *http.Response) (*GetSuggestionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSuggestionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetUserViewsResponse parses an HTTP response from a GetUserViewsWithResponse call
func ParseGetUserViewsResponse(rsp *http.Response) (*GetUserViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseStopEncodingProcessResponse parses an HTTP response from a StopEncodingProcessWithResponse call
func ParseStopEncodingProcessResponse(rsp *http.Response) (*StopEncodingProcessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopEncodingProcessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMergeVersionsResponse parses an HTTP response from a MergeVersionsWithResponse call
func ParseMergeVersionsResponse(rsp *http.Response) (*MergeVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetAdditionalPartResponse parses an HTTP response from a GetAdditionalPartWithResponse call
func ParseGetAdditionalPartResponse(rsp *http.Response) (*GetAdditionalPartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdditionalPartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseDeleteAlternateSourcesResponse parses an HTTP response from a DeleteAlternateSourcesWithResponse call
func ParseDeleteAlternateSourcesResponse(rsp *http.Response) (*DeleteAlternateSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAlternateSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseUploadSubtitleResponse parses an HTTP response from a UploadSubtitleWithResponse call
func ParseUploadSubtitleResponse(rsp *http.Response) (*UploadSubtitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSubtitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubtitleResponse parses an HTTP response from a DeleteSubtitleWithResponse call
func ParseDeleteSubtitleResponse(rsp *http.Response) (*DeleteSubtitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubtitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetHlsPlaylistLegacyResponse parses an HTTP response from a GetHlsPlaylistLegacyWithResponse call
func ParseGetHlsPlaylistLegacyResponse(rsp *http.Response) (*GetHlsPlaylistLegacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsPlaylistLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHlsVideoSegmentLegacyResponse parses an HTTP response from a GetHlsVideoSegmentLegacyWithResponse call
func ParseGetHlsVideoSegmentLegacyResponse(rsp *http.Response) (*GetHlsVideoSegmentLegacyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsVideoSegmentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetHlsVideoSegmentResponse parses an HTTP response from a GetHlsVideoSegmentWithResponse call
func ParseGetHlsVideoSegmentResponse(rsp *http.Response) (*GetHlsVideoSegmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHlsVideoSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLiveHlsStreamResponse parses an HTTP response from a GetLiveHlsStreamWithResponse call
func ParseGetLiveHlsStreamResponse(rsp *http.Response) (*GetLiveHlsStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveHlsStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVariantHlsVideoPlaylistResponse parses an HTTP response from a GetVariantHlsVideoPlaylistWithResponse call
func ParseGetVariantHlsVideoPlaylistResponse(rsp *http.Response) (*GetVariantHlsVideoPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariantHlsVideoPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMasterHlsVideoPlaylistResponse parses an HTTP response from a GetMasterHlsVideoPlaylistWithResponse call
func ParseGetMasterHlsVideoPlaylistResponse(rsp *http.Response) (*GetMasterHlsVideoPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMasterHlsVideoPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadMasterHlsVideoPlaylistResponse parses an HTTP response from a HeadMasterHlsVideoPlaylistWithResponse call
func ParseHeadMasterHlsVideoPlaylistResponse(rsp *http.Response) (*HeadMasterHlsVideoPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadMasterHlsVideoPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVideoStreamResponse parses an HTTP response from a GetVideoStreamWithResponse call
func ParseGetVideoStreamResponse(rsp *http.Response) (*GetVideoStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideoStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadVideoStreamResponse parses an HTTP response from a HeadVideoStreamWithResponse call
func ParseHeadVideoStreamResponse(rsp *http.Response) (*HeadVideoStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadVideoStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVideoStreamByContainerResponse parses an HTTP response from a GetVideoStreamByContainerWithResponse call
func ParseGetVideoStreamByContainerResponse(rsp *http.Response) (*GetVideoStreamByContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideoStreamByContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseHeadVideoStreamByContainerResponse parses an HTTP response from a HeadVideoStreamByContainerWithResponse call
func ParseHeadVideoStreamByContainerResponse(rsp *http.Response) (*HeadVideoStreamByContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadVideoStreamByContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubtitlePlaylistResponse parses an HTTP response from a GetSubtitlePlaylistWithResponse call
func ParseGetSubtitlePlaylistResponse(rsp *http.Response) (*GetSubtitlePlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubtitlePlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubtitleResponse parses an HTTP response from a GetSubtitleWithResponse call
func ParseGetSubtitleResponse(rsp *http.Response) (*GetSubtitleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubtitleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubtitleWithTicksResponse parses an HTTP response from a GetSubtitleWithTicksWithResponse call
func ParseGetSubtitleWithTicksResponse(rsp *http.Response) (*GetSubtitleWithTicksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubtitleWithTicksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAttachmentResponse parses an HTTP response from a GetAttachmentWithResponse call
func ParseGetAttachmentResponse(rsp *http.Response) (*GetAttachmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetYearsResponse parses an HTTP response from a GetYearsWithResponse call
func ParseGetYearsResponse(rsp *http.Response) (*GetYearsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetYearsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDtoQueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetYearResponse parses an HTTP response from a GetYearWithResponse call
func ParseGetYearResponse(rsp *http.Response) (*GetYearResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetYearResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BaseItemDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetDurationHistogramReportResponse parses an HTTP response from a GetDurationHistogramReportWithResponse call
func ParseGetDurationHistogramReportResponse(rsp *http.Response) (*GetDurationHistogramReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDurationHistogramReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTvShowsReportResponse parses an HTTP response from a GetTvShowsReportWithResponse call
func ParseGetTvShowsReportResponse(rsp *http.Response) (*GetTvShowsReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTvShowsReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHourlyReportResponse parses an HTTP response from a GetHourlyReportWithResponse call
func ParseGetHourlyReportResponse(rsp *http.Response) (*GetHourlyReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHourlyReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMovieReportResponse parses an HTTP response from a GetMovieReportWithResponse call
func ParseGetMovieReportResponse(rsp *http.Response) (*GetMovieReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMovieReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageStatsResponse parses an HTTP response from a GetUsageStatsWithResponse call
func ParseGetUsageStatsResponse(rsp *http.Response) (*GetUsageStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLoadBackupResponse parses an HTTP response from a LoadBackupWithResponse call
func ParseLoadBackupResponse(rsp *http.Response) (*LoadBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveBackupResponse parses an HTTP response from a SaveBackupWithResponse call
func ParseSaveBackupResponse(rsp *http.Response) (*SaveBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCustomQueryResponse parses an HTTP response from a CustomQueryWithResponse call
func ParseCustomQueryResponse(rsp *http.Response) (*CustomQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTypeFilterListResponse parses an HTTP response from a GetTypeFilterListWithResponse call
func ParseGetTypeFilterListResponse(rsp *http.Response) (*GetTypeFilterListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypeFilterListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserReportResponse parses an HTTP response from a GetUserReportWithResponse call
func ParseGetUserReportResponse(rsp *http.Response) (*GetUserReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJellyfinUsersResponse parses an HTTP response from a GetJellyfinUsersWithResponse call
func ParseGetJellyfinUsersResponse(rsp *http.Response) (*GetJellyfinUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJellyfinUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIgnoreListAddResponse parses an HTTP response from a IgnoreListAddWithResponse call
func ParseIgnoreListAddResponse(rsp *http.Response) (*IgnoreListAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IgnoreListAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePruneUnknownUsersResponse parses an HTTP response from a PruneUnknownUsersWithResponse call
func ParsePruneUnknownUsersResponse(rsp *http.Response) (*PruneUnknownUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PruneUnknownUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIgnoreListRemoveResponse parses an HTTP response from a IgnoreListRemoveWithResponse call
func ParseIgnoreListRemoveResponse(rsp *http.Response) (*IgnoreListRemoveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IgnoreListRemoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBreakdownReportResponse parses an HTTP response from a GetBreakdownReportWithResponse call
func ParseGetBreakdownReportResponse(rsp *http.Response) (*GetBreakdownReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBreakdownReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserReportDataResponse parses an HTTP response from a GetUserReportDataWithResponse call
func ParseGetUserReportDataResponse(rsp *http.Response) (*GetUserReportDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserReportDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDashboardConfigurationPageResponse parses an HTTP response from a GetDashboardConfigurationPageWithResponse call
func ParseGetDashboardConfigurationPageResponse(rsp *http.Response) (*GetDashboardConfigurationPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDashboardConfigurationPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}

// ParseGetConfigurationPagesResponse parses an HTTP response from a GetConfigurationPagesWithResponse call
func ParseGetConfigurationPagesResponse(rsp *http.Response) (*GetConfigurationPagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurationPageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/json; profile="PascalCase") unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/json; profile="PascalCase") unsupported

	}

	return response, nil
}
